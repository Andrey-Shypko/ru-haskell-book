<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<p></p>
<h1 id="основы">Основы</h1>
<p>Есть мнение, что Haskell очень большой язык. Это и правда так. В Haskell много разных конструкций, синтаксического сахара, которые делают код более наглядным. Также в Haskell много библиотек на разные случаи жизни. Однако, обману ли я ваши ожидания, сказав, что всё это имеет достаточно компактную основу? Это и правда так, вам осталось лишь убедиться в наглядности и простоте Haskell. В этой главе мы пробежимся по нему, охватив одним взглядом целиком весь язык. Несколько наглядных конструкций, немного моих пояснений, и вы поймёте, что к чему. Если что-то сразу не станет ясно, или где-то я опущу какие-то пояснения, будьте уверены – в следующих главах мы обязательно обратимся к этим моментам и обсудим их подробнее.</p>
<h2 id="общая-картина">Общая картина</h2>
<p>Программы на Haskell бывают двух видов: это <em>приложения</em> (executable) и <em>библиотеки</em> (library). Приложения представляют собой исполняемые файлы, которые решают некоторую задачу, к примеру – это может быть компилятор языка, сортировщик данных в директориях, календарь, или цитатник на каждый день, любая полезная утилита. Библиотеки тоже решают задачи, но решают их внутри самого языка. Они содержат отдельные значения, функции, которые можно подключать к другой программе Haskell, и которыми можно пользоваться.</p>
<p>Программа состоит из <em>модулей</em> (module). И здесь работает правило: один модуль – один файл. Имя модуля совпадает с именем файла. Имя модуля начинается с большой буквы, тогда как файлы имеют расширение \In{.hs}. Например \In{FirstModule.hs}. Посмотрим на типичный модуль в Haskell:</p>

\begin{code}
--------------------------------------
-- шапка

module Имя(определение1, определение2,..., определениеN) where

import Модуль1(...)
import Модуль2(...)
...

---------------------------------------
-- определения

определение1
определение2
...
\end{code}

<p>Каждый модуль содержит набор определений. Относительно модуля определения делятся на <em>экспортируемые</em> и <em>внутренние</em>. Экспортируемые определения могут быть использованы за пределами модуля, а внутренние – только внутри модуля, и обычно они служат для выражения экспортируемых определений.</p>
<p>Модуль состоит из двух частей – шапки и определений.</p>
<dl>
<dt><em>Шапка</em></dt>
<dd><p>В шапке после слова \In{module} объявляется имя модуля, за которым в скобках следует список экспортируемых определений; после скобок стоит слово \In{where}. Затем идут импортируемые модули. С помощью импорта модулей вы имеете возможность в данном модуле пользоваться определениями из другого модуля.</p>
<p>Как после имени модуля, так и в директиве \In{import} скобки с определениями можно не писать,так как в этом случае считается, что экспортируются/импортируются все определения.</p>
</dd>
<dt><em>Определения</em></dt>
<dd><p>Эта часть содержит все определения модуля, при этом порядок следования определений не имеет значения. То есть, не обязательно пользоваться в данной функции лишь теми значениями, что были определены выше.</p>
</dd>
</dl>
<p>Модули взаимодействуют друг с другом с помощью экспортируемых определений. Один модуль может сказать, что он хочет воспользоваться экспортируемыми определениями другого модуля, для этого он пишет \In{import Модуль(определения)}. Модуль – это айсберг, на вершине которого – те функции, ради которых он создавался (экспортируемые), а под водой – все служебные детали реализации (внутренние).</p>
<p>Итак, программа состоит из модулей, модули состоят из определений. Но что такое определения?</p>
<p>В Haskell определения могут описывать четыре вида сущностей:</p>
<ul>
<li><p>Типы.</p></li>
<li><p>Значения.</p></li>
<li><p>Классы типов.</p></li>
<li><p>Экземпляры классов типов.</p></li>
</ul>
<p>Теперь давайте рассмотрим их подробнее.</p>
<h2 id="типы">Типы</h2>
<p>Типы представляют собой каркас программы. Они кратко описывают все возможные значения. Это очень удобно. Опытный программист на Haskell может понять смысл функции по её названию и типу. Это не очень сложно. Например, мы видим:</p>

\begin{code}
not :: Bool -> Bool
\end{code}

<p>Выражение \In{v :: T} означает, что значение \In{v} имеет тип \In{T}. Стрелка \In{a -> b} означает функцию, то есть из \In{a} мы можем получить \In{b}. Итак, перед нами функция из \In{Bool} в \In{Bool}, под названием \In{not}. Мы можем предположить, что это логическая операция “не”. Или, перед нами такое определение типа:</p>

\begin{code}
reverse :: [a] -> [a]
\end{code}

<p>Мы видим функцию с именем \In{reverse}, которая принимает список \In{[a]} и возвращает список \In{[a]}, и мы можем догадаться, что эта функция переворачивает список, то есть мы получаем список, у которого элементы идут в обратном порядке. Маленькая буква \In{a} в \In{[a]} является параметром типа, на место параметра может быть поставлен любой тип. Она говорит о том, что список содержит элементы типа \In{a}. Например, такая функция соглашается переворачивать только списки логических значений:</p>

\begin{code}
reverseBool :: [Bool] -> [Bool]
\end{code}

<p>Программа представляет собой описание некоторого явления или процесса. Типы определяют основные слова или термины и способы их комбинирования. А значения представляют собой комбинации базовых слов. Но значения комбинируются не произвольным образом, а на основе определённых правил, которые задаются типами.</p>
<p>Например, такое выражение определяет тип, в котором два базовых термина \In{True} или \In{False}</p>

\begin{code}
data Bool = True | False
\end{code}

<p>Слово \In{data} ключевое, с него начинается любое определение нового типа. Символ \In{|} означает или. Наш новый тип \In{Bool} является либо словом \In{True}, либо словом \In{False}. В этом типе есть только понятия, но нет способов комбинирования, посмотрим на тип, в котором есть и то, и другое:</p>

\begin{code}
data [a] = [] | a : [a]
\end{code}

<p>Это определение списка. Как мы уже поняли, \In{a} – это параметр. Список \In{[a]} может быть либо пустым списком \In{[]}, либо комбинацией \In{a : [a]}. В этой комбинации знак \In{:} объединяет элемент типа \In{a} и ещё один список \In{[a]}. Это рекурсивное определение, они встречаются в Haskell очень часто. Если это пока кажется непонятным, не пугайтесь, в следующих главах будет представлено много примеров с пояснениями.</p>
<p>Приведём ещё несколько примеров определений; ниже типы определяют базовые понятия для мира календаря: то что стоит за \In{--} является комментарием и игнорируется при выполнении программы:</p>

\begin{code}
-- Дата
data Date = Date Year Month Day

-- Год
data Year  = Year Int       -- Int это целые числа

-- Месяц
data Month  = January    | February   | March    | April          
            | May        | June       | July     | August   
            | September  | October    | November | December 

data Day = Day Int

-- Неделя
data Week  = Monday     | Tuesday   | Wednesday 
           | Thursday   | Friday    | Saturday     
           | Sunday     

-- Время
data Time = Time Hour Minute Second

data Hour   = Hour   Int    -- Час
data Minute = Minute Int    -- Минута
data Second = Second Int    -- Секунда
\end{code}

<p>Одной из основных целей разработчиков Haskell была ясность. Они стремились создать язык, предложения которого будут простыми и понятными, близкий к языку спецификаций.</p>
<p>С символом \In{|} мы уже познакомились, он указывает на альтернативы, объединение пишется через пробел. Так, фраза</p>

\begin{code}
data Time = Time Hour Minute Second
\end{code}

<p>означает, что тип \In{Time} – это значение с меткой \In{Time}, которое состоит из значений типов “час”, “время” и “секунда”, и больше ничего. Метку принято называть <em>конструктором</em>.</p>
<p>Фраза</p>

\begin{code}
data Year = Year Int
\end{code}

<p>означает, что тип \In{Year} – это значение с конструктором \In{Year}, которое состоит из одного значения типа \In{Int}. Конструктор обычно идёт первым, а за ним через пробел следуют другие типы. Конструктор может быть и самостоятельным значением, как в случае \In{True} или \In{January}.</p>
<p>Типы делят выполнение программы на две стадии: <em>компиляцию</em> (compile-time) и <em>вычисление</em> (run-time). На этапе компиляции происходит проверка типов. Программа, которая не прошла проверку типов, считается бессмысленной и не вычисляется. Приложение, которое выполняет компиляцию, называют <em>компилятором</em> (compiler), а то приложение, которое проводит вычисление, называют <em>вычислителем</em> (run-time system).</p>
<p>Типами мы определяем основные понятия в том явлении, которое мы хотим описать, а также осмысленные способы их комбинирования. Мы говорим, как из простейших терминов получаются составные. Если мы попытаемся построить бессмысленное предложение, компилятор языка автоматически найдёт такое предложение и сообщит нам об этом. Этот процесс заключается в проверке типов, к примеру если у нас есть функция сложения чисел, и мы попытаемся передать в неё строку или список, компилятор заметит это и скажет нам об этом <em>перед</em> тем как программа начнёт выполнятся. И важно то, что это произойдёт очень быстро. Если мы случайно ошиблись в выражении, которое будет вычислено через час, нам не нужно ждать пока вычислитель дойдёт до ошибки, мы узнаем об этом, не успев моргнуть, после запуска программы.</p>
<p>Итак, если мы попробуем составить время из месяцев и логических значений:</p>

\begin{code}
Time January True 23
\end{code}

<p>компилятор предупредит нас об ошибке. Наверное, вы думаете, что приведенный пример надуман, ведь кому захочется составлять время из логических значений? Но когда вы пишете программу, часто процесс работы складывается так: вы думаете над одним, пишете другое, а также планируете вернуться к третьему. И знание того, что есть надежный компилятор, который не пропустит глупых ошибок, освобождает руки, вы можете не заботиться о таких пустяках, как правильное построение предложения.</p>
<p>Отметим, что такой подход с разделением вычисления на две стадии и проверкой типов называется <em>статической типизацией</em>. Есть и другие языки, в них типы лишь подразумеваются и программа сразу начинает вычисляться, если есть какие-то несоответствия, об ошибке программисту сообщит вычислитель, причём только тогда, когда вычисление дойдёт до ошибки. Такой подход называют <em>динамической типизацией</em>.</p>
<p>Типы требуют серьёзных размышлений на начальном этапе, этапе определения базовых терминов и способов их комбинирования. Не упускаем ли мы что-то важное из виду, или, может быть, типы имеют слишком общий характер и допускают ненужные нам предложения? Приходится задумываться. Но если типы подобраны удачно, они сами начинают подсказывать, как строить программу.</p>
<h2 id="значения">Значения</h2>
<p>Итак, мы определили типами базовые понятия и способы комбинирования. Обычно это небольшой набор слов. Например в логических выражениях всего лишь два слова. Можем ли мы на что либо рассчитывать с таким словарным запасом? Оказывается, что да. Здесь на помощь приходят синонимы. Сейчас у нас в активе лишь два слова:</p>

\begin{code}
data Bool = True | False
\end{code}

<p>И мы можем определить два синонима:</p>

\begin{code}
true :: Bool
true = True

false :: Bool
false = False
\end{code}

<p>В Haskell синонимы пишутся с маленькой буквы. Синоним определяется через знак \In{=}. Обратите внимание на то, что это не процесс вычисления значения. Мы всего лишь объявляем новое имя для комбинации слов.</p>
<p>Теперь мы имеем целых четыре слова! Тем не менее, ушли мы не далеко, и два новых слова, в сущности, не делают язык выразительнее. Такие синонимы называют <em>константами</em>. Это значит, что одним словом мы будем обозначать некоторую комбинацию других слов. В данном случае комбинации очень простые.</p>
<p>Но наши синонимы могут определять одни слова через другие. Синонимы могут принимать параметры. Параметры пишутся через пробел между новым именем и знаком равно:</p>

\begin{code}
not :: Bool -> Bool
not True  = False
not False = True
\end{code}

<p>Мы определили новое имя \In{not} с типом \In{Bool -> Bool}. Оно определяется двумя <em>уравнениями</em> (clause). Слева от знака равно левая часть уравнения, а справа – правая. В первом уравнении мы говорим, что сочетание \In{(not True)} означает \In{False}, а сочетание \In{(not False)} означает \In{True}. Опять же, мы ничего не вычисляем, мы даём новые имена нашим константам \In{True} и \In{False}. Только в этом случае имена составные.</p>
<p>Если вычислителю нужно узнать, что кроется за составным именем \In{not False} он <em>последовательно</em> проанализирует уравнения сверху вниз, до тех пор, пока левая часть уравнения не совпадёт со значением <em>not False</em>. Сначала мы сверим с первым:</p>

\begin{code}
not True   == not False     -- нет, пошли дальше
not False  == not False     -- эврика, вернём правую часть
=> True
\end{code}

<p>Определим ещё два составных имени</p>

\begin{code}
and :: Bool -> Bool -> Bool
and False  _  = False
and True   x  = x

or  :: Bool -> Bool -> Bool
or True   _ = True
or False  x = x
\end{code}

<p>Эти синонимы определяют логические операции “и” и “или”. Здесь несколько новых конструкций, но вы не пугайтесь, они не так трудны для понимания. Начнём с \In{_}:</p>

\begin{code}
and False  _  = False
\end{code}

<p>Здесь cимвол \In{_} означает, что в этом уравнении, если первый параметр равен \In{False}, то второй нам уже не важен, мы знаем ответ. Так, если в логическом “и” один из аргументов равен \In{False}, то всё выражение равно \In{False}. Так же и в случае с \In{or}.</p>
<p>Теперь другая новая конструкция:</p>

\begin{code}
and True   x  = x
\end{code}

<p>В этом случае параметр \In{x} служит для того, чтобы перетащить значение из аргумента в результат. Конкретное значение нам также не важно, но в этом случае мы полагаем, что слева и справа от \In{=}, \In{x} имеет одно и то же значение.</p>
<p>Итак у нас уже целых семь имён: \In{True}, \In{False}, \In{true}, \In{false}, \In{not}, \In{and}, \In{or}. Или не семь? На самом деле, их уже бесконечное множество. Поскольку три из них составные, мы можем создавать самые разнообразные комбинации:</p>

\begin{code}
not (and true False)
or (and true true) (or False False)
not (not true)
not (or (or True True) (or False (not True)))
...
\end{code}

<p>Обратите внимание на использование скобок, они группируют значения. Так, если бы мы написали \In{not not true} вместо \In{not (not true)}, мы бы получили ошибку компиляции, потому что \In{not} ожидает один параметр, а в выражении \In{not not true} их два. Параметры дописываются к имени через пробел.</p>
<p>Посмотрим, как происходят вычисления. В сущности, процесса вычислений нет, есть процесс замены синонимов на основные понятия согласно уравнениям. Базовые понятия мы определили в типах. Так давайте “вычислим” выражение \In{not (and true False)}:</p>

\begin{code}
-- выражение            --  уравнение

not (and true False)    --  true        = True
not (and True False)    --  and True  x = x     => and True False = False
not False               --  not False   = True
True
\end{code}

<p>Слева в столбик написаны шаги “вычисления”, а справа уравнения, по которым синонимы заменяются на комбинации слов. Процесс замены синонима (левой части уравнения) на комбинацию слов (правую часть уравнения) называется <em>редукцией</em> (reduction).</p>
<p>Сначала мы заменили синоним \In{true} на правую часть его уравнения, тo есть на конструктор \In{True}. Затем мы заменили выражение \In{(and True False)} на правую часть из уравнения для синонима \In{and}. Обратите внимание на то, что переменная \In{x} была заменена на значение \In{False}. Последним шагом была замена синонима \In{not}. В конце концов мы пришли к базовому понятию, а именно – к одному из двух конструкторов. В данном случае \In{True}.</p>
<p>Интересно, что новые синонимы могут быть использованы в правых частях уравнений. Так мы можем определить операцию “исключающее или”:</p>

\begin{code}
xor :: Bool -> Bool -> Bool
xor a b = or (and (not a) b) (and a (not b))
\end{code}

<p>Этим выражением мы говорим, что \In{xor a b} это или отрицание \In{a} и \In{b}, или \In{a} и отрицание \In{b}. Это и есть определение “исключающего или”.</p>
<p>Может показаться, что с типом \In{Bool} мы зациклены на двух конструкторах, и единственное, что нам остаётся – это давать всё новые и новые имена словам \In{True} и \In{False}. Но на самом деле это не так. С помощью типов-параметров мы можем выйти за эти рамки. Определим функцию ветвления \In{ifThenElse}:</p>

\begin{code}
ifThenElse :: Bool -> a -> a -> a
ifThenElse True   t  _ = t
ifThenElse False  _  e = e
\end{code}

<p>Эта функция первым аргументом принимает значение типа \In{Bool}, а вторым и третьим – альтернативы некоторого типа \In{a}. Если первый аргумент – \In{True}, возвращается второй аргумент, а если – \In{False}, то третий.</p>
<p>Интересно, что в Haskell ничего не происходит, мир Haskell-значений стоит на месте. Мы просто даём имена разным комбинациям слов. Определяем новые термины. Потом на этих терминах определяем новые термины, и так далее. Кажется, если ничего не меняется, то зачем язык? И что мы собираемся программировать без вычислений?</p>
<p>Разгадка кроется в функциях \In{not}, \In{and} и \In{or}. До того как мы их определили, у нас было четыре имени, но после их определения имён стало бесконечное множество. Три синонима пополнили наш язык бесконечным набором комбинаций. В этом суть. Мы определяем базовые элементы и способы составления новых, потом мы просим &quot;вычислить’ комбинацию из них. Мы не определяли явно, чему равна комбинация \In{not (and true False)}, это сделал за нас вычислитель Haskell<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>.</p>
<p>Вычислить стоит в кавычках, потому что на самом деле вычислений нет, есть замена синонимов на комбинации простейших элементов.</p>
<p>Ещё один пример, положим у нас есть тип:</p>

\begin{code}
data Status = Work | Rest
\end{code}

<p>Он определяет, что делать в данный день: работать (\In{Work}) или отдыхать (\In{Rest}). У разных рабочих разный график. Например, есть функции:</p>

\begin{code}
jonny :: Week -> Status
jonny x = ...

colin :: Week -> Status
colin x = ...
\end{code}

<p>Конкретное определение сейчас не важно, важно, что они определяют зависимость статуса (\In{Status}) от дня недели (\In{Week}) для работников Джонни (\In{jonny}) и Колина (\In{colin}).</p>
<p>Также у нас есть полезная функция:</p>

\begin{code}
calendar :: Date -> Week
calendar x = ...
\end{code}

<p>Она определяет по дате день недели. И теперь, зная лишь эти функции, мы можем спросить у вычислителя будет ли у Джонни выходной 8 августа 3043 года:</p>

\begin{code}
jonny (calendar (Date (Year 3043) August (Day 8)))
=> jonny Saturday
=> Rest
\end{code}

<p>Интересно, у нас опять всего лишь два значения, но, дав такое большое имя одному из значений, мы смогли получить полезную нам информацию, ничего не вычисляя.</p>
<h2 id="классы-типов">Классы типов</h2>
<p>Если типы и значения – привычные понятия, которые можно найти в том или ином виде в любом языке программирования, то термин класс типов встречается не часто. У него нет аналогов и в обычном языке, поэтому я сначала постараюсь объяснить его смысл на примере.</p>
<p>В типизированном языке у каждой функции есть тип, но бывают функции, которые могут быть определены на аргументах разных типов; по сути, они описывают схожие понятия, но определены для значений разных типов. Например, функция сравнения на равенство, говорящая о том, что два значения одного типа \In{a} равны, имеет тип \In{a -> a -> Bool}, или функция печати выражения имеет тип \In{a -> String}, но что такое \In{a} в этих типах? Тип \In{a} является любым типом, для которого сравнение на равенство или печать (преобразование в строку) имеют смысл. Это понятие как раз и кодируется в классах типов. \In{Классы типов} (type class) позволяют определять функции с одинаковым именем для разных типов.</p>
<p>У классов типов есть имена. Также как и имена классов, они начинаются с большой буквы. Например, класс сравнений на равенство называется \In{Eq} (от англ. <em>equals</em> – равняется), а класс печати выражений имеет имя \In{Show} (от англ. <em>show</em> – показывать). Посмотрим на их определения:</p>
<p>Класс \In{Eq}:</p>

\begin{code}
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
\end{code}

<p>Класс \In{Show}:</p>

\begin{code}
class Show a where
    show :: a -> String
\end{code}

<p>За ключевым словом \In{class} следует имя класса, тип-параметр и ещё одно ключевое слово \In{where}. Далее с отступами пишутся имена определённых в классе значений. Значения класса называются <em>методами</em>.</p>
<p>Мы определяем лишь типы методов, конкретная реализация будет зависеть от типа \In{a}. Методы определяются в экземплярах классов типов, мы скоро к ним перейдём.</p>
<p>Программистская аналогия класса типов это интерфейс. В интерфейсе определён набор значений (как констант, так и функций), которые могут быть применены ко всем типам, которые поддерживают данный интерфейс. К примеру, в интерфейсе “сравнение на равенство” для некоторого типа \In{a} определены две функции: равно \In{(==)} и не равно \In{(/=)} с одинаковым типом \In{a -> a -> Bool}, или в интерфейсе “печати” для любого типа \In{a} определена одна функция \In{show} типа \In{a -> String}.</p>
<p>Математическая аналогия класса типов это алгебраическая система. Алгебра изучает свойства объекта в терминах операций, определённых на нём, и взаимных ограничениях этих операций. Алгебраическая система представляет собой набор операций и свойств этих операций. Этот подход позволяет абстрагироваться от конкретного представления объектов. Например группа – это все объекты данного типа \In{a}, для которых определены значения: константа – единица типа \In{a}, бинарная операция типа \In{a -> a -> a} и операция взятия обратного элемента, типа \In{a -> a}. При этом на операции накладываются ограничения, называемые свойствами операций. Например, ассоциативность бинарной операции, или тот факт, что единица с любым другим элементом, применённые к бинарной операции, дают на выходе исходный элемент.</p>
<p>Давайте определим класс для группы:</p>

\begin{code}
class Group a where
    e   :: a
    (+) :: a -> a -> a
    inv :: a -> a
\end{code}

<p>Класс с именем \In{Group} имеет для некоторого типа \In{a} три метода: константу \In{e :: a}, операцию \In{(+) :: a -> a -> a} и операцию взятия обратного элемента \In{inv :: a -> a}.</p>
<p>Как и в алгебре, в Haskell классы типов позволяют описывать сущности в терминах определённых на них операций или значений. В примерах мы указываем лишь наличие операций и их типы, так же и в классах типов. Класс типов содержит набор имён его значений с информацией о типах значений.</p>
<p>Определив класс \In{Group}, мы можем начать строить различные выражения, которые будут потом интерпретироваться специфическим для типа образом:</p>

\begin{code}
twice :: Group a => a -> a
twice a = a + a

isE :: (Group a, Eq a) => a -> Bool
isE x = (x == e)
\end{code}

<p>Обратите внимание на запись \In{Group a =>} и \In{(Group a, Eq a) =>}. Это называется контекстом объявления типа. В контексте мы говорим, что данный тип должен быть из класса \In{Group} или из классов \In{Group} и \In{Eq}. Это значит, что для этого типа мы можем пользоваться методами из этих классов.</p>
<p>В первой функции \In{twice} мы воспользовались методом \In{(+)} из класса \In{Group}, поэтому функция имеет контекст \In{Group a =>}. А во второй функции \In{isE} мы воспользовались методом \In{e} из класса \In{Group} и методом \In{(==)} из класса \In{Eq}, поэтому функция имеет контекст \In{(Group a, Eq a) =>}.</p>
<h3 id="контекст-классов-типов.-суперклассы">Контекст классов типов. Суперклассы</h3>
<p>Класс типов также может содержать контекст. Он указывается между словом \In{class} и именем класса. Например</p>

\begin{code}
class IsPerson a

class IsPerson a => HasName a where
    name :: a -> String
\end{code}

<p>Это определение говорит о том, что мы можем сделать экземпляр класса \In{HasName} только для тех типов, которые содержатся в \In{IsPerson}. Мы говорим, что класс \In{HasName} содержится в \In{IsPerson}. В этом случае класс из контекста \In{IsPerson} называют <em>суперклассом</em> для данного класса \In{HasName}.</p>
<p>Это сказывается на контексте объявления типа. Теперь, если мы пишем</p>

\begin{code}
fun :: HasName a => a -> a
\end{code}

<p>Это означает, что мы можем пользоваться для значений типа \In{a} как методами из класса \In{HasName}, так и методами из класса \In{IsPerson}. Поскольку если тип принадлежит классу \In{HasName}, то он также принадлежит и \In{IsPerson}.</p>
<p>Запись \In{(IsPerson a => HasName a)} немного обманывает, было бы точнее писать \In{IsPerson a <= HasName a}, если тип \In{a} в классе \In{HasName}, то он точно в классе \In{IsPerson}, но в Haskell закрепилась другая запись.</p>
<h2 id="экземпляры-классов-типов">Экземпляры классов типов</h2>
<p>В <em>экземплярах</em> (instance) классов типов мы даём конкретное наполнение для методов класса типов. Определение экземпляра пишется так же, как и определение класса типа, но вместо \In{class} мы пишем \In{instance}, вместо некоторого типа наш конкретный тип, а вместо типов методов – уравнения для них.</p>
<p>Определим экземпляры для \In{Bool}</p>
<p>Класс \In{Eq}:</p>

\begin{code}
instance Eq Bool where
    (==) True  True  = True
    (==) False False = True
    (==) _     _     = False

    (/=) a b         = not (a == b)
\end{code}

<p>Класс \In{Show}:</p>

\begin{code}
instance Show Bool where
    show True  = "True"
    show False = "False"
\end{code}

<p>Класс \In{Group}:</p>

\begin{code}
instance Group Bool where
    e       = True
    (+) a b = and a b
    inv a   = not a
\end{code}

<p>Отметим важность наличия свойств (ограничений) у значений, определённых в классе типов. Так, например, в классе типов “сравнение на равенство” для любых двух значений данного типа одна из операций должна вернуть “истину”, а другая “ложь”, т.е.~два элемента данного типа либо равны, либо не равны. Недостаточно определить равенство для конкретного типа, необходимо убедиться в том, что для всех элементов данного типа свойства понятия равенства не нарушаются.</p>
<p>На самом деле приведённое выше определение экземпляра для \In{Group} не верно, хотя по типам оно подходит. Оно не верно как раз из-за нарушения свойств. Для группы необходимо, чтобы для любого \In{a} выполнялось:</p>

\begin{code}
 inv a + a == e
\end{code}

<p>У нас лишь два значения, и это свойство не выполняется ни для одного из них. Проверим:</p>

\begin{code}
    inv True   + True
 => (not True) + True
 => False      + True
 => and False    True
 => False

    inv False   + False
 => (not False) + False
 => True        + False
 => and True      False
 => False
\end{code}

<p>Проверять свойства очень важно, потому что другие люди, читая ваш код и используя ваши функции, будут на них рассчитывать.</p>
<h2 id="ядро-haskell">Ядро Haskell</h2>
<p>Фуууухх. Мы закончили наш пробег. Теперь можно остановиться, отдышаться и подвести итоги. Давайте вспомним синтаксические конструкции, которые нам встретились.</p>
<h4 id="модули">Модули</h4>

\begin{code}
module New(edef1, edef2, ..., edefN) where

import Old1(idef11, idef12, ..., idef1N)
import Old2(idef21, idef22, ..., idef2M)
...
import OldK(idefK1, idefK2, ..., idefKP)

-- определения :
...
\end{code}

<p>Ключевые слова: \In{module}, \In{where}, \In{import}. Мы определили модуль с именем \In{New}, который экспортирует определения \In{edef1}, \In{edef2}, … , \In{edefN}. И импортирует определения из модулей \In{Old1}, \In{Old2}, и т.д., определения написаны в скобках за ключевыми словами \In{import} и именами модулей.</p>
<h4 id="типы-1">Типы</h4>
<p>Тип определяется с помощью:</p>
<ul>
<li><p>Перечисления альтернатив через \In{|}</p>

\begin{code}
data Type = Alt1 | Alt2 | ... | AltN
\end{code}

<p>Эту операцию называют <em>суммой</em> типов.</p></li>
<li><p>Составления сложного типа из подтипов, пишем конструктор первым, затем через пробел подтипы:</p>

\begin{code}
data Type = Name  Sub1  Sub2  ...  SubN
\end{code}

<p>Эту операцию называют <em>произведением</em> типов.</p>
<p>Есть одно исключение: если тип состоит из двух подтипов, мы можем дать конструктору символьное (а не буквенное) имя, но оно должно начинаться с двоеточия \In{:}, как в случае списка, например, можно делать такие определения типов:</p>

\begin{code}
data Type = Sub1 :+ Sub2 
data Type = Sub1 :| Sub2 
\end{code}
</li>
<li><p>Комбинации суммы и произведения типов:</p>

\begin{code}
data Type = Name1  Sub11  Sub12  ...  Sub1N
          | Name2  Sub21  Sub22  ...  Sub2M
          ...
          | NameK  SubK1  SubK2  ...  SubKP
\end{code}
</li>
</ul>
<p>Такие типы называют <em>алгебраическими типами данных</em>. С помощью типов мы определяем основные понятия и способы их комбинирования.</p>
<h4 id="значения-1">Значения</h4>
<p>Как это ни странно, нам встретилась лишь одна операция создания значений: <em>определение синонима</em>. Она пишется так</p>

\begin{code}
name x1  x2 ... xN = Expr1
name x1  x2 ... xN = Expr2
name x1  x2 ... xN = Expr3
\end{code}

<p>Слева от знака равно стоит составное имя, а справа от знака равно некоторое выражение, построенное согласно типам. Разные комбинации имени \In{name} с параметрами определяют разные уравнения для синонима \In{name}.</p>
<p>Также мы видели символ \In{_}, который означает “всё, что угодно” на месте аргумента. А также мы увидели, как с помощью переменных можно перетаскивать значения из аргументов в результат.</p>
<h4 id="классы-типов-1">Классы типов</h4>
<p>Нам встретилась одна конструкция определения классов типов:</p>

\begin{code}
class Name a where
    method1 :: a -> ...
    method2 :: a -> ...
    ...
    methodN :: a -> ...
\end{code}

<h4 id="экземпляры-классов-типов-1">Экземпляры классов типов</h4>
<p>Нам встретилась одна конструкция определения экземпляров классов типов:</p>

\begin{code}
instance Name Type where
    method1 x1 ... xN = ...
    method2 x1 ... xM = ...
    ...
    methodN x1 ... xP = ...
\end{code}

<h4 id="типы-значения-и-классы-типов">Типы, значения и классы типов</h4>
<p>Каждое значение имеет тип. Значение \In{v} имеет тип \In{T} на Haskell:</p>

\begin{code}
v :: T
\end{code}

<p>Функциональный тип обозначается стрелкой: \In{a -> b}</p>

\begin{code}
fun :: a -> b
\end{code}

<p>Тип значения может иметь контекст, он говорит о том, что параметр должен принадлежать классу типов:</p>

\begin{code}
fun1 :: С a                 => a -> a
fun2 :: (C1 a, C2, ..., CN) => a -> a
\end{code}

<h4 id="суперклассы">Суперклассы</h4>
<p>Также контекст может быть и у классов, запись</p>

\begin{code}
class A a => B a where
    ...
\end{code}

<p>Означает, что класс \In{B} целиком содержится в \In{A}, и перед тем как объявлять экземпляр для класса \In{B}, необходимо определить экземпляр для класса \In{A}. При этом класс \In{A} называют суперклассом для \In{B}.</p>
<h2 id="двумерный-синтаксис">Двумерный синтаксис</h2>
<p>Наверное вы обратили внимание на то, что в Haskell нет разделителей строк и дополнительных скобок, которые бы указывали границы определения классов или функций. Компилятор Haskell ориентируется по переносам строки и знакам табуляции.</p>
<p>Так если мы пишем в классе:</p>

\begin{code}
class Eq a where
    (==) :: a -> a -> a
    (/=) :: a -> a -> a
\end{code}

<p>По отступам за первой строкой определения компилятор понимает, что класс содержит два метода. Если бы мы написали:</p>

\begin{code}
class Eq a where
    (==) :: a -> a -> a
(/=) :: a -> a -> a
\end{code}

<p>То смысл был бы совсем другим. Теперь мы определяем класс \In{Eq} с одним методом \In{==} и указываем тип некоторого значения \In{(/=)}. Основное правило такое: конструкции, расположенные на одном уровне, выравниваются с помощью табуляции. Чем правее находится определение, тем глубже оно вложено в какую-нибудь специальную конструкцию. Пока нам встретилось лишь несколько специальных конструкций, но дальше появятся и другие.</p>
<h2 id="краткое-содержание">Краткое содержание</h2>
<p>Итак подведём итоги: у нас есть две операции для определения типов (сумма и произведение) и по одной для значений (синонимы), классов типов и экземпляров. А также бесконечное множество их комбинаций, из которых и состоит увлекательный мир Haskell. Конечно не только из них, есть нюансы, синтаксический сахар, расширения языка. Об этом и многом другом мы узнаем из этой книги.</p>
<p>Интересно, что в Haskell, несмотря на обилие конструкций и библиотек, ты чувствуешь, что за ними стоит нечто из мира науки, мира чистого знания. Ты не просто учишься пользоваться определёнными функциями или классами, а узнаёшь что-то новое и красивое.</p>
<h2 id="упражнения">Упражнения</h2>
<p>Потренируйтесь в описаниях в рамках системы типов. Вы определяете базовые понятия и способы их комбинирования. У вас есть три операции:</p>
<ul>
<li><p>Сумма типов \In{data T = A1 | A2}. Перечисление альтернатив</p></li>
<li><p>Произведение типов \In{data T = S S1 S2}. Этим мы говорим, что понятие состоит из нескольких.</p></li>
<li><p>Взятие в список \In{[T]}. Обозначает множественное число, элементов типа \In{T} их может быть несколько.</p></li>
</ul>
<p>Опишите что-либо: комнату, дорогу, город, человека, главу из книги, математическую теорию, всё что угодно.</p>
<p>Ниже приведён пример для понятий из этой главы:</p>

\begin{code}
data Program = Programm ProgramType [Module]
data ProgramType = Executable | Library

data Module = Module [Definition]

data Definition = Definition DefinitionType Element
data DefinitionType = Export | Inner

data Element = ET Type | EV Value | EC Class | EI Instance

data Type     = Type String
data Value    = Value String
data Class    = Class String
data Instance = Instance String
\end{code}

<p>После того как вы закончите с описанием, подумайте, какие производные связи могли бы вас заинтересовать. Какие функции вам бы хотелось определить в этом описании. Выпишите их типы без определений, например так:</p>

\begin{code}
-- Все объявления типов в модуле
getTypes :: Module -> [Type]

-- Провести редукцию значения:
reduce :: Value -> Program -> Value

-- Проверить типы:
checkTypes :: Program -> Bool

-- Заменить все определения в модуле на новые
setDefinitions    :: Module -> [Definition] -> Module

-- Упорядочить определения по какому-лбо принципу
orderDefinitions :: [Definition] -> [Definition]
\end{code}

<p>Подумайте: если у вас есть все эти функции, какие производные значения могли бы вам сказать что-нибудь интересное.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Было бы точнее называть вычислитель редуктором, поскольку мы проводим редукции, или замену эквивалентных значений, но закрепилось это название. К тому же, редуктор также обозначает прибор.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
</body>
</html>
