<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<h1 id="редукция-выражений">Редукция выражений</h1>
<p>В этой главе мы поговорим о том как вычисляются программы. В самом начале мы говорили о том, что процесса вычисления значений нет. В том смысле, что у нас нет новых значений, у нас ничего не меняется, мы лишь расшифровываем синонимы значений.</p>
<p>Вкратце вспомним то, что мы уже знаем о вычислениях. Сначала мы с помощью типов определяем множество всех возможных значений. Значения – это деревья в узлах которых записаны конструкторы, которые мы определяем в типах. Так например мы можем определить тип:</p>

\begin{code}
data Nat = Zero | Succ Nat
\end{code}

<p>Этим типом мы определяем множество допустимых значений. В данном случае это цепочки конструкторов \In{Succ}, которые заканчиваются конструктором \In{Zero}:</p>

\begin{code}
Zero, Succ Zero, Succ (Succ Zero), ...
\end{code}

<p>Затем начинаем давать им новые имена, создавая константы (простые имена-синонимы)</p>

\begin{code}
zero    = Zero
one     = Succ zero
two     = Succ one
\end{code}


<p>и функции (составные имена-синонимы):</p>

\begin{code}
foldNat :: a -> (a -> a) -> Nat -> a
foldNat z  s  Zero      = z
foldNat z  s  (Succ n)  = s (foldNat z s n)

add a = foldNat a   Succ
mul a = foldNat one (add a) 
\end{code}

<p>Затем мы передаём нашу программу на проверку компилятору. Мы просим у него проверить не создаём ли мы случайно какие-нибудь бессмысленные выражения. Бессмысленные потому, что они пытаются создать значение, которое не вписывается в наши типы. Например если мы где-нибудь попробуем составить выражение:</p>

\begin{code}
add Zero mul
\end{code}

<p>Компилятор напомнит нам о том, что мы пытаемся подставить функцию \In{mul} на место обычного значения типа \In{Nat}. Тогда мы исправим выражение на:</p>

\begin{code}
add Zero two
\end{code}

<p>Компилятор согласится. И передаст выражение вычислителю. И тут мы говорили, что вычислитель начинает проводить расшифровку нашего описания. Он подставляет на место синонимов их определения, правые части из уравнений. Этот процесс мы называли <em>редукцией</em>. Вычислитель видит два синонима и одно значение. С какого синонима начать? С \In{add} или \In{two}?</p>
<h2 id="стратегии-вычислений">Стратегии вычислений</h2>
<p>Этот вопрос приводит нас к понятию стратегии вычислений. Поскольку вычисляем мы только константы, то наше выражение также можно представить в виде дерева. Только теперь у нас в узлах записаны не только конструкторы, но и синонимы. Процесс редукции можно представить как процесс очистки такого дерева от синонимов. Посмотрим на дерево нашего значения:</p>
<p>Оказывается у нас есть две возможности очистки синонимов.</p>
<dl>
<dt><em>Cнизу-вверх</em></dt>
<dd><p> начинаем с листьев и убираем все синонимы в листьях дерева выражения. Как только в данном узле и всех дочерних узлах остались одни конструкторы можно переходить на уровень выше. Так мы поднимаемся выше и выше пока не дойдём до корня.</p>
</dd>
<dt><em>Cверху-вниз</em></dt>
<dd><p> начинаем с корня, самого внешнего синонима и заменяем его на определение (с помощью уравнения на правую часть от знака равно), если на верху снова окажется синоним, мы опять заменим его на определение и так пока на верху не появится конструктор, тогда мы спустимся в дочерние деревья и будем повторять эту процедуру пока не дойдём до листьев дерева.</p>
</dd>
</dl>
<p>Посмотрим как каждая из стратегий будет редуцировать наше выражение. Начнём со стратегии от листьев к корню (снизу-вверх):</p>

\begin{code}
        add Zero two                    
-- видим два синонима add и two 
-- раскрываем two, ведь он находится ниже всех синонимов
=>      add Zero (Succ one)    
-- ниже появился ещё один синоним, раскроем и его
=>      add Zero (Succ (Succ zero))    
-- появился синоним zero раскроем его
=>      add Zero (Succ (Suсс Zero))
-- все узлы ниже содержат конструкторы, поднимаемся вверх до синонима
-- заменяем add на его правую часть
=>      foldNat Succ Zero (Succ (Succ Zero))  
-- самый нижний синоним foldNat, раскроем его
-- сопоставление с образцом проходит во втором уравнении для foldNat
=>      Succ (foldNat Succ Zero (Succ Zero))
-- снова раскрываем foldNat
=>      Succ (Succ (foldNat Zero Zero))
-- снова раскрываем foldNat, но на этот раз нам подходит
-- первое уравнение из определения foldNat
=>      Succ (Succ Zero)
-- синонимов больше нет можно вернуть значение
-- результат:
        Succ (Succ Zero)
\end{code}

<p>В этой стратегии для каждой функции мы сначала вычисляем до конца все аргументы, потом подставляем расшифрованные значения в определение функции.</p>
<p>Теперь посмотрим на вычисление от корня к листьям (сверху-вниз):</p>

\begin{code}
        add Zero two
-- видим два синонима add и two, начинаем с того, что ближе всех к корню
=>      foldNat Succ Zero two
-- теперь выше всех foldNat, раскроем его
\end{code}

<p>Но для того чтобы раскрыть \In{foldNat} нам нужно узнать какое уравнение выбрать для этого нам нужно понять какой конструктор находится в корне у второго аргумента, если это \In{Zero}, то мы выберем первое уравнение, а если это \In{Succ}, то второе:</p>

\begin{code}
-- в уравнении для foldNat видим декомпозицию по второму 
-- аргументу. Узнаем какой конструктор в корне у two
=>      foldNat Succ Zero (Succ one)
-- Это Succ нам нужно второе уравнение:
=>      Succ (foldNat Succ Zero one)
-- В корне м ыполучили конструктор, можем спуститься ниже.
-- Там мы видим foldNat, для того чтобы раскрыть его нам
-- снова нужно понять какой конструктор в корне у второго аргумента:
=>      Succ (foldNat Succ Zero (Succ zero))
-- Это опять Succ переходим ко второму уравнению для foldNat
=>      Succ (Succ (foldNat Succ Zero zero))
-- Снова раскрываем второй аргумент у foldNat
=>      Succ (Succ (foldNat Succ Zero Zero))
-- Ага это Zero, выбираем первое уравнение
=>      Succ (Succ Zero)
-- Синонимов больше нет можно вернуть значение
-- результат:
        Succ (Succ Zero)
\end{code}

<p>В этой стратегии мы всегда раскрываем самый верхний уровень выражения, можно представить как мы вытягиваем конструкторы от корня по цепочке. У этих стратегий есть специальные имена:</p>
<ul>
<li><p>вычисление <em>по значению</em> (call by value), когда мы идём от листьев к корню.</p></li>
<li><p>вычисление <em>по имени</em> (call by name), когда мы идём от корня к листьям.</p></li>
</ul>
<p>Отметим, что стратегию вычисления по значению также принято называть <em>энергичными вычислениями</em> (eqger evaluation) или <em>аппликативной</em> (applicative) стратегией редукции. Вычисление по имени также принято называть <em>нормальной</em> (normal) стратегией редукции.</p>
<h3 id="преимущества-и-недостатки-стратегий">Преимущества и недостатки стратегий</h3>
<p>В чём преимущества, той и другой стратегии.</p>
<blockquote>
<p>Если выражение вычисляется полностью, первая стратегия более эффективна по расходу памяти.</p>
</blockquote>
<p><em>Вычисляется полностью</em> означает все компоненты выражения участвуют в вычислении. Например то выражении, которое мы рассмотрели так подробно, вычисляется полностью. Приведём пример выражения, при вычислении которого нужна лишь часть аргументов, для этого определим функцию:</p>

\begin{code}
isZero :: Nat -> Bool
isZero Zero     = True
isZero _        = False
\end{code}

<p>Она проверяет является ли нулём данное число, теперь представим как будет вычисляться выражение, в той и другой стратегии:</p>

\begin{code}
isZero (add Zero two)
\end{code}

<p>Первая стратегия сначала вычислит все аргументы у \In{add} потом расшифрует \In{add} и только в самом конце доберётся до \In{isZero}. На это уйдёт восемь шагов (семь на вычисление \In{add Zero two}). В то время как вторая стратегия начнёт с \In{isZero}. Для вычисления \In{isZero} ей потребуется узнать какой конструктор в корне у выражения \In{add Zero two}. Она узнает это за два шага. Итого три шага. Налицо экономия усилий.</p>
<p>Почему вторая стратегия экономит память? Поскольку мы всегда вычисляем аргументы функции, мы можем не хранить описания в памяти а сразу при подстановке в функцию начинать редукцию. Эту ситуацию можно понять на таком примере, посчитаем сумму чисел от одного до четырёх с помощью такой функции:</p>

\begin{code}
sum :: Int -> [Int] -> Int
sum []      res = res
sum (x:xs)  res = sum xs (res + x) 
\end{code}

<p>Посмотрим на то как вычисляет первая стратегия, с учётом того что мы вычисляем значения при подстановке:</p>

\begin{code}
        sum [1,2,3,4] 0
=>      sum [2,3,4]   (0 + 1)    
=>      sum [2,3,4]   1
=>      sum [3,4]     (1 + 2)
=>      sum [3,4]     3
=>      sum [4]       (3+3)
=>      sum [4]       6
=>      sum []        (6+4)
=>      sum []        10
=>      10
\end{code}

<p>Теперь посмотрим на вторую стратегию:</p>

\begin{code}
        sum [1,2,3,4] 0
=>      sum [2,3,4]   0+1
=>      sum [3,4]     (0+1)+2
=>      sum [4]       ((0+1)+2)+3
=>      sum []        (((0+1)+2)+3)+4
=>      (((0+1)+2)+3)+4
=>      ((1+2)+3)+4
=>      (3+3)+4
=>      6+4
=>      10
\end{code}

<p>А теперь представьте, что мы решили посчитать сумму чисел от 1 до миллиона. Сколько вычислений нам придётся накопить! В этом недостаток второй стратегии. Но есть и ещё один недостаток, рассмотрим выражение:</p>

\begin{code}
(\x -> add (add x x) x) (add Zero two)
\end{code}

<p>Первая стратегия сначала редуцирует выражение \In{add Zero two} в то время как вторая подставит это выражение в функцию и утроит свою работу!</p>
<p>Но у второй стратегии есть одно очень веское преимущество, она может вычислять больше выражений чем вторая. Определим значение бесконечность:</p>

\begin{code}
infinity    :: Nat
infinity    = Succ infinity
\end{code}

<p>Это рекурсивное определение, если мы попытаемся его распечатать мы получим бесконечную последовательность \In{Succ}. Чем не бесконечность? Теперь посмотрим на выражение:</p>

\begin{code}
isZero infinity
\end{code}

<p>Первая стратегия захлебнётся, вычисляя аргумент функции \In{isZero}, в то время как вторая найдёт решение за два шага.</p>
<p>Подведём итоги. Плюсы вычисления по значению:</p>
<ul>
<li><p>Эффективный расход памяти в том случае если все<br /> составляющие выражения участвуют в вычислении.</p></li>
<li><p>Она не может дублировать вычисления, как стратегия вычисления по имени.</p></li>
</ul>
<p>Плюсы вычисления по имени:</p>
<ul>
<li><p>Меньше вычислений в том случае, если при вычислении выражения<br /> участвует лишь часть составляющих.</p></li>
<li><p>Большая выразительность. Мы можем вычислить больше значений.</p></li>
</ul>
<p>Какую из них выбрать? В Haskell пошли по второму пути. Всё-таки преимущество выразительности языка оказалось самым существенным. Но для того чтобы избежать недостатков стратегии вычисления по имени оно было модифицировано. Давайте посмотрим как.</p>
<h2 id="вычисление-по-необходимости">Вычисление по необходимости</h2>
<p>  Вернёмся к выражению:</p>

\begin{code}
(\x -> add (add x x) x) (add Zero two)
\end{code}

<p>Нам нужно как-то рассказать функции о том, что имя \In{x} в её теле указывает на одно и то же значение. И если в одном из \In{x} значение будет вычислено переиспользовать эти результаты в других \In{x}. Вместо значения мы будем передовать в функцию <em>ссылку</em> на область памяти, которая содержит рецепт получения этого значения. Напомню, что мы по-прежнему вычисляем значение сверху вниз, сейчас мы просто хотим избавиться от проблемы дублирования. Вернитесь к примеру с вычислением по имени и просмотрите его ещё раз. Обратите внимание на то, что значения вычислялись лишь при сопоставлении с образцом. Мы вычисляем верхний конструктор аргумента лишь для того, чтобы понять какое уравнение для \In{foldNat} выбрать. Теперь мы будем хранить ссылку на \In{(add Zero two)} в памяти и как только, внешняя функция запросит верхний конструктор мы обновим значение в памяти новым вычисленным до корневого конструктора значением. Если в любом другом месте функции мы вновь обратимся к значению, мы не будем его перевычислять, а сразу вернём конструктор. Посмотрим как это происходит на примере:</p>

\begin{code}
--  выражение                               | память:
--------------------------------------------|-------------------------
    (\x -> add (add x x) x) M               | M = (add Zero two)
-- подставим ссылку в тело функции          |
=>  add (add M M) M                         |
-- раскроем самый верхний синоним           |
=>  foldNat (add M M) Succ M                |
-- для foldNat узнаем верхний конструктор   |
-- последнего аргумента (пропуская          |
-- промежуточные шаги, такие же как выше)   |
=>                                          | M  = Succ M1
                                            | M1 = foldNat Succ Zero one
-- по M выбираем второе уравнение           |
=> Succ (foldNat (add M M) Succ M1)         |
-- запросим следующий верхний конструктор:  |
=>                                          | M  = Succ M1
                                            | M1 = Succ M2
                                            | M2 = foldNat Succ Zero zero
-- по M1 выбираем второе уравнение          |
=> Succ (Succ (foldNat (add M M) Succ M2))  | 
-- теперь для определения уравнения foldNat |
-- раскроем M2                              |
=>                                          | M  = Succ M1
                                            | M1 = Succ M2
                                            | M2 = Zero
-- выбираем первое уравнение для foldNat:   |
=> Succ (Succ (add M M))                    |
-- раскрываем самый верхний синоним:        |
=> Succ (Succ (foldNat M Succ M))           |
-- теперь, поскольку M уже вычислялось, в   |
-- памяти уже записан верхний конструктор,  |
-- мы знаем, что это Succ и выбираем второе |
-- уравнение:                               |
=> Succ (Succ (Succ (foldNat M Succ M1)))   |
-- и M1 тоже уже вычислялось, сразу         |
-- выбираем второе уравнение                |----+
=> Succ (Succ (Succ (Succ (foldNat M Succ M2)))) |
-- M2 вычислено, идём на первое уравнение   |----+
=> Succ (Succ (Succ (Succ (Succ M))))       |
-- далее остаётся только подставить уже     |
-- вычисленные значения M                   |
-- и вернуть значение.                      |
\end{code}

<p>Итак подставляется не значение а ссылка на него, вычисленная часть значения используется сразу в нескольких местах. Эта стратегия редукции называется вычислением <em>по необходимости</em> (call by need) или <em>ленивой</em> стратегией вычислений (lazy evaluation).</p>
<p>Теперь немного терминологии. Значение может находится в четырёх состояниях:</p>
<ul>
<li><p>Нормальная форма (normal form, далее НФ), когда оно полностью вычислено (нет синонимов);</p></li>
<li><p>Слабая заголовочная НФ (weak head NF, далее СЗНФ), когда известен хотя бы один верхний конструктор;</p></li>
<li><p>Отложенное вычисление (thunk), когда известен лишь рецепт вычисления;</p></li>
<li><p>Дно (bottom, часто рисуют как <span class="math">⊥</span>), когда известно, что значение не определено.</p></li>
</ul>
<p>Вы могли понаблюдать за значением в первых трёх состояниях на примере выше. Но что такое <span class="math">⊥</span>? Вспомним определение для функции извлечения головы списка \In{head}:</p>

\begin{code}
head :: [a] -> a
head (a:_)  = a
head []     = error "error: empty list" 
\end{code}

<p>Второе уравнение возвращает <span class="math">⊥</span>. У нас есть две функции, которые возвращают это “значение”:</p>

\begin{code}
undefined   :: a
error       :: String -> a
\end{code}

<p>Первая – это <span class="math">⊥</span> в чистом виде, а вторая не только возвращает неопределённое значение, но и приводит к выводу на экран сообщения об ошибке. Обратите внимание на тип этих функций, результат может быть значением любого типа. Это наблюдение приводит нас к ещё одной тонкости. Когда мы определяем тип:</p>

\begin{code}
data Bool       = False | True
data Maybe a    = Nothing | Just a
\end{code}

<p>На самом деле мы пишем:</p>

\begin{code}
data Bool       = undefined | False | True
data Maybe a    = undefined | Nothing | Just a
\end{code}

<p>Компилятор автоматически прибавляет ещё одно значение к любому определённому пользователем типу. Такие типы называют <em>поднятыми</em> (lifted type). А значения таких типов принято называть <em>запакованными</em> (boxed). Не запакованное (unboxed) значение – это простое примитивное значение. Например целое или действительное число в том виде, в котором оно хранится на компьютере. В Haskell даже числа “запакованы”. Поскольку нам необходимо, чтобы \In{undefined} могло возвращать в том числе и значение типа \In{Int}:</p>

\begin{code}
data Int = undefined  | I# Int# 
\end{code}

<p>Тип \In{Int#} – это низкоуровневое представление ограниченного целого числа. Принято писать не запакованные типы с решёткой на конце. \In{I#} – это конструктор. Нам приходится запаковывать значения ещё и потому, что значение может принимать несколько состояний (в зависимости от того, насколько оно вычислено), всё это ведёт к тому, что у нас хранится не просто значение, а значение с какой-то дополнительной информацией, которая зависит от конкретной реализации языка Haskell.</p>
<p>Мы решили проблему дублирования вычислений, но наше решение усугубило проблему расхода памяти. Ведь теперь мы храним не просто значения, но ещё и дополнительную информацию, которая отвечает за проведение вычислений. Эта проблема может проявляться в очень простых задачах. Например попробуем вычислить сумму чисел от одного до миллиарда:</p>

\begin{code}
sum [1 .. 1e9]
<interactive>: out of memory (requested 2097152 bytes)
\end{code}

<p>Интуитивно кажется, что для решения этой задачи нам нужно лишь две ячейки памяти. В одной мы будем постоянно прибавлять к значению единицу, пока не дойдём до миллиарда, так мы последовательно будем получать элементы списка, а в другой мы будем хранить значение суммы. Мы начнём с нуля и будем прибавлять значения первой ячейки. У ленивой стратегии другое мнение на этот счёт. Если вы вернётесь к примеру выше, то заметите, что \In{sum} копит отложенные выражения до самого последнего момента. Поскольку память ограничена, такой момент не наступает. Как нам быть? В Haskell по умолчанию все вычисления проводятся по необходимости, но предусмотрены и средства для имитации вычисления по значению. Давайте посмотрим на них.</p>
<h2 id="аннотации-строгости">Аннотации строгости</h2>
<p>Языки с ленивой стратегией вычислений называют не строгими (non-strict), а языки с энергичной стратегией вычислений соответственно~– строгими.</p>
<h3 id="принуждение-к-сзнф-с-помощью-seq">Принуждение к СЗНФ с помощью seq</h3>
<p>Мы говорили о том, что при вычислении по имени значения вычисляются только при сопоставлении с образцом или в \In{case}-выражениях. Есть специальная функция \In{seq}, которая форсирует приведение к СЗНФ:</p>

\begin{code}
seq :: a -> b -> b
\end{code}

<p>Она принимает два аргумента, при выполнении функции первый аргумент приводится к СЗНФ и <em>затем</em> возвращается второй. Вернёмся к примеру с \In{sum}. Привести к СЗНФ число – означает вычислить его полностью. Определим функцию \In{sum'}, которая перед рекурсивным вызовом вычисляет промежуточный результат:</p>

\begin{code}
sum' :: Num a => [a] -> a
sum' = iter 0 
    where iter res []        = res
          iter res (a:as)    = let res' = res + a
                               in  res' `seq` iter res' as 
\end{code}

<p>Сохраним результат в отдельном модуле \In{Strict.hs} и попробуем теперь вычислить значение, придётся подождать:</p>

\begin{code}
Strict> sum' [1 .. 1e9]
\end{code}

<p>И мы ждём, и ждём, и ждём. Но переполнения памяти не происходит. Это хорошо. Но давайте прервём вычисления. Нажмём \In{ctrl+c}. Функция \In{sum'} вычисляется, но вычисляется очень медленно. Мы можем существенно ускорить её, если <em>скомпилируем</em> модуль \In{Strict}. Для компиляции модуля переключимся в его текущую директорию и вызовем компилятор \In{ghc} с флагом \In{--make}:</p>

\begin{code}
ghc --make Strict
\end{code}

<p>Появились два файла \In{Strict.hi} и \In{Strict.o}. Теперь мы можем загрузить модуль \In{Strict} в интерпретатор и сравнить выполнение двух функций:</p>

\begin{code}
Strict> sum' [1 .. 1e6]
5.000005e11
(0.00 secs, 89133484 bytes)
Strict> sum [1 .. 1e6]
5.000005e11
(0.57 secs, 142563064 bytes)
\end{code}

<p>Обратите внимание на прирост скорости. Умение понимать в каких случаях стоит ограничить лень очень важно. И в программах на Haskell тоже. Также компилировать модули можно из интерпретатора. Для этого воспользуемся командой \In{:!}, она выполняет системные команды в интерпретаторе \In{ghci}:</p>

\begin{code}
Strict> :! ghc --make Strict
[1 of 1] Compiling Strict           ( Strict.hs, Strict.o )
\end{code}

<p>Отметим наличие специальной функции применения, которая просит перед применением привести аргумент к СЗНФ, эта функция определена в \In{Prelude}:</p>

\begin{code}
($!) :: (a -> b) -> a -> b
 f $! a = a `seq` f a
\end{code}

<p>С этой функцией мы можем определить функцию \In{sum} так:</p>

\begin{code}
sum' :: Num a => [a] -> a
sum' = iter 0 
    where iter res []        = res
          iter res (a:as)    = flip iter as $! res + a
\end{code}

<h3 id="функции-с-хвостовой-рекурсией">Функции с хвостовой рекурсией</h3>
<p>Определим функцию, которая не будет лениться при вычислении произведения чисел, мы назовём её \In{product'}:</p>

\begin{code}
product' :: Num a => [a] -> a
product' = iter 1
    where iter res []        = res
          iter res (a:as)    = let res' = res * a
                               in  res' `seq` iter res' as 
\end{code}

<p>Смотрите функция \In{sum} изменилась лишь в двух местах. Это говорит о том, что пора задуматься о том, а нет ли такой общей функции, которая включает в себя и то и другое поведение. Такая функция есть и называется она \In{foldl'}, вот её определение:</p>

\begin{code}
foldl' :: (a -> b -> a) -> a -> [b] -> a
foldl' op init = iter init
    where iter res []        = res
          iter res (a:as)    = let res' = res `op` a
                               in  res' `seq` iter res' as 
\end{code}

<p>Мы вынесли в аргументы функции бинарную операцию и начальное значение. Всё остальное осталось прежним. Эта функция живёт в модуле \In{Data.List}. Теперь мы можем определить функции \In{sum'} и \In{prod'}:</p>

\begin{code}
sum'        = foldl' (+) 0
product'    = foldl' (*) 1
\end{code}

<p>Также в \In{Prelude} определена функция \In{foldl}. Она накапливает значения в аргументе, но без принуждения вычислять промежуточные результаты:</p>

\begin{code}
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl op init = iter init
    where iter res []        = res
          iter res (a:as)    = iter (res `op` a) as 
\end{code}

<p>Такая функция называется функцией с <em>хвостовой рекурсией</em> (tail-recursive function). Рекурсия хвостовая тогда, когда рекурсивный вызов функции является последним действием, которое выполняется в функции. Посмотрите на второе уравнение функции \In{iter}. Мы вызываем функцию \In{iter} рекурсивно последним делом. В языках с вычислением по значению часто хвостовая рекурсия имеет преимущество за счёт экономии памяти (тот момент который мы обсуждали в самом начале). Но как видно из этого раздела в ленивых языках это не так. Библиотечная функция \In{sum} будет накапливать выражения перед вычислением с риском исчерпать всю доступную память, потому что она определена через \In{foldl}.</p>
<h3 id="тонкости-применения-seq">Тонкости применения seq</h3>
<p>Хочу подчеркнуть, что функция \In{seq} не вычисляет свой первый аргумент полностью. Первый аргумент не приводится к нормальной форме. Мы лишь просим вычислитель узнать какой конструктор находится в корне у данного выражения. Например в выражении \In{isZero $! infinity} знак \In{$!} ничем не отличается от простого применения мы и так будем приводить аргумент \In{infinity} к СЗНФ, когда нам понадобится узнать какое из уравнений для \In{isZero} выбрать, ведь в аргументе функции есть сопоставление с образцом.</p>
<p>Посмотрим на один типичный пример. Вычисление среднего для списка чисел. Среднее равно сумме всех элементов списка, разделённой на длину списка. Для того чтобы вычислить значение за один проход мы будем одновременно вычислять и сумму элементов и значение длины. Также мы понимаем, что нам не нужно откладывать вычисления, воспользуемся функцией \In{foldl'}:</p>

\begin{code}
mean :: [Double] -> Double
mean = division . foldl' count (0, 0)
    where count  (sum, leng) a = (sum+a, leng+1)
          division (sum, leng) = sum / fromIntegral leng
\end{code}

<p>Проходим по списку, копим сумму в первом элементе пары и длину во втором. В самом конце делим первый элемент на второй. Обратите внимание на функцию \In{fromIntegral} она преобразует значения из целых чисел, в какие-нибудь другие из класса \In{Num}. Сохраним это определение в модуле \In{Strict} скомпилируем модуль и загрузим в интерпретатор, не забудьте импортировать модуль \In{Data.List}, он нужен для функции \In{foldl'}. Посмотрим, что у нас получилось:</p>

\begin{code}
Prelude Strict> mean [1 .. 1e7]
5000000.5
(49.65 secs, 2476557164 bytes)
\end{code}

<p>Получилось очень медленно, странно ведь порядок этой функции должен быть таким же что и у \In{sum'}. Посмотрим на скорость \In{sum'}:</p>

\begin{code}
Prelude Strict> sum' [1 .. 1e7]
5.0000005e13
(0.50 secs, 881855740 bytes)
\end{code}

<p>В 100 раз быстрее. Теперь представьте, что у нас 10 таких функций как \In{mean} они разбросаны по всему коду и делают своё чёрное ленивое дело. Причина такого поведения кроется в том, что мы опять завернули значение в другой тип, на этот раз в пару. Когда вычислитель дойдёт до \In{seq}, он остановится на выражении \In{(thunk, thunk)} вместо двух чисел. Он вновь будет накапливать отложенные вычисления, а не значения.</p>
<p>Перепишем \In{mean}, теперь мы будем вычислять значения пары по отдельности и попросим вычислитель привести к СЗНФ каждое из них перед вычислением итогового значения:</p>

\begin{code}
mean' :: [Double] -> Double
mean' = division . iter (0, 0)
    where iter res          []      = res
          iter (sum, leng)  (a:as)  = 
                let s = sum  + a
                    l = leng + 1
                in  s `seq` l `seq` iter (s, l) as
          
          division (sum, leng) = sum / fromIntegral leng
\end{code}

<p>Такой вот монстр. Функция \In{seq} право ассоциативна поэтому скобки будут группироваться в нужном порядке. В этом определении мы просим вычислитель привести к СЗНФ <em>числа</em>, а не пары чисел, как в прошлой версии. Для чисел СЗНФ совпадает с НФ, и всё должно пройти гладко, но сохраним это определение и проверим результат:</p>

\begin{code}
Prelude Strict> :! ghc --make Strict
[1 of 1] Compiling Strict           ( Strict.hs, Strict.o )
Prelude Strict> :load Strict
Ok, modules loaded: Strict.
(0.00 secs, 0 bytes)
Prelude Strict> mean' [1 .. 1e7]
5000000.5
(0.65 secs, 1083157384 bytes)
\end{code}

<p>Получилось! Скорость чуть хуже чем у \In{sum'}, но не в сто раз.</p>
<h3 id="энергичные-образцы">Энергичные образцы</h3>
<p>В GHC предусмотрены специальные обозначения для принудительного приведения выражения к СЗНФ. Они не входят в стандарт языка Haskell, поэтому для того, чтобы воспользоваться ими, нам необходимо подключить их. Расширения подключаются с помощью специального комментария в самом начале модуля:</p>

\begin{code}
{-# LANGUAGE BangPatterns #-}
\end{code}

<p>Эта запись активирует расширение языка с именем \In{BangPatterns}. Ядро языка Haskell фиксировано стандартом, но каждый разработчик компилятора может вносить свои дополнения. Они подключаются через директиву \In{LANGUAGE}:</p>

\begin{code}
{-# LANGUAGE 
        Расширение1, 
        Расширение2, 
        Расширение3 #-}
\end{code}

<p>Мы заключаем директиву в специальные комментарии с решёткой, говорим \In{LANGUAGE} а затем через запятую перечисляем имена расширений, которые нам понадобятся. Расширения активны только в рамках данного модуля. Например если мы импортируем функции из модуля, в котором включены расширения, то эти расширения не распространяются дальше на другие модули. Такие комментарии с решёткой называют <em>прагмами</em> (pragma).</p>
<p>Нас интересует расширение \In{BangPatterns} (bang – восклицательный знак, вы сейчас поймёте почему оно так называется). Посмотрим на функцию, которая использует энергичные образцы:</p>

\begin{code}
iter (!sum, !leng) a = (step + a, leng + 1)
\end{code}

<p>В декомпозиции пары перед переменными у нас появились восклицательные знаки. Они говорят вычислителю о том, чтобы он так уж и быть сделал ещё одно усилие и заглянул в корень значений переменных, которые были переданы в эту функцию.</p>
<p>Вычислитель говорит ладно-ладно сделаю. А там числа! И получается, что они не накапливаются. С помощью энергичных образцов мы можем переписать функцию \In{mean'} через \In{foldl'}, а не выписывать её целиком:</p>

\begin{code}
mean'' :: [Double] -> Double
mean'' = division . foldl' iter (0, 0)
    where iter (!sum, !leng) a = (sum  + a, leng + 1)
          division (sum, leng) = sum / fromIntegral leng
\end{code}

<p>Проверим в интерпретаторе</p>

\begin{code}
*Strict> :! ghc --make Strict
[1 of 1] Compiling Strict           ( Strict.hs, Strict.o )
*Strict> :l Strict
Ok, modules loaded: Strict.
(0.00 secs, 581304 bytes)
Prelude Strict> mean'' [1 .. 1e7]
5000000.5
(0.78 secs, 1412862488 bytes)
Prelude Strict> mean' [1 .. 1e7]
5000000.5
(0.65 secs, 1082640204 bytes)
\end{code}

<p>Функция работает чуть медленнее, чем исходная версия, но не сильно.</p>
<h3 id="энергичные-типы-данных">Энергичные типы данных</h3>
<p>Расширение \In{BangPatterns} позволяет указывать какие значения привести к СЗНФ не только в образцах, но и в типах данных. Мы можем создать тип:</p>

\begin{code}
data P a b = P !a !b
\end{code}

<p>Этот тип обозначает пару, элементы которой обязаны находиться в СЗНФ. Теперь мы можем написать ещё один вариант функции поиска среднего:</p>

\begin{code}
mean''' :: [Double] -> Double
mean''' = division . foldl' iter (P 0 0)
    where iter (P sum leng) a = P (sum  + a) (leng + 1)
          division (P sum leng) = sum / fromIntegral leng
\end{code}

<h2 id="пример-ленивых-вычислений">Пример ленивых вычислений</h2>
<p>У вас может сложиться ошибочное представление, что ленивые вычисления созданы только для того, чтобы с ними бороться. Пока мы рассматривали лишь недостатки, вскользь упомянув о преимуществе выразительности. Ленивые вычисления могут и экономить память! Мы можем строить огромные промежуточные данные, обрабатывать их разными способами при условии, что в конце программы нам потребуется лишь часть этих данных или конечный алгоритм будет накапливать определённую статистику.</p>
<p>Рассмотрим такое выражение:</p>

\begin{code}
let longList = produce x
in  sum' $ filter p $ map f longList 
\end{code}

<p>Функция \In{produce} строит огромный список промежуточных данных. Далее мы преобразуем эти данные функцией \In{f} и фильтруем их предикатом \In{p}. Всё это делается для того, чтобы посчитать сумму всех элементов в списке. Посмотрим как повела бы себя в такой ситуации энергичная стратегия вычислений. Сначала был бы вычислен список \In{longList}, причём полностью. Затем все элементы были бы преобразованы функцией \In{f}. У нас в памяти уже два огромных списка. Теперь мы фильтруем весь список и в самом конце суммируем. Было бы очень плохо заставлять энергичный вычислитель редуцировать такое выражение.</p>
<p>А в это время ленивый вычислитель поступит так. Сначала всё выражение будет сохранено в виде описания, затем он скажет разверну сначала \In{sum'}, эта функция запросит первый элемент списка, что приведёт к вызову \In{filter}. Фильтр будет запрашивать следующий элемент списка у подчинённых ему функций до тех пор, пока предикат \In{p} не вернёт \In{True} на одном из них. Всё это время функция \In{map} будет вытягивать из \In{produce} по одному элементу. Причём память, выделенная на промежуточные не нужные значения (на них \In{p} вернул \In{False}) будет переиспользована. Как только \In{sum'} прибавит первый элемент, она запросит следующий, проснётся фильтр и так далее. Вся функция будет работать в постоянном ограниченном объёме памяти, который не зависит от величины списка \In{longList}!</p>
<p>Примерам ленивых вычислений будет посвящена отдельная глава, а пока приведём один пример. Найдём корень уравнения с помощью метода неподвижной точки. У нас есть функция \In{f :: a -> a}, и нам нужно найти решение уравнения:</p>

\begin{code}
f x = x
\end{code}

<p>Можно начать с какого-нибудь стартового значения, и подставлять, подставлять, подставлять его в \In{f} до тех пор, пока значение не перестанет изменяться. Так мы найдём решение.</p>

\begin{code}
x1 = f x0
x2 = f x1
x3 = f x2
...
до тех пор пока abs (x[N] - x[N-1]) <= eps
\end{code}

<p>Первое наблюдение: функция принимает не произвольные значения, а те для которых имеет смысл операции: минус, поиск абсолютного значения и сравнение на больще/меньше. Тип нашей функции:</p>

\begin{code}
f :: (Ord a, Num a) => a -> a
\end{code}

<p>Ленивые вычисления позволяют нам отделить шаг генерации решений, от шага проверки сходимости. Сначала мы сделаем список всех подстановок функции \In{f}, а затем найдём в этом списке два соседних элемента расстояние между которыми достаточно мало. Итак первый шаг, генерируем всю последовательность:</p>

\begin{code}
xNs = iterate f x0
\end{code}

<p>Мы воспользовались стандартной функцией \In{iterate} из \In{Prelude}. Теперь ищем два соседних числа:</p>

\begin{code}
converge :: (Ord a, Num a) => a -> [a] -> a
converge eps (a:b:xs) 
    | abs (a - b) <= eps    = a
    | otherwise             = converge eps (b:xs)
\end{code}

<p>Поскольку список бесконечный мы можем не проверять случаи для пустого списка. Итоговое решение:</p>

\begin{code}
roots :: (Ord a, Num a) => a -> a -> (a -> a) -> a
roots eps x0 f = converge eps $ iterate f x0
\end{code}

<p>За счёт ленивых вычислений функции \In{converge} и \In{iterate} работают синхронно. Функция \In{converge} запрашивает новое значение и \In{iterate} передаёт его, но только одно! Найдём решение какого-нибудь уравнения. Запустим интерпретатор. Мы ленимся и не создаём новый модуль для такой “большой” функции. Определяем её сразу в интерпретаторе.</p>

\begin{code}
Prelude> let converge eps (a:b:xs) = if abs (a-b)<=eps then a else converge eps (b:xs)
Prelude> let roots eps x0 f = converge eps $ iterate f x0
\end{code}

<p>Найдём корень уравнения:</p>
<p><br /><span class="math"><em>x</em>(<em>x</em> − 2) = 0</span><br /></p>
<p><br /><span class="math"><em>x</em><sup>2</sup> − 2<em>x</em> = 0</span><br /></p>
<p><br /><span class="math">$\frac{1}{2} x^2 = x$</span><br /></p>

\begin{code}
Prelude> roots 0.001 5 (\x -> x*x/2)
\end{code}

<p>Метод завис, остаётся только нажать \In{ctrl+c} для остановки. На самом деле есть одно условие для сходимости метода. Метод сойдётся, если модуль производной функции \In{f} меньше единицы. Иначе есть возможность, что мы будем бесконечно генерировать новые подстановки. Вычислим производную нашей функции:</p>
<p><br /><span class="math">$\frac{d}{dx} \frac{1}{2} x^2 = x$</span><br /></p>
<p>Нам следует ожидать решения в интервале от минус единицы до единицы:</p>

\begin{code}
Prelude> roots 0.001 0.5 (\x -> x*x/2)
3.0517578125e-5
\end{code}

<p>Мы нашли решение, корень равен нулю. В этой записи \In{Ne-5} означает <span class="math"><em>N</em> ⋅ 10<sup> − 5</sup></span></p>
<h2 id="краткое-содержание">Краткое содержание</h2>
<p>В этой главе мы узнали о том как происходят вычисления в Haskell. Мы узнали, что они ленивые. Всё вычисляется как можно позже и как можно меньше. Такие вычисления называются вычислениями по необходимости.</p>
<p>Также мы узнали о вычислениях по значению и вычислениях по имени.</p>
<ul>
<li><p>В <em>вычислениях по значению</em> редукция проводится от листьев дерева выражения к корню</p></li>
<li><p>В <em>вычислениях по имени</em> редукция проводится от корня дерева выражения к листьям.</p></li>
</ul>
<p>Вычисление по необходимости является улучшением вычисления по имени. Мы не дублируем выражения во время применения. Мы сохраняем значения в памяти и подставляем в функцию ссылки на значения. После вычисления значения происходит его обновление в памяти. Так если в одном месте выражение уже было вычислено и мы обратимся к нему по ссылке из другого места, то мы не будем перевычислять его, а просто считаем готовое значение.</p>
<p>Мы познакомились с терминологией процесса вычислений. Выражение может находится в <em>нормальной форме</em>. Это значит что оно вычислено. Может находится в <em>слабой заголовочной нормальной форме</em>. Это значит, что мы знаем хотя бы один конструктор в корне выражения. Также возможно выражение ещё не вычислялось, тогда оно является <em>отложенным</em> (thunk).</p>
<p>Суть ленивых вычислений заключается в том, что они происходят синхронно. Если у нас есть композиция двух функций:</p>
<p><br /><span class="math"><em>g</em> (<em>f</em> <em>x</em>)</span><br /></p>
<p>Внутренняя функция \In{f} не начнёт вычисления до тех пор пока значения не понадобятся внешней функции \In{g}. О последствиях этого мы остановимся подробнее в отдельной главе. Значения могут потребоваться только при сопоставлении с образцом. Когда мы хотим узнать какое из уравнений нам выбрать.</p>
<p>Иногда ленивые вычисления не эффективны по расходу памяти. Это происходит когда выражение состоит из большого числа подвыражений, которые будут вычислены в любом случае. В Haskell у нас есть способы борьбы с ленью. Это функция \In{seq}, энергичные образцы и энергичные типы данных.</p>
<p>Функция \In{seq}:</p>

\begin{code}
seq :: a -> b -> b
\end{code}

<p>Сначала приводит к слабой заголовочной форме свой первый аргумент, а затем возвращает второй. Взрывные образцы выполняют те же функции, но они используются в декомпозиции аргументов или в объявлении типа.</p>
<h2 id="упражнения">Упражнения</h2>
<ul>
<li><p>Потренируйтесь в понимании того как происходят ленивые вычисления. Вычислите на бумаге следующие выражения (если это возможно):</p>
<ul>
<li><p>\In{sum $ take 3 $ filter (odd . fst) $          zip [1 ..] [1, undefined, 2, undefined, 3, undefined, undefined]}</p></li>
<li>\In{take 2 $ foldr (+) 0 $ map Succ $ repeat Zero}</li>
<li><p>\In{take 2 $ foldl (+) 0 $ map Succ $ repeat Zero}</p></li>
</ul></li>
<li><p>Функция \In{seq} приводит первый аргумент к СЗНФ, убедитесь в этом на таком эксперименте. Определите тип:</p>

\begin{code}
data TheDouble = TheDouble { runTheDouble :: Double }
\end{code}

<p>Он запаковывает действительные числа в конструктор. Определите для этого типа экземпляр класса \In{Num} и посмотрите как быстро будет работать функция \In{sum'} на таких числах. Как изменится скорость если мы заменим в определении типа \In{data} на \In{newtype}? как изменится скорость, если мы вернём \In{data}, но сделаем тип \In{TheDouble} энергичным? Поэкспериментируйте.</p></li>
<li><p>Посмотрите на приведение к СЗНФ в энергичных типах данных. Определите два типа:</p>

\begin{code}
data Strict a = Strict !a
data Lazy   a = Lazy    a
\end{code}

<p>И повычисляйте в интерпретаторе различные значения с \In{undefined}, \In{const}, \In{($!)} и \In{seq}:</p>

\begin{code}
> seq (Lazy undefined) "Hi"
> seq (Strict undefined) "Hi"
> seq (Lazy (Strict undefined)) "Hi"
> seq (Strict (Strict (Strict undefined))) "Hi"
\end{code}
</li>
<li><p>Посмотрите на такую функцию вычисления суммы всех чётных и нечётных чисел в списке.</p>

\begin{code}
sum2 :: [Int] -> (Int, Int)
sum2 = iter (0, 0)
    where iter c  []     = c
          iter c  (x:xs) = iter (tick x c) xs

tick :: Int -> (Int, Int) -> (Int, Int)
tick x (c0, c1) | even x    = (c0, c1 + 1)
                | otherwise = (c0 + 1, c1)
\end{code}

<p>Эта функция очень медленная. Кто-то слишком много ленится. Узнайте кто, и ускорьте функцию.</p></li>
</ul>
</body>
</html>
