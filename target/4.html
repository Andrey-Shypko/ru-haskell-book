<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<h1 id="декларативный-и-композиционный-стиль">Декларативный и композиционный стиль</h1>
<p>В Haskell существует несколько встроенных выражений, которые облегчают построение функций и делают код более наглядным. Их можно разделить на два вида: выражения, которые поддерживают <em>декларативный стиль</em> (declarative style) определения функций, и выражения которые поддерживают <em>композиционный стиль</em> (expression style).</p>
<p>Что это за стили? В декларативном стиле определения функций больше похожи на математическую нотацию, словно это предложения языка. В композиционном стиле мы строим из маленьких выражений более сложные, применяем к этим выражениям другие выражения и строим ещё большие.</p>
<p>В Haskell есть полноценная поддержка и того и другого стиля, поэтому конструкции которые мы рассмотрим в этой главе будут по смыслу дублировать друг друга. Выбор стиля скорее дело вкуса, существуют приверженцы и того и другого стиля, поэтому разработчики Haskell не хотели никого ограничивать.</p>
<h2 id="локальные-переменные">Локальные переменные</h2>
<p>Вспомним формулу вычисления площади треугольника по трём сторонам:</p>
<p><br /><span class="math">$S = \sqrt{p \cdot (p - a) \cdot (p - b) \cdot (p - c)}$</span><br /></p>
<p>Где <span class="math"><em>a</em></span>, <span class="math"><em>b</em></span> и <span class="math"><em>c</em></span> – длины сторон треугольника, а <span class="math"><em>p</em></span> это полупериметр.</p>
<p>Как бы мы определили эту функцию теми средствами, что у нас есть? Наверное, мы бы написали так:</p>

\begin{code}
square a b c = sqrt (p a b c * (p a b c - a) * (p a b c - b) * (p a b c - c))

p a b c = (a + b + c) / 2
\end{code}

<p>Согласитесь это не многим лучше чем решение в лоб:</p>

\begin{code}
square a b c = sqrt ((a+b+c)/2 * ((a+b+c)/2 - a) * ((a+b+c)/2 - b) * ((a+b+c)/2 - c))
\end{code}

<p>И в том и в другом случае нам приходится дублировать выражения, нам бы хотелось чтобы определение выглядело так же, как и обычное математическое определение:</p>

\begin{code}
square a b c = sqrt (p * (p - a) * (p - b) * (p - c))

p = (a + b + c) / 2
\end{code}

<p>Нам нужно, чтобы \In{p} знало, что \In{a}, \In{b} и \In{c} берутся из аргументов функции \In{square}. В этом нам помогут локальные переменные.</p>
<h3 id="where-выражения">where-выражения</h3>
<p>В декларативном стиле для этого предусмотрены  \In{where}-выражения. Они пишутся так:</p>

\begin{code}
square a b c = sqrt (p * (p - a) * (p - b) * (p - c))
    where p = (a + b + c) / 2
\end{code}

<p>Или так:</p>

\begin{code}
square a b c = sqrt (p * (p - a) * (p - b) * (p - c)) where 
    p = (a + b + c) / 2
\end{code}

<p>За определением функции следует специальное слово \In{where}, которое вводит локальные имена-синонимы. При этом аргументы функции включены в область видимости имён. Синонимов может быть несколько:</p>

\begin{code}
square a b c = sqrt (p * pa * pb * pc)
    where p  = (a + b + c) / 2
          pa = p - a
          pb = p - b
          pc = p - c
\end{code}

<p>Отметим, что отступы обязательны. Haskell по отступам понимает, что эти выражения относятся к \In{where}.</p>
<p>Как и в случае объявления функций порядок следования локальных переменных в \In{where}-выражении не важен. Главное чтобы в выражениях справа от знака равно мы пользовались именами из списка аргументов исходной функции или другими определёнными именами. Локальные переменные видны только в пределах той функции, в которой они вводятся.</p>
<p>Что интересно, слева от знака равно в \In{where}-выражениях можно проводить декомпозицию значений, также как и в аргументах функции:</p>

\begin{code}
pred :: Nat -> Nat
pred x = y
    where (Succ y) = x
\end{code}

<p>Эта функция делает тоже самое что и функция</p>

\begin{code}
pred :: Nat -> Nat
pred (Succ y) = y
\end{code}

<p>В \In{where}-выражениях можно определять новые функции а также выписывать их типы:</p>

\begin{code}
add2 x = succ (succ x)
    where succ :: Int -> Int
          succ x = x + 1
\end{code}

<p>А можно и не выписывать, компилятор догадается:</p>

\begin{code}
add2 x = succ (succ x)
    where succ x = x + 1
\end{code}

<p>Но иногда это бывает полезно, при использовании классов типов, для избежания неопределённости применения.</p>
<p>Приведём ещё один пример. Посмотрим на функцию фильтрации списков, она определена в \In{Prelude}:</p>

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  []     = []
filter  p  (x:xs) = if p x then x : rest else rest
    where rest = filter p xs
\end{code}

<p>Мы определили локальную переменную \In{rest}, которая указывает на рекурсивный вызов функции на оставшейся части списка.</p>
<p>\In{where}-выражения определяются для каждого уравнения в определении функции:</p>

\begin{code}
even :: Nat -> Bool
even Zero        = res
    where res = True
even (Succ Zero) = res
    where res = False
even x = even res
    where (Succ (Succ res)) = x
\end{code}

<p>Конечно в этом примере \In{where} не нужны, но здесь они приведены для иллюстрации привязки \In{where}-выражения к данному уравнению. Мы определили три локальных переменных с одним и тем же именем.</p>
<p>\In{where}-выражения могут быть и у значений, которые определяются внутри \In{where}-выражений. Но лучше избегать сильно вложенных выражений.</p>
<h3 id="let-выражения">let-выражения</h3>
<p>В композиционном стиле функция вычисления площади треугольника будет выглядеть так:</p>

\begin{code}
square a b c = let p = (a + b + c) / 2
               in  sqrt (p * (p - a) * (p - b) * (p - c)) 
\end{code}

<p>Слова  \In{let} и \In{in} – ключевые. Выгодным отличием \In{let}-выражений является то, что они являются обычными выражениями и не привязаны к определённому месту как \In{where}-выражения. Они могут участвовать в любой части обычного выражения:</p>

\begin{code}
square a b c = let p = (a + b + c) / 2
               in  sqrt ((let pa = p - a in p * pa) * 
                         (let pb = p - b
                              pc = p - c  
                          in  pb * pc)) 
\end{code}

<p>В этом проявляется их принадлежность композиционному стилю. \In{let}-выражения могут участвовать в любом подвыражении, они также группируются скобками. А \In{where}-выражения привязаны к уравнениям в определении функции.</p>
<p>Также как и в \In{where}-выражениях, в \In{let}-выражениях слева от знака равно можно проводить декомпозицию значений.</p>

\begin{code}
pred :: Nat -> Nat
pred x = let (Succ y) = x
         in  y
\end{code}

<p>Определим функцию фильтрации списков через \In{let}:</p>

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  []     = []
filter  p  (x:xs) = 
    let rest = filter p xs
    in  if p x then x : rest else rest
\end{code}

<h2 id="декомпозиция">Декомпозиция</h2>
<p>Декомпозиция или сопоставление с образцом позволяет выделять из составных значений, простейшие значения с помощью которых они были построены</p>

\begin{code}
pred (Succ x) = x
\end{code}

<p>и организовывать условные вычисления которые зависят от вида поступающих на вход функции значений</p>

\begin{code}
not True  = False
not False = True
\end{code}

<h3 id="сопоставление-с-образцом">Сопоставление с образцом</h3>
<p>Декомпозицию в декларативном стиле мы уже изучили, это обычный случай разбора значений в аргументах функции. Рассмотрим одну полезную возможность при декомпозиции. Иногда нам хочется провести декомпозицию и дать псевдоним всему значению. Это можно сделать с помощью специального символа \In{@}.</p>
<p>Например определим функцию, которая возвращает соседние числа для данного числа Пеано:</p>

\begin{code}
beside :: Nat -> (Nat, Nat)
beside  Zero       = error "undefined"
beside  x@(Succ y) = (y, Succ x)
\end{code}

<p>В выражении \In{x@``(Succ y)} мы одновременно проводим разбор и даём имя всему значению.</p>
<h3 id="case-выражения">case-выражения</h3>
<p>Оказывается декомпозицию можно проводить в любом выражении, для этого существуют  \In{case}-выражения:</p>

\begin{code}
data AnotherNat = None | One | Two | Many
    deriving (Show, Eq)

toAnother :: Nat -> AnotherNat
toAnother x = 
    case x of
        Zero                -> None
        Succ Zero           -> One
        Succ (Succ Zero)    -> Two
        _                   -> Many

fromAnother :: AnotherNat -> Nat
fromAnother None    = Zero
fromAnother One     = Succ Zero
fromAnother Two     = Succ (Succ Zero)
fromAnother Many    = error "undefined" 
\end{code}

<p>Слова \In{case} и \In{of} – ключевые. Выгодным отличием \In{case}-выражений является то, что нам не приходится каждый раз выписывать имя функции. Обратите внимание на то, что в \In{case}-выражениях также можно пользоваться обычными переменными и безымянными переменными.</p>
<p>Для проведения декомпозиции по нескольким переменным можно воспользоваться кортежами. Например определим знакомую функцию равенства для \In{Nat}:</p>

\begin{code}
instance Eq Nat where
    (==) a b =
        case (a, b) of
            (Zero,    Zero)     -> True
            (Succ a', Succ b')  -> a' == b'
            _                   -> False
\end{code}

<p>Мы проводим сопоставление с образцом по кортежу \In{(a, b)}, соответственно слева от знака \In{->} мы проверяем значения в кортежах, для этого мы также заключаем значения в скобки и пишем их через запятую.</p>
<p>Давайте определим функцию \In{filter} в ещё более композиционном стиле. Для этого мы заменим в исходном определении \In{where} на \In{let} и декомпозицию в аргументах на \In{case}-выражение:</p>

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  a = 
    case a of
        []      -> []
        x:xs    ->  let rest = filter p xs
                    in  if (p x) 
                        then (x:rest)
                        else rest
\end{code}

<h2 id="условные-выражения">Условные выражения</h2>
<p>С условными выражениями мы уже сталкивались в сопоставлении с образцом. Например в определении функции \In{not}:</p>

\begin{code}
not True  = False
not False = True
\end{code}

<p>В зависимости от поступающего значения мы выбираем одну из двух альтернатив. Условные выражении в сопоставлении с образцом позволяют реагировать лишь на частичное (с учётом переменных) совпадение дерева значения в аргументах функции.</p>
<p>Часто нам хочется определить более сложные условия для альтернатив. Например, если значение на входе функции больше 2, но меньше 10, верни \In{A}, а если больше 10, верни \In{B}, а во всех остальных случаях верни \In{C}. Или если на вход поступила строка состоящая только из букв латинского алфавита, верни \In{A}, а в противном случае верни \In{B}. Нам бы хотелось реагировать лишь в том случае, если значение некоторого типа \In{a} удовлетворяет некоторому предикату. Предикатами обычно называют функции типа \In{a -> Bool}. Мы говорим, что значение удовлетворяет предикату, если предикат для этого значения возвращает \In{True}.</p>
<h3 id="охранные-выражения">Охранные выражения</h3>
<p>В декларативном стиле условные выражения представлены <em>охранными выражениями</em> (guards). Предположим у нас есть тип:</p>

\begin{code}
data HowMany = Little | Enough | Many
\end{code}

<p>И мы хотим написать функцию, которая принимает число людей, которые хотят посетить выставку, а возвращает значение типа \In{HowMany}. Эта функция оценивает вместительность выставочного зала. С помощью охранных выражений мы можем написать её так:</p>

\begin{code}
hallCapacity :: Int -> HowMany
hallCapacity n
    | n < 10    = Little
    | n < 30    = Enough
    | True      = Many
\end{code}

<p>Специальный символ \In{|} уже встречался нам в определении типов. Там он играл роль разделителя альтернатив в сумме типов. Здесь же он разделяет альтернативы в условных выражениях. Сначала мы пишем \In{|} затем выражение-предикат, которое возвращает значение типа \In{Bool}, затем равно и после равно – возвращаемое значение. Альтернативы так же как и в случае декомпозиции аргументов функции обходятся сверху вниз, до тех пор пока в одной из альтернатив предикат не вернёт значение \In{True}. Обратите внимание на то, что нам не нужно писать во второй альтернативе:</p>

\begin{code}
    | 10 <= n && n < 30   = Enough
\end{code}

<p>Если вычислитель дошёл до этой альтернативы, значит значение точно больше либо равно \In{10}. Поскольку в предыдущей альтернативе предикат вернул \In{False}.</p>
<p>Предикат в последней альтернативе является константой \In{True}, он пройдёт сопоставление с любым значением \In{n}. В данном случае, если учесть предыдущие альтернативы мы знаем, что если вычислитель дошёл до последней альтернативы , значение \In{n} больше либо равно \In{30}. Для повышения наглядности кода в \In{Prelude} определена специальная константа-синоним значению \In{True} под именем \In{otherwise}.</p>
<p>Определим функцию \In{filter} для списков в более декларативном стиле, для этого заменим \In{if}-выражение в исходной версии на охранные выражения:</p>

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  []       = []
filter  p  (x:xs)   
    | p x           = x : rest
    | otherwise     = rest
    where rest = filter p xs
\end{code}

<p>Или мы можем разместить охранные выражения по-другому:</p>

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  []                   = []
filter  p  (x:xs)   | p x       = x : rest
                    | otherwise = rest
    where rest = filter p xs
\end{code}

<p>Отметим то, что локальная переменная \In{rest} видна и в той и в другой альтернативе. Вы спокойно можете пользоваться локальными переменными в любой части уравнения, в котором они определены.</p>
<p>Определим с помощью охранных выражений функцию \In{all}, она принимает предикат и список, и проверяет удовлетворяют ли все элементы списка данному предикату.</p>

\begin{code}
all :: (a -> Bool) -> [a] -> Bool
all p []        = True
all p (x:xs)    
    | p x       = all p xs
    | otherwise = False
\end{code}

<p>С помощью охранных выражений можно очень наглядно описывать условные выражения. Но иногда можно обойтись и простыми логическими операциями. Например функцию \In{all} можно было бы определить так:</p>

\begin{code}
all :: (a -> Bool) -> [a] -> Bool
all  p  []        = True
all  p  (x:xs)    = p x && all p xs
\end{code}

<p>Или так:</p>

\begin{code}
all :: (a -> Bool) -> [a] -> Bool
all  p  xs = null (filter notP xs)
    where notP x = not (p x)
\end{code}

<p>Или даже так:</p>

\begin{code}
import Prelude(all)
\end{code}

<p>Функция \In{null} определена в \In{Prelude} она возвращает \In{True} только если список пуст.</p>
<h3 id="if-выражения">if-выражения</h3>
<p>В композиционном стиле в качестве условных выражений используются уже знакомые нам \In{if}-выражения. Вспомним как они выглядят:</p>

\begin{code}
a = if bool 
    then x1
    else x2
\end{code}

<p>Слова \In{if}, \In{then} и \In{else} – ключевые. Тип \In{a}, \In{x1} и \In{x2} совпадают.</p>
<p>Любое охранное выражение, в котором больше одной альтернативы, можно представить в виде \In{if}-выражения и наоборот. Перепишем все функции их предыдущего подраздела с помощью \In{if}-выражений:</p>

\begin{code}
hallCapacity :: Int -> HowMany
hallCapacity n =
    if (n < 10)
    then Little
    else (if n < 30 
          then Enough
          else Many)

all :: (a -> Bool) -> [a] -> Bool
all p []     = True
all p (x:xs) = if (p x) then all p xs else False
\end{code}

<h2 id="определение-функций">Определение функций</h2>
<p>Под функцией мы понимаем составной синоним, который принимает аргументы, возможно разбирает их на части и составляет из этих частей новые выражения. Теперь посмотрим как такие синонимы определяются в каждом из стилей.</p>
<h3 id="уравнения">Уравнения</h3>
<p>В декларативном стиле функции определяются с помощью уравнений. Пока мы видели лишь этот способ определения функций, примерами могут служить все предыдущие примеры. Вкратце напомним, что функция определяется набором уравнений вида:</p>

\begin{code}
name декомпозиция1 = композиция1
name декомпозиция2 = композиция2
...
name декомпозицияN = композицияN
\end{code}

<p>Где \In{name} – имя функции. В \In{декомпозиции} происходит разбор поступающих на вход значений, а в \In{композиции} происходит составление значения результата. Уравнения обходятся вычислителем сверху вниз до тех пор пока он не найдёт такое уравнение, для которого переданные в функции значения не подойдут в указанный в декомпозиции шаблон значений (если сопоставление с образцом аргументов пройдёт успешно). Как только такое уравнение найдено, составляется выражение справа от знака равно (\In{композиция}). Это значение будет результатом функции. Если такое уравнение не будет найдено программа остановится с ошибкой.</p>
<p>К примеру попробуйте вычислить в интерпретаторе выражение \In{notT False}, для такой функции:</p>

\begin{code}
notT :: Bool -> Bool
notT True = False
\end{code}

<p>Что мы увидим?</p>

\begin{code}
Prelude> notT False
*** Exception: <interactive>:1:4-20: Non-exhaustive patterns in function notT
\end{code}

<p>Интерпретатор сообщил нам о том, что он не нашёл уравнения для переданного в функцию значения.</p>
<h3 id="безымянные-функции">Безымянные функции</h3>
<p>В композиционном стиле функции определяются по-другому. Это необычный метод, он пришёл в Haskell из лямбда-исчисления. Функции строятся с помощью специальных конструкций, которые называются лямбда-функциями. По сути лямбда-функции являются безымянными функциями. Давайте посмотрим на лямбда функцию, которая прибавляет к аргументу единицу:</p>

\begin{code}
\x -> x + 1
\end{code}

<p>Для того, чтобы превратить лямбда-функцию в обычную функцию мысленно замените знак \verb!\! на имя \In{noName}, а стрелку на знак равно:</p>

\begin{code}
noName x = x + 1
\end{code}

<p>Мы получили обычную функцию Haskell, с такими мы уже много раз встречались. Зачем специальный синтаксис для определения безымянных функций? Ведь можно определить её в виде уравнений. К тому же кому могут понадобиться безымянные функции? Ведь смысл функции в том, чтобы выделить определённый шаблон поведения и затем ссылаться на него по имени функции.</p>
<p>Смысл безымянной функции в том, что ею, также как и любым другим элементом композиционного стиля, можно пользоваться в любой части обычных выражений. С её помощью мы можем создавать функции “на лету”. Предположим, что мы хотим профильтровать список чисел, мы хотим выбрать из них лишь те, что меньше 10, но больше 2, и к тому же они должны быть чётными. Мы можем написать:</p>

\begin{code}
f :: [Int] -> [Int]
f = filter p
    where p x = x > 2 && x < 10 && even x
\end{code}

<p>При этом нам приходится давать какое-нибудь имя предикату, например \In{p}. С помощью безымянной функции мы могли бы написать так:</p>

\begin{code}
f :: [Int] -> [Int]
f = filter (\x -> x > 2 && x < 10 && even x)
\end{code}

<p>Смотрите мы составили предикат сразу в аргументе функции \In{filter}. Выражение (\verb!\!x -> x > 2 && x < 10 && even x) является обычным значением.</p>
<p>Возможно у вас появился вопрос, где аргумент функции? Где тот список по которому мы проводим фильтрацию. Ответ на этот вопрос кроется в частичном применении. Давайте вычислим по правилу применения тип функции \In{filter}:</p>

\begin{code}
    f :: (a -> Bool) -> [a] -> [a],    x :: (Int -> Bool)
    ------------------------------------------------------
                (f x) :: [Int] -> [Int]
\end{code}

<p>После применения параметр \In{a} связывается с типом \In{Int}, поскольку при применении происходит сопоставление более общего предиката \In{a -> Bool} из функции \In{filter} с тем, который мы передали первым аргументом \In{Int -> Bool}. После этого мы получаем тип \In{(f x) :: [Int] -> [Int]} это как раз тип функции, которая принимает список целых чисел и возвращает список целых чисел. Частичное применение позволяет нам не писать в таких выражениях:</p>

\begin{code}
f xs = filter p xs
    where p x = ...
\end{code}


<p>последний аргумент \In{xs}.</p>
<p>К примеру вместо</p>

\begin{code}
add a b = (+) a b
\end{code}


<p>мы можем просто написать:</p>

\begin{code}
add = (+)
\end{code}

<p>Такой стиль определения функций называют <em>бесточечным</em> (point-free).</p>
<p>Давайте выразим функцию \In{filter} с помощью лямбда-функций:</p>

\begin{code}
filter :: (a -> Bool) -> ([a] -> [a])
filter = \p -> \xs -> case xs of
    []     -> []
    (x:xs) -> let rest = filter p xs
              in  if   p x
                  then x : rest
                  else rest
\end{code}

<p>Мы определили функцию \In{filter} пользуясь только элементами композиционного стиля. Обратите внимание на скобки в объявлении типа функции. Я хотел напомнить вам о том, что все функции в Haskell являются функциями одного аргумента. Это определение функции \In{filter} как нельзя лучше подчёркивает этот факт. Мы говорим, что функция \In{filter} является функцией одного аргумента \In{p} в выражении \verb!\!p ->, которая возвращает также функцию одного аргумента. Мы выписываем это в явном виде в выражении \verb!\!xs ->. Далее идёт выражение, которое содержит определение функции.</p>
<p>Отметим, что лямбда функции могут принимать несколько аргументов, в предыдущем определении мы могли бы написать:</p>

\begin{code}
filter :: (a -> Bool) -> ([a] -> [a])
filter = \p xs -> case xs of
    ...
\end{code}


<p>но это лишь синтаксический сахар, который разворачивается в предыдущую запись.</p>
<p>Для тренировки определим несколько стандартных функций для работы с кортежами с помощью лямбда-функций (все они определены в \In{Prelude}):</p>

\begin{code}
fst :: (a, b) -> a
fst = \(a, _) -> a

snd :: (a, b) -> b
snd = \(_, b) -> b

swap :: (a, b) -> (b, a)
swap = \(a, b) -> (b, a)
\end{code}

<p>Обратите внимание на то, что все функции словно являются константами. Они не содержат аргументов. Аргументы мы “пристраиваем” с помощью безымянных функций.</p>
<p>Определим функции преобразования первого и второго элемента кортежа (эти функции определены в модуле \In{Control.Arrow})</p>

\begin{code}
first :: (a -> a') -> (a, b) -> (a', b)
first = \f (a, b) -> (f a, b)

second :: (b -> b') -> (a, b) -> (a, b')
second = \f (a, b) -> (a, f b)
\end{code}

<p>Также в \In{Prelude} есть полезные функции, которые превращают функции с частичным применением в обычны функции и наоборот:</p>

\begin{code}
curry :: ((a, b) -> c) -> a -> b -> c
curry = \f -> \a -> \b -> f (a, b)

uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry = \f -> \(a, b) -> f a b
\end{code}

<p>Функция \In{curry} принимает функцию двух аргументов для которой частичное применение невозможно. Это имитируется с помощью кортежей. Функция принимает кортеж из двух элементов. Функция \In{curry} (от слова каррирование, частичное применение) превращает такую функцию в обычную функцию Haskell. А функция \In{uncurry} выполняет обратное преобразование.</p>
<p>С помощью лямбда-функций можно имитировать локальные переменные. Так например можно переписать формулу для вычисления площади треугольника:</p>

\begin{code}
square a b c = 
    (\p -> sqrt (p * (p - a) * (p - b) * (p - c))) 
    ((a + b + c) / 2)
\end{code}

<p>Смотрите мы определили функцию, которая принимает параметром полупериметр \In{p} и передали в неё значение \In{((a + b + c) / 2)}. Если в нашей функции несколько локальных переменных, то мы можем составить лямбда-функцию от нескольких переменных и подставить в неё нужные значения.</p>
<h2 id="какой-стиль-лучше">Какой стиль лучше?</h2>
<p>Основной критерий выбора заключается в том, сделает ли этот элемент код более <em>ясным</em>. Наглядность кода станет залогом успешной поддержки. Его будет легче понять и улучшить при необходимости.</p>
<p>Далее мы рассмотрим несколько примеров определений из \In{Prelude} и подумаем, почему был выбран тот или иной стиль. Начнём с класса \In{Ord} и посмотрим на определения по умолчанию:</p>

\begin{code}
-- Тип упорядочивания

data  Ordering  =  LT | EQ | GT
          deriving (Eq, Ord, Enum, Read, Show, Bounded)


class  (Eq a) => Ord a  where
    compare              :: a -> a -> Ordering
    (<), (<=), (>=), (>) :: a -> a -> Bool
    max, min             :: a -> a -> a

        -- Минимальное полное определение:
        --      (<=) или compare
        -- Использование compare может оказаться более 
        -- эффективным для сложных типов.
    compare x y
         | x == y    =  EQ
         | x <= y    =  LT
         | otherwise =  GT

    x <= y           =  compare x y /= GT
    x <  y           =  compare x y == LT
    x >= y           =  compare x y /= LT
    x >  y           =  compare x y == GT

    max x y 
         | x <= y    =  y
         | otherwise =  x
    min x y
         | x <= y    =  x
         | otherwise =  y
\end{code}

<p>Все функции определены в декларативном стиле. Тип \In{Ordering} кодирует результат операции сравнения. Два числа могут быть либо равны (значение \In{EQ}), либо первое меньше второго (значение \In{LT}), либо первое больше второго (значение \In{GT}).</p>
<p>Обратите внимание на функцию \In{compare}. Мы не пишем дословное определение значений типа \In{Ordering}:</p>

\begin{code}
    compare x y
         | x == y    =  EQ
         | x <  y    =  LT
         | x >  y    =  GT
\end{code}

<p>В этом случае функция \In{compare} была бы определена через две других функции класса \In{Ord}, а именно больше \In{>} и меньше \In{<}. Мы же хотим минимизировать число функций в этом определении. Поэтому вместо этого определения мы полагаемся на очерёдность обхода альтернатив в охранном выражении.</p>
<p>Если первый случай не прошёл, то во втором случае нет разницы между функциями \In{<} и \In{<=}. А если не прошёл и этот случай, то остаётся только вернуть значение \In{GT}. Так мы определили функцию \In{compare} через одну функцию класса \In{Ord}.</p>
<p>Теперь посмотрим на несколько полезных функций для списков. Посмотрим на три основные функции для списков, одна из них возможно вам уже порядком поднадоела:</p>

\begin{code}
-- Преобразование списка
map :: (a -> b) -> [a] -> [b]
map f []     = []
map f (x:xs) = f x : map f xs

-- Фильтрация списка
filter :: (a -> Bool) -> [a] -> [a]
filter p []                 = []
filter p (x:xs) | p x       = x : filter p xs
                | otherwise = filter p xs

-- Свёртка списка
foldr            :: (a -> b -> b) -> b -> [a] -> b
foldr f z []     =  z
foldr f z (x:xs) =  f x (foldr f z xs)
\end{code}

<p>Приведём несколько примеров для функции \In{foldr}:</p>

\begin{code}
and, or :: [Bool] -> Bool
and = foldr (&&) True
or  = foldr (||) False

(++) :: [a] -> [a] -> [a]
[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
    
concat :: [[a]] -> [a]
concat = foldr (++) []
\end{code}

<p>Функции \In{and} и \In{or} выполняют логические операции на списках. Так каждый конструктор \In{(:)} заменяется на соответствующую логическую операцию, а пустой список заменяется на значение, которое не влияет на результат выполнения данной логической операции. Имеется ввиду, что функции \In{(&& True)} и \In{(|| False)} дают тот же результат, что и функция \In{id x = x}. Функция \In{(++)} объединяет два списка, а функция \In{concat} выполняет ту же операцию, но на списке списков.</p>
<p>Функция \In{zip} принимает два списка и смешивает их в список пар. Как только один из списков оборвётся оборвётся и список-результат. Эта функция является частным случаем более общей функции \In{zipWith}, которая принимает функцию двух аргументов и два списка и составляет новый список попарных применений.</p>

\begin{code}
-- zip-ы 
zip :: [a] -> [b] -> [(a, b)]
zip = zipWith (,)

zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith z (a:as) (b:bs) =  z a b : zipWith z as bs
zipWith _ _ _           =  []
\end{code}

<p>Посмотрим как работают эти функции в интерпретаторе:</p>

\begin{code}
Prelude> zip [1,2,3] "hello"
[(1,'h'),(2,'e'),(3,'l')]
Prelude> zipWith (+) [1,2,3] [3,2,1]
[4,4,4]
Prelude> zipWith (*) [1,2,3] [5,4,3,2,1]
[5,8,9]
\end{code}

<p>Отметим, что в \In{Prelude} также определена обратная функция \In{unzip}:</p>

\begin{code}
unzip   :: [(a,b)] -> ([a], [b]) 
\end{code}

<p>Она берёт список пар и разбивает его на два списка.</p>
<p>Пока по этим определениям кажется, что композиционный стиль совсем нигде не применяется. Он встретился нам лишь в функции \In{break}. Но давайте посмотрим и на функции с композиционным стилем:</p>

\begin{code}
lines            :: String -> [String]
lines ""         =  []
lines s          =  let (l, s') = break (== '\n') s
                    in  l : case s' of
                              []      -> []
                              (_:s'') -> lines s''
\end{code}

<p>Функция \In{line} разбивает строку на список строк. Эти строки были разделены в исходной строке символом переноса '\verb!\!n'.</p>
<p>Функция \In{break} принимает предикат и список и возвращает два списка. В первом все элементы от начала списка, которые не удовлетворяют предикату, а во втором все остальные. Наш предикат (== '\verb!\!n') выделяет все символы кроме переноса каретки. В строке</p>

\begin{code}
let (l, s') = break (== '\n') s
\end{code}

<p>Мы сохраняем все символы до '\verb!\!n' от начала строки в переменной \In{l}. Затем мы рекурсивно вызываем функцию \In{lines} на оставшейся части списка:</p>

\begin{code}
                    in  l : case s' of
                              []      -> []
                              (_:s'') -> lines s''
\end{code}

<p>При этом мы пропускаем в \In{s'} первый элемент, поскольку он содержит символ переноса каретки.</p>
<p>Посмотрим на ещё одну функцию для работы со строками.</p>

\begin{code}
words            :: String -> [String]
words s          =  case dropWhile Char.isSpace s of
                      "" -> []
                      s' -> w : words s''
                            where (w, s'') = break Char.isSpace s'
\end{code}

<p>Функция \In{words} делает тоже самое, что и \In{lines}, только теперь в качестве разделителя выступает пробел. Функция \In{dropWhile} отбрасывает от начала списка все элементы, которые удовлетворяют предикату. В строке</p>

\begin{code}
case dropWhile Char.isSpace s of
\end{code}

<p>Мы одновременно отбрасываем все первые пробелы и готовим значение для декомпозиции. Дальше мы рассматриваем два возможных случая для строк.</p>

\begin{code}
                      "" -> []  
                      s' -> w : words s''
                            where (w, s'') = break Char.isSpace s'
\end{code}

<p>Если строка пуста, то делать больше нечего. Если – нет, мы также как и в предыдущей функции применяем функцию \In{break} для того, чтобы выделить все элементы кроме пробела, а затем рекурсивно вызываем функцию \In{words} на оставшейся части списка.</p>
<h2 id="краткое-содержание">Краткое содержание</h2>
<p>В этой главе мы узнали очень много новых синтаксических конструкций для определения функций. Они появлялись парами. Сведём их в таблицу:</p>
<table>
<col width="28%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr class="header">
<th align="left">Элемент</th>
<th align="left">Декларативный стиль</th>
<th align="left">Композиционный</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Локальные переменные</td>
<td align="left">\In{where}-выражения</td>
<td align="left">\In{let}-выражения</td>
</tr>
<tr class="even">
<td align="left">Декомпозиция</td>
<td align="left">Сопоставление с образцом</td>
<td align="left">\In{case}-выражения</td>
</tr>
<tr class="odd">
<td align="left">Условные выражения</td>
<td align="left">Охранные выражения</td>
<td align="left">\In{if}-выражения</td>
</tr>
<tr class="even">
<td align="left">Определение функций</td>
<td align="left">Уравнения</td>
<td align="left">лямбда-функции</td>
</tr>
</tbody>
</table>
<h4 id="особенности-синтаксиса">Особенности синтаксиса</h4>
<p>Нам встретилась новая конструкция в сопоставлении с образцом:</p>

\begin{code}
beside :: Nat -> (Nat, Nat)
beside  Zero       = error "undefined"
beside  x@(Succ y) = (y, Succ x)
\end{code}

<p>Она позволяет проводить декомпозицию и давать имя всему значению одновременно. Такие выражения \In{x@(...)} в англоязычной литературе принято называть as-patterns.</p>
<h2 id="упражнения">Упражнения</h2>
<ul>
<li><p>В этой главе нам встретилось много полезных стандартных функций, потренируйтесь с ними в интерпретаторе. Вызывайте их с различными значениями, экспериментируйте.</p></li>
<li><p>Попробуйте определить функции из предыдущих глав в чисто композиционном стиле.</p></li>
<li><p>Посмотрите на те функции, которые мы прошли и попробуйте переписать их определения шиворот на выворот. Если вы видите, что элемент написан композиционном стиле перепишите его в декларативном и наоборот. Получившиеся функции могут показаться монстрами, но это упражнение может помочь вам в закреплении новых конструкций и почувствовать сильные и слабые стороны того или иного стиля.</p></li>
<li><p>Определите модуль, который будет вычислять площади простых фигур, треугольника, окружности, прямоугольника, трапеции. Помните, что фигуры могут задаваться различными способами.</p></li>
<li><p>Поток это бесконечный список, т.е.~список, у которого нет конструктора пустого списка:</p></li>
</ul>

\begin{code}
data Stream a = a :& Stream a
\end{code}

<p>Так например мы можем составить поток из всех чисел Пеано:</p>

\begin{code}
nats :: Nat -> Stream Nat
nats a = a :& nats (Succ a) 
\end{code}

<p>Или поток, который содержит один и тот же элемент:</p>

\begin{code}
constStream :: a -> Stream a
constStream a = a :& constStream a 
\end{code}

<p>Напишите модуль для потоков. В первую очередь нам понадобятся функции выделения частей потока, поскольку мы не сможем распечатать поток целиком (ведь он бесконечный):</p>

\begin{code}
-- Первый элемент потока
head :: Stream a -> a

-- Хвост потока, всё кроме первого элемента
tail :: Stream a -> Stream a

-- n-тый элемент потока
(!!) :: Stream a -> Int -> a

-- Берёт из потока несколько первых элементов:
take :: Int -> Stream a -> [a]
\end{code}

<p>Имена этих функций будут совпадать с именами функций для списков чтобы избежать коллизий имён мы воспользуемся квалифицированным импортом функций. Делается это так:</p>

\begin{code}
import qualified Prelude as P( определения )
\end{code}

<p>Слова  \In{qualified} и \In{as} – ключевые. Теперь для использования функций из модуля \In{Prelude} мы будем писать \In{P.имяФункции}. Такие имена называются квалифицированными. Для того чтобы пользоваться квалифицированными именами только для тех функций, для которых возможна коллизия имён можно поступить так:</p>

\begin{code}
import qualified Prelude as P
import Prelude
\end{code}

<p>Компилятор разберётся, какую функцию мы имеем в виду.</p>
<p>Для удобства тестирования можно определить такую функцию печати потоков:</p>

\begin{code}
instance Show a => Show (Stream a) where
    show xs =  showInfinity (show (take 5 xs))
        where showInfinity x = P.init x  P.++ "..."
\end{code}

<p>Функция \In{P.init} выделяет все элементы списка кроме последнего. В данном случае она откусит от строки закрывающуюся скобку. После этого мы добавляем троеточие, как символ бесконечности списка.</p>
<p>Функции преобразования потоков:</p>

\begin{code}
-- Преобразование потока
map :: (a -> b) -> Stream a -> Stream b

-- Фильтрация потока
filter :: (a -> Bool) -> Stream a -> Stream a

-- zip-ы для потоков:
zip :: Stream a -> Stream b -> Stream (a, b)

zipWith :: (a -> b -> c) -> Stream a -> Stream b -> Stream c 
\end{code}

<p>Функция генерации потока:</p>

\begin{code}
iterate :: (a -> a) -> a -> Stream a
\end{code}

<p>Эта функция принимает два аргумента: функцию следующего элемента потока и значение первого элемента потока и возвращает поток:</p>

\begin{code}
iterate f a = a :& f a :& f (f a) :& f (f (f a)) :& ...
\end{code}

<p>Так с помощью этой функции можно создать поток всех чисел Пеано от нуля или постоянный поток:</p>

\begin{code}
nats            = iterate Succ Zero 
constStream a   = iterate (\x -> x) a
\end{code}

<p>Возможно вас удивляет тот факт, что в этом упражнении мы оперируем бесконечными значениями, но пока мы не будем вдаваться в детали того как это работает, просто попробуйте определить этот модуль и посмотрите в интерпретаторе, что получится.</p>
</body>
</html>
