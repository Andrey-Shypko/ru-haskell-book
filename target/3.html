<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<h1 id="типы">Типы</h1>
<p>С помощью типов мы определяем все возможные значения в нашей программе. Мы определяем основные примитивы и способы их комбинирования. Например в типе \In{Nat}:</p>

\begin{code}
data Nat = Zero | Succ Nat
\end{code}

<p>Один конструктор-примитив \In{Zero}, и один конструктор \In{Succ}, с помощью которого мы можем делать составные значения. Определив тип \In{Nat} таким образом, мы говорим, что значения типа \In{Nat} могут быть только такими:</p>

\begin{code}
    Zero,  Succ Zero,  Succ (Succ Zero), Succ (Succ (Succ Zero)), ...
\end{code}

<p>Все значения являются цепочками \In{Succ} с \In{Zero} на конце. Если где-нибудь мы попытаемся построить значение, которое не соответствует нашему типу, мы получим ошибку компиляции, т.е.~программа не пройдёт проверку типов. Так типы описывают множество допустимых значений.</p>
<p>Значения, которые проходят проверку типов мы будем называть <em>допустимыми</em>, а те, которые не проходят соответственно <em>недопустимыми</em>. Так например следующие значения недопустимы для \In{Nat}</p>

\begin{code}
    Succ Zero Zero,  Succ Succ, True, Zero (Zero Succ), ...
\end{code}

<p>Недопустимых значений конечно гораздо больше. Такое проявляется и в естественном языке, бессмысленных комбинаций слов гораздо больше, чем осмысленных предложений. Обратите внимание на то, что мы говорим о значениях (не)допустимых для некоторого типа, например значение \In{True} допустимо для \In{Bool}, но недопустимо для \In{Nat}.</p>
<p>Сами типы строятся не произвольным образом. Мы узнали, что при их построении используются две основные операции, это сумма и произведение типов. Это говорит о том, что в типах должны быть какие-то закономерности, которые распространяются на все значения. В этой главе мы посмотрим на эти закономерности.</p>
<h2 id="структура-алгебраических-типов-данных">Структура алгебраических типов данных</h2>
<p>Итак у нас лишь две операции: сумма и произведение. Давайте для начала рассмотрим два крайних случая.</p>
<ul>
<li><p>Только произведение типов</p>

\begin{code}
data T = Name T1 T2 ... TN
\end{code}

<p>Мы говорим, что значение нашего нового типа \In{T} состоит из значений типов \In{T1}, \In{T2}, … , \In{TN} и у нас есть лишь один способ составить значение этого типа. Единственное, что мы можем сделать это применить к значениям типов \In{Ti} конструктор \In{Name}.</p>
<p>Пример:</p>

\begin{code}
data Time = Time Hour Second Minute
\end{code}
</li>
<li><p>Только сумма типов</p>

\begin{code}
data T = Name1 | Name2 | ... | NameN
\end{code}

<p>Мы говорим, что у нашего нового типа \In{T} может быть лишь несколько значений, и перечисляем их в альтернативах через знак \In{|}.</p>
<p>Пример:</p>

\begin{code}
data Bool = True | False
\end{code}
</li>
</ul>
<p>Сделаем первое наблюдение: каждое произведение типов определяет новый конструктор. Число конструкторов в типе равно числу альтернатив. Так в первом случае у нас была одна альтернатива и следовательно у нас был лишь один конструктор \In{Name}.</p>
<p>Имена конструкторов должны быть уникальными в пределах модуля. У нас нет таких двух типов, у которых совпадают конструкторы. Это говорит о том, что по имени конструктора компилятор знает значение какого типа он может построить.</p>
<p>Произведение типов состоит из конструктора, за которым через пробел идут подтипы. Такая структура не случайна, она копирует структуру функции. В качестве имени функции выступает конструктор, а в качестве аргументов – значения заданных в произведении подтипов. Функция-конструктор после применения “оборачивает” значения аргументов и создаёт новое значение. За счёт этого мы могли бы определить типы по-другому. Мы могли бы определить их в стиле классов типов:</p>

\begin{code}
data Bool where
    True  :: Bool
    False :: Bool
\end{code}

<p>Мы видим “класс” \In{Bool}, у которого два метода. Или определим в таком стиле \In{Nat}:</p>

\begin{code}
data Nat where
    Zero  :: Nat
    Succ  :: Nat -> Nat
\end{code}

<p>Мы переписываем подтипы по порядку в аргументы метода. Или определим в таком стиле списки:</p>

\begin{code}
data [a] where
    []   :: [a]
    (:)  :: a -> [a] -> [a] 
\end{code}

<p>Конструктор пустого списка \In{[]} является константой, а конструктор объединения элемента со списком \In{(:)}, является функцией. Когда я говорил, что типы определяют примитивы и методы составления из примитивов, я имел ввиду, что некоторые конструкторы по сути являются константами, а другие функциями.</p>
<p>Эти “методы” определяют базовые значения типа, все другие значения будут комбинациями базовых. При этом сумма типов, определяет число методов “классе” типа, т.е.~число базовых значений, а произведение типов в каждой альтернативе определяет имя метода (именем конструктора) и состав аргументов (перечислением подтипов).</p>
<h2 id="структура-констант">Структура констант</h2>
<p>Мы уже знаем, что значения могут быть функциями и константами. Объявляя константу, мы даём имя-синоним некоторой комбинации базовых конструкторов. В функции мы говорим как по одним значениям получить другие. В этом и следующем разделе мы посмотрим на то, как типы определяют структуру констант и функций.</p>
<p>Давайте присмотримся к константам:</p>

\begin{code}
Succ (Succ Zero)
Neg (Add One (Mul Six Ten))
Not (Follows A (And A B))
Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))
\end{code}

<p>Заменим все функциональные конструкторы на букву \In{f} (от слова <em>function</em>), а все примитивные конструкторы на букву \In{c} (от слова <em>constant</em>).</p>

\begin{code}
f (f c)
f (f c (f c c))
f (f c (f c c))
f c (f c (f c (f c c)))
\end{code}

<p>Те кто знаком с теорией графов, возможно уже узнали в этой записи строчную запись дерева. Все значения в Haskell являются деревьями. Узел дерева содержит составной конструктор, а лист дерева содержит примитивный конструктор. Далее будет небольшой подраздел посвящённый терминологии теории графов, которая нам понадобится, будет много картинок, если вам это известно, то вы можете спокойно его пропустить.</p>
<h3 id="несколько-слов-о-теории-графов">Несколько слов о теории графов</h3>
<p>Если вы не знакомы с теорией графов, то сейчас как раз самое время с ней познакомится, хотя бы на уровне основных терминов. Теория графов изучает дискретные объекты в терминах зависимостей между объектами или связей. При этом объекты и связи можно изобразить графически.</p>
<p>Граф состоит из <em>узлов</em> и <em>рёбер</em>, которые соединяют узлы. Приведём пример графа:</p>
<p></p>
<p>В этом графе восемь узлов, они пронумерованы, и восемь рёбер, они обозначены буквами. Теорию графов придумал Леонард Эйлер, когда решал задачу о кёнингсбергских мостах. Он решал задачу о том, можно ли обойти все семь кёнингсбергских мостов так, чтобы пройти по каждому лишь один раз. Эйлер представил мосты в виде рёбер а участки суши в виде узлов графа и показал, что это сделать нельзя. Но мы отвлеклись.</p>
<p>А что такое дерево? <em>Дерево</em> это такой связанный граф, у которого нет циклов. Несвязанный граф образует несколько островков, или множеств узлов, которые не соединены рёбрами. Циклы – это замкнутые последовательности рёбер. Например граф на рисунке выше не является деревом, но если мы сотрём ребро <em>e</em>, то у нас получится дерево.</p>
<p>Ориентированный граф – это такой граф, у которого все рёбра являются стрелками, они ориентированы, отсюда и название. При этом теперь каждое ребро не просто связывает узлы, но имеет начало и конец. В ориентированных деревьях обычно выделяют один узел, который называют <em>корнем</em>. Его особенность заключается в том, что все стрелки в ориентированном дереве как бы “разбегаются” от корня или сбегаются к корню. Корень определяет все стрелки в дереве. Ориентированное дерево похоже на иерархию. У нас есть корневой элемент и набор его дочерних поддеревьев, каждое из поддеревьев в свою очередь является ориентированным деревом и так далее. Проиллюстрируем на картинке, давайте сотрём ребро <em>e</em> и назначим первый узел корнем. Все наши стрелки будут идти от корня. Сначала мы проведём стрелки к узлам связанным с корнем:</p>
<p></p>
<p>Затем представим, что каждый из этих узлов сам является корнем в своём дереве и повторим эту процедуру. На этом шаге мы дорисовываем стрелки в поддеревьях, которые находятся в узлах 3 и 6. Узел 5 является вырожденным деревом, в нём всего лишь одна вершина. Мы будем называть такие поддеревья <em>листьями</em>. А невырожденные поддеревья мы будем называть узлами. Корневой узел в данном поддереве называют родительским. А его соседние узлы, в которые направлены исходящие из него стрелки называют дочерними узлами. На предыдущем шаге у нас появился один родительский узел 1, у которого три дочерних узла: 3, 6, и 5. А на этом шаге у нас появились ещё два родительских узла 3 и 6. У узла 3 один дочерний узел (4), а у узла 6 – три дочерних узла (2, 8, 7).</p>
<p></p>
<p>Отметим, что положение узлов и рёбер на картинке не важно, главное это то, какие рёбра какие узлы соединяют. Мы можем перерисовать это дерево в более привычном виде ().</p>
<p>Теперь если вы посмотрите на константы в Haskell вы заметите, что очень похожи на деревья. Листья содержат примитивные конструкторы, а узлы – составные. Это происходит из-за того, что каждый конструктор содержит метку и набор подтипов. В этой аналогии метки становятся узлами, а подтипы-аргументы становятся поддеревьями.</p>
<p></p>
<p>Но есть одна тонкость, в которой заключается отличие констант Haskell от деревьев из теории графов. В теории графов порядок поддеревьев не важен, мы могли бы нарисовать поддеревья в любом порядке, главное сохранить связи. А в Haskell порядок следования аргументов в конструкторе важен.</p>
<p>На следующем рисунке () изображены две константы:<br />\In{Succ (Succ Zero) :: Nat} и \In{Neg (Add One (Mul Six Ten)) :: Expr}. Но они изображены немного по-другому. Я перевернул стрелки и добавил корнем ещё один узел, это тип константы.</p>
<p></p>
<p>Стрелки перевёрнуты так, чтобы стрелки на картинке соответствовали стрелкам в типе конструктора. Например по виду узла \In{Succ :: Nat -> Nat}, можно понять, что это функция от одного аргумента, в неё впадает одна стрелка-аргумент и вытекает одна стрелка-значение. В конструктор \In{Mul} впадает две стрелки, значит это конструктор-функция от двух аргументов.</p>
<p>Константы похожи на деревья за счёт структуры операции произведения типов. В произведении типов мы пишем:</p>

\begin{code}
data Tnew = Name T1 T2 ... Tn
\end{code}

<p>Так и получается, что у нашего узла \In{New} одна вытекающая стрелка, которая символизирует значение типа \In{Tnew} и несколько впадающих стрелок \In{T1}, \In{T2}, …, \In{Tn}, они символизируют аргументы конструктора.</p>
<p>Потренируйтесь изображать константы в виде деревьев, вспомните константы из предыдущей главы, или придумайте какие-нибудь новые.</p>
<h3 id="строчная-запись-деревьев">Строчная запись деревьев</h3>
<p>Итак все константы в Haskell за счёт особой структуры построения типов являются деревьями, но мы программируем в текстовом редакторе, а не в редакторе векторной графики, поэтому нам нужен удобный способ строчной записи дерева. Мы им уже активно пользуемся, но сейчас давайте опишем его по-подробнее.</p>
<p>Мы сидим на корне дерева и спускаемся по его вершинам. Нам могут встретиться вершины двух типов узлы и листья. Сначала мы пишем имя в текущем узле, затем через пробел имена в дочерних узлах, если нам встречается невырожденный узел мы заключаем его в скобки. Давайте последовательно запишем в строчной записи дерево из первого примера:</p>
<p></p>
<p>Начнём с корня и будем последовательно дописывать поддеревья, точками обозначаются дочерние узлы, которые нам ещё предстоит дописать:</p>

\begin{code}
(1     .       .      .       )
(1    (3 .)    5     (6 . . .))
(1    (3 4)    5     (6 2 7 8))
\end{code}

<p>Мы можем ставить любое число пробелов между дочерними узлами, здесь для наглядности точки выровнены. Так мы можем закодировать исходное дерево строкой. Часто самые внешние скобки опускаются. В итоге получилась такая запись:</p>

\begin{code}
tree = 1 (3 4) 5 (6 2 7 8)
\end{code}

<p>По этой записи мы можем понять, что у нас есть два конструктора трёх аргументов \In{1} и \In{6}, один конструктор одного аргумента \In{3} и пять примитивных конструкторов. Точно так же мы строим и все другие константы в Haskell:</p>

\begin{code}
Succ (Succ (Succ Zero))
Time (Hour 13) (Minute 10) (Second 0)
Mul (Add One Ten) (Neg (Mul Six Zero))
\end{code}

<p>За одним исключением, если конструктор бинарный, символьный (начинается с двоеточия), мы помещаем его между аргументов:</p>

\begin{code}
(One :+ Ten) :* (Neg (Six :* Zero))
\end{code}

<h2 id="структура-функций">Структура функций</h2>
<p>Функции описывают одни значения в терминах других. При этом важно понимать, что функция это лишь новое имя, пусть и составное. Мы можем написать \In{5}, или \In{2+3}, это лишь два разных имени для одной константы. Теперь мы разобрались с тем, что константы это деревья. Значит функции строят одни деревья из других. Как они это делают? Для этого этого в Haskell есть две операции: это композиция и декомпозиция деревьев. С помощью <em>композиции</em> мы строим из простых деревьев сложные, а с помощью <em>декомпозиции</em> разбиваем составные деревья на простейшие.</p>
<p>Композиция и декомпозиция объединены в одной операции, с которой мы уже встречались, это операция определения синонима. Давайте вспомним какое-нибудь объявление функции:</p>

\begin{code}
(+) a  Zero      = a
(+) a  (Succ b)  = Succ (a + b)
\end{code}

<p>Смотрите в этой функции слева от знака равно мы проводим декомпозицию второго аргумента, а в правой части мы составляем новое дерево из тех значений, что были нами получены слева от знака равно. Или посмотрим на другой пример:</p>

\begin{code}
show (Time h m s) = show h ++ ":" ++ show m ++ ":" ++ show s
\end{code}

<p>Слева от знака равно мы также выделили из составного дерева \In{(Time h m s)} три его дочерних для корня узла и связали их с переменными \In{h}, \In{m} и \In{s}. А справа от знака равно мы составили из этих переменных новое выражение.</p>
<p>Итак операцию объявления синонима можно представить в таком виде:</p>

\begin{code}
name    декомпозиция    =  композиция 
\end{code}

<p>В каждом уравнении у нас три части: новое имя, декомпозиция, поступающих на вход аргументов, и композиция нового значения. Теперь давайте остановимся поподробнее на каждой из этих операций.</p>
<h3 id="композиция-и-частичное-применение">Композиция и частичное применение</h3>
<p>Композиция строится по очень простому правилу, если у нас есть значение \In{f} типа \In{a -> b} и значение \In{x} типа \In{a}, мы можем получить новое значение \In{(f x)} типа \In{b}. Это основное правило построения новых значений, поэтому давайте запишем его отдельно:</p>

\begin{code}
                    f :: a -> b,       x :: a
                    --------------------------
                            (f x) :: b
\end{code}

<p>Сверху от черты, то что у нас есть, а снизу от черты то, что мы можем получить. Это операция называется <em>применением</em> или аппликацией.</p>
<p>Выражения, полученные таким образом, напоминают строчную запись дерева, но есть одна тонкость, которую мы обошли стороной. В случае деревьев мы строили только константы, и конструктор получал столько аргументов, сколько у него было дочерних узлов (или подтипов). Так мы строили константы. Но в Haskell мы можем с помощью применения строить функции на лету, передавая меньшее число аргументов, этот процесс называется <em>частичным применением</em> или каррированием (currying). Поясним на примере, предположим у нас есть функция двух аргументов:</p>

\begin{code}
add :: Nat -> Nat -> Nat
add a b = ...
\end{code}

<p>На самом деле компилятор воспринимает эту запись так:</p>

\begin{code}
add :: Nat -> (Nat -> Nat)
add a b = ...
\end{code}

<p>Функция \In{add} является функцией одного аргумента, которая в свою очередь возвращает функцию одного аргумента \In{(Nat -> Nat)}. Когда мы пишем в где-нибудь в правой части функции:</p>

\begin{code}
... =  ... (add Zero (Succ Zero)) ...
\end{code}

<p>Компилятор воспринимает эту запись так:</p>

\begin{code}
... =  ... ((add Zero) (Succ Zero)) ...
\end{code}

<p>Присмотримся к этому выражению, что изменилось? У нас появились новые скобки, вокруг выражения \In{(add Zero)}. Давайте посмотрим как происходит применение:</p>

\begin{code}
              add :: Nat -> (Nat -> Nat),       Zero :: Nat
              ----------------------------------------------
                        (add Zero) :: Nat -> Nat
\end{code}

<p>Итак применение функции \In{add} к \In{Zero} возвращает новую функцию \In{(add Zero)}, которая зависит от одного аргумента. Теперь применим к этой функции второе значение:</p>

\begin{code}
              (add Zero) :: Nat -> Nat,   (Succ Zero) :: Nat
              ----------------------------------------------
                     ((add Zero) (Succ Zero)) :: Nat
\end{code}

<p>И только теперь мы получили константу. Обратите внимание на то, что получившаяся константа не может принять ещё один аргумент. Поскольку в правиле для применения функция \In{f} <em>должна содержать стрелку</em>, а у нас есть лишь \In{Nat}, это значение может участвовать в других выражениях лишь на месте аргумента.</p>
<p>Тоже самое работает и для функций от большего числа аргументов, если мы пишем</p>

\begin{code}
fun :: a1 -> a2 -> a3 -> a4 -> res

... = fun a b c d
\end{code}

<p>На самом деле мы пишем</p>

\begin{code}
fun :: a1 -> (a2 -> (a3 -> (a4 -> res)))

... = (((fun a) b) c) d
\end{code}

<p>Это очень удобно. Так, определив лишь одну функцию \In{fun}, мы получили в подарок ещё три функции \In{(fun a)}, \In{(fun a b)} и \In{(fun a b c)}. С ростом числа аргументов растёт и число подарков. Если смотреть на функцию \In{fun}, как на функцию одного аргумента, то она представляется таким генератором функций типа \In{a2 -> a3 -> a4 -> res}, который зависит от параметра. Применение функций через пробел значительно упрощает процесс комбинирования функций.</p>
<p>Поэтому в Haskell аргументы функций, которые играют роль параметров или специфических флагов, т.е.~аргументы, которые меняются редко обычно пишутся в начале функции. Например</p>

\begin{code}
process :: Param1 -> Param2 -> Arg1 -> Arg2 -> Result
\end{code}

<p>Два первых аргумента функции \In{process} выступают в роли параметров для генерации функций с типом \In{Arg1 -> Arg2 -> Result}.</p>
<p>Давайте потренируемся с частичным применением в интерпретаторе. Для этого загрузим модуль \In{Nat} из предыдущей главы:</p>

\begin{code}
Prelude> :l Nat
[1 of 1] Compiling Nat              ( Nat.hs, interpreted )
Ok, modules loaded: Nat.
*Nat> let add = (+) :: Nat -> Nat -> Nat
*Nat> let addTwo = add (Succ (Succ Zero))
*Nat> :t addTwo
addTwo :: Nat -> Nat
*Nat> addTwo (Succ Zero)
Succ (Succ (Succ Zero))
*Nat> addTwo (addTwo Zero)
Succ (Succ (Succ (Succ Zero)))
\end{code}

<p>Сначала мы ввели локальную переменную \In{add}, и присвоили ей метод \In{(+)} из класса \In{Num} для \In{Nat}. Нам пришлось выписать тип функции, поскольку \In{ghci} не знает для какого экземпляра мы хотим определить этот синоним. В данном случае мы подсказали ему, что это \In{Nat}. Затем с помощью частичного применения мы объявили новый синоним \In{addTwo}, как мы видим из следующей строки это функция оного аргумента. Она принимает любое значение типа \In{Nat} и прибавляет к нему двойку. Мы видим, что этой функцией можно пользоваться также как и обычной функцией.</p>
<p>Попробуем выполнить тоже самое для функции с символьной записью имени:</p>

\begin{code}
*Nat> let add2 = (+) (Succ (Succ Zero))
*Nat> add2 Zero
Succ (Succ Zero)
\end{code}

<p>Мы рассмотрели частичное применение для функций в префиксной форме записи. В префиксной форме записи функция пишется первой, затем следуют аргументы. Для функций в инфиксной форме записи существует два правила применения.</p>
<p>Это применение слева:</p>

\begin{code}
                    (*) :: a -> (b -> c),   x :: a
                    -----------------------------
                            (x *) :: b -> c
\end{code}

<p>И применение справа:</p>

\begin{code}
                    (*) :: a -> (b -> c),   x :: b
                    -----------------------------
                            (* x) :: a -> c
\end{code}

<p>Обратите внимание на типы аргумента и возвращаемого значения. Скобки в выражениях \In{(x*)} и \In{(*x)} обязательны. Применением слева мы фиксируем в бинарной операции первый аргумент, а применением справа – второй.</p>
<p>Поясним на примере, для этого давайте возьмём функцию минус \In{(-)}. Если мы напишем \In{(2-) 1} то мы получим \In{1}, а если мы напишем \In{(-2) 1}, то мы получим \In{-1}. Проверим в интерпретаторе:</p>

\begin{code}
*Nat> (2-) 1
1
*Nat> (-2) 1

<interactive>:4:2:
    No instance for (Num (a0 -> t0))
      arising from a use of syntactic negation
    Possible fix: add an instance declaration for (Num (a0 -> t0))
    In the expression: - 2
    In the expression: (- 2) 1
    In an equation for `it': it = (- 2) 1
\end{code}

<p>Ох уж этот минус. Незадача. Ошибка произошла из-за того, что минус является хамелеоном. Если мы пишем \In{-2}, компилятор воспринимает минус как унарную операцию, и думает, что мы написали константу минус два. Это сделано для удобства, но иногда это мешает. Это единственное такое исключение в Haskell. Давайте введём новый синоним для операции минус:</p>

\begin{code}
*Nat> let (#) = (-)
*Nat> (2#) 1
1
*Nat> (#2) 1
-1
\end{code}

<p>Эти правила левого и правого применения работают и для буквенных имён в инфиксной форме записи:</p>

\begin{code}
*Nat> let minus = (-)
*Nat> (2 `minus` ) 1
1
*Nat> ( `minus` 2) 1
-1
\end{code}

<p>Так если мы хотим на лету получить новую функцию, связав в функции второй аргумент мы можем написать:</p>

\begin{code}
... = ... ( `fun` x) ...
\end{code}

<p>Частичное применение для функций в инфиксной форме записи называют <em>сечением</em> (section), они бывают соответственно левыми и правыми.</p>
<h4 id="связь-с-логикой">Связь с логикой</h4>
<p>Отметим связь основного правила применения с Modus Ponens, известным правилом вывода в логике:</p>

\begin{code}
                    a -> b,    a
                    -------------
                          b
\end{code}

<p>Оно говорит о том, что если у нас есть выражение из \In{a} следует \In{b} и мы знаем, что \In{a} истинно, мы смело можем утверждать, что \In{b} тоже истинно. Если перевести это правило на Haskell, то мы получим: Если у нас определена функция типа \In{a -> b} и у нас есть значение типа \In{a}, то мы можем получить значение типа \In{b}.</p>
<h3 id="декомпозиция-и-сопоставление-с-образцом">Декомпозиция и сопоставление с образцом</h3>
<p>Декомпозиция применяется слева от знака равно, при этом наша задача состоит в том, чтобы опознать дерево определённого вида и выделить из него некоторые поддеревья. Мы уже пользовались декомпозицией много раз в предыдущих главах, давайте выпишем примеры декомпозиции:</p>

\begin{code}
not :: Bool -> Bool
not True   = ...
not False  = ...

xor :: Bool -> Bool -> Bool
xor a b = ...

show :: Show a => a -> String

show (Time h m s) = ...

addZero :: String -> String
addZero (a:[])  = ...
addZero as      = ...

(*)  a   Zero      = ...
(*)  a   (Succ b)  = ...
\end{code}

<p>Декомпозицию можно проводить в аргументах функции. Там мы видим строчную запись дерева, в узлах стоят конструкторы (начинаются с большой буквы), переменные (с маленькой буквы) или символ безразличной переменой (подчёркивание).</p>
<p>С помощью конструкторов, мы указываем те части, которые обязательно должны быть в дереве для данного уравнения. Так уравнение</p>

\begin{code}
not True   = ...
\end{code}


<p>сработает, только если на вход функции поступит значение \In{True}. Мы можем углубляться в дерево значения настолько, насколько нам позволят типы, так мы можем определить функцию:</p>

\begin{code}
is7 :: Nat -> Bool
is7  (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))  = True
is7  _                                                      = False
\end{code}

<p>С помощью переменных мы даём синонимы поддеревьям. Этими синонимами мы можем пользоваться в правой части функции. Так в уравнении</p>

\begin{code}
addZero (a:[])
\end{code}


<p>мы извлекаем первый элемент из списка, и одновременно говорим о том, что список может содержать только один элемент. Отметим, что если мы хотим дать синоним всему дереву а не какой-то части, мы просто пишем на месте аргумента переменную, как в случае функции \In{xor}:</p>

\begin{code}
xor a b = ...
\end{code}

<p>С помощью безразличной переменной говорим, что нам не важно, что находится у дерева в этом узле. Уравнения в определении синонима обходятся сверху вниз, поэтому часто безразличной переменной пользуются в смысле “а во всех остальных случаях”, как в:</p>

\begin{code}
instance Eq Nat where
    (==) Zero     Zero     = True
    (==) (Succ a) (Succ b) = a == b
    (==) _        _        = False
\end{code}

<p>Переменные и безразличные переменные также могут уходить вглубь дерева сколь угодно далеко (или ввысь дерева, поскольку первый уровень в строчной записи это корень):</p>

\begin{code}
lessThan7 :: Nat -> Bool
lessThan7  (Succ (Succ (Succ (Succ (Succ (Succ (Succ _)))))))  = False
lessThan7  _                                                   = True
\end{code}

<p>Декомпозицию можно применять только к значениям-константам. Проявляется интересная закономерность: если для композиции необходимым элементом было значение со стрелочным типом (функция), то в случае декомпозиции нам нужно значение с типом без стрелок (константа). Это говорит о том, что все функции будут полностью применены, т.е.~константы будут записаны в виде строчной записи дерева. Если мы ожидаем на входе функцию, то мы можем только дать ей синоним с помощью с помощью переменной или проигнорировать её безразличной переменной.</p>
<p>Как в</p>

\begin{code}
name  (Succ (Succ Zero))       = ...
name  (Zero : Succ Zero : [])  = ...
\end{code}

<p>Но не</p>

\begin{code}
name  Succ      = ...
name  (Zero :)  = ...
\end{code}

<p>Отметим, что для композиции это допустимые значения, в первом случае это функция \In{Nat -> Nat}, а во втором это функция типа \In{[Nat] -> [Nat]}.</p>
<p>Ещё одна особенность декомпозиции заключается в том, что при декомпозиции мы можем пользоваться только “настоящими” значениями, т.е.~конструкторами, объявленными в типах. В случае композиции мы могли пользоваться как конструкторами, так и синонимами.</p>
<p>Например мы не можем написать в декомпозиции:</p>

\begin{code}
name  (add Zero Zero)      = ...
name  (or (xor a b) True)  = ...
\end{code}

<p>В Haskell декомпозицию принято называть <em>сопоставлением с образцом</em> (pattern matching). Термин намекает на то, что в аргументе мы выписываем шаблон (или заготовку) для целого набора значений. Наборы значений могут получиться, если мы пользуемся переменными. Конструкторы дают нам возможность зафиксировать вид ожидаемого на вход дерева.</p>
<h2 id="проверка-типов">Проверка типов</h2>
<p>В этом разделе мы поговорим об ошибках проверки типов. Почти все ошибки, которые происходят в Haskell, связаны с проверкой типов. Проверка типов происходит согласно правилам применения, которые встретились нам в разделе о композиции значений. Мы остановимся лишь на случае для префиксной формы записи, правила для сечений работают аналогично. Давайте вспомним основное правило:</p>

\begin{code}
                    f :: a -> b,       x :: a
                    --------------------------
                            (f x) :: b
\end{code}

<p>Что может привести к ошибке? В этом правиле есть два источника ошибки.</p>
<ul>
<li><p>Тип \In{f} не содержит стрелок, или \In{f} не является функцией.</p></li>
<li><p>Типы \In{x} и аргумента для \In{f} не совпадают.</p></li>
</ul>
<p>Вот и все ошибки. Универсальное представление всех функций в виде функций одного аргумента, значительно сокращает число различных видов ошибок. Итак мы можем ошибиться применяя значение к константе и передав в функцию не то, что она ожидает.</p>
<p>Потренируемся в интерпретаторе, сначала попытаемся создать ошибку первого типа:</p>

\begin{code}
*Nat> Zero Zero

<interactive>:1:1:

    The function `Zero' is applied to one argument,
    but its type `Nat' has none
    In the expression: Zero Zero
    In an equation for `it': it = Zero Zero
\end{code}

<p>Если перевести на русский интерпретатор говорит:</p>

\begin{code}
*Nat> Zero Zero

<interactive>:1:1:
    Функция 'Zero' применяется к одному аргументу,
    но её тип 'Nat' не имеет аргументов
    В выражении: Zero Zero
    В уравнении для `it': it = Zero Zero
\end{code}

<p>Компилятор увидел применение функции \In{f x}, далее он посмотрел, что \In{x = Zero}, из этого на основе правила применения он сделал вывод о том, что \In{f} имеет тип \In{Nat -> t}, тогда он заглянул в \In{f} и нашёл там \In{Zero :: Nat}, что и привело к несовпадению типов.</p>
<p>Составим ещё одно выражение с такой же ошибкой:</p>

\begin{code}
*Nat> True Succ

<interactive>:6:1:
    The function `True' is applied to one argument,
    but its type `Bool' has none
    In the expression: True Succ
    In an equation for `it': it = True Succ
\end{code}

<p>В этом выражении аргумент \In{Succ} имеет тип \In{Nat -> Nat}, значит по правилу вывода тип \In{True} равен \In{(Nat -> Nat) -> t}, где \In{t} некоторый произвольный тип, но мы знаем, что \In{True} имеет тип \In{Bool}.</p>
<p>Теперь перейдём к ошибкам второго типа. Попробуем вызывать функции с неправильными аргументами:</p>

\begin{code}
*Nat> :m +Prelude
*Nat Prelude> not (Succ Zero)

<interactive>:9:6:
    Couldn't match expected type `Bool' with actual type `Nat'
    In the return type of a call of `Succ'
    In the first argument of `not', namely `(Succ Zero)'
    In the expression: not (Succ Zero)
\end{code}

<p>Опишем действия компилятора в терминах правила применения. В этом выражении у нас есть три значения: \In{not}, \In{Succ} и \In{Zero}. Нам нужно узнать тип выражения и проверить правильно ли оно построено.</p>

\begin{code}
not (Succ Zero) - ? 

     not :: Bool -> Bool,    Succ :: Nat -> Nat,    Zero :: Nat
     ----------------------------------------------------------
            f x, f = not и x = (Succ Zero)
    ------------------------------------------------------------
            f :: Bool -> Bool следовательно x :: Bool
    -------------------------------------------------------------
            (Succ Zero) :: Bool
\end{code}

<p>Воспользовавшись правилом применения мы узнали, что тип выражения \In{Succ Zero} должен быть равен \In{Bool}. Проверим, так ли это?</p>

\begin{code}
(Succ Zero) - ?
        Succ :: Nat -> Nat,     Zero :: Nat
     ----------------------------------------------------------
            f x, f = Succ, x = Zero следовательно (f x) :: Nat
     ----------------------------------------------------------
                        (Succ Zero) :: Nat
\end{code}

<p>Из этой цепочки следует, что \In{(Succ Zero)} имеет тип \In{Nat}. Мы пришли к противоречию и сообщаем об этом пользователю.</p>

\begin{code}
<interactive>:1:5:
    Не могу сопоставить ожидаемый тип 'Bool' с выведенным 'Nat'
    В типе результата вызова `Succ'
	В первом аргументе `not', а именно `(Succ Zero)'
    В выражении: not (Succ Zero)	
\end{code}

<p>Потренируйтесь в составлении неправильных выражений и посмотрите почему они не правильные. Мысленно сверьтесь с правилом применения в каждом из слагаемых.</p>
<h4 id="специализация-типов-при-подстановке">Специализация типов при подстановке</h4>
<p>Мы говорили о том, что тип аргумента функции и тип подставляемого значения должны совпадать, но на самом деле есть и другая возможность. Тип аргумента или тип значения могут быть полиморфными. В этом случае происходит специализация общего типа. Например, при выполнении выражения:</p>

\begin{code}
*Nat> Succ Zero + Zero
Succ (Succ Zero)
\end{code}

<p>Происходит специализация общей функции \In{(+) :: Num a => a -> a -> a} до функции \In{(+) :: Nat -> Nat -> Nat}, которая определена в экземпляре \In{Num} для \In{Nat}.</p>
<h3 id="проверка-типов-с-контекстом">Проверка типов с контекстом</h3>
<p>Предположим, что у функции \In{f} есть контекст, который говорит о том, что первый аргумент принадлежит некоторому классу \In{f :: C a => a -> b}, тогда значение, которое мы подставляем в функцию, должно быть экземпляром класса \In{C}.</p>
<p>Для иллюстрации давайте попробуем сложить логические значения:</p>

\begin{code}
*Nat Prelude> True + False

<interactive>:11:6:
    No instance for (Num Bool)
      arising from a use of `+'
    Possible fix: add an instance declaration for (Num Bool)
    In the expression: True + False
    In an equation for `it': it = True + False
\end{code}

<p>Компилятор говорит о том, что для типа \In{Bool} не<br />определён экземпляр для класса \In{Num}.</p>

\begin{code}
No instance for (Num Bool) 
\end{code}

<p>Запишем это в виде правила:</p>

\begin{code}
                    f :: C a => a -> b,  x :: T, instance C T 
                    -----------------------------------------
                                (f x) :: b
\end{code}

<p>Важно отметить, что \In{x} имеет конкретный тип \In{T}. Если \In{x} – значение, у которого тип с параметром, компилятор не сможет определить для какого типа конкретно мы хотим выполнить применение. Мы будем называть такую ситуацию неопределённостью:</p>

\begin{code}
x :: T a => a
f :: C a => a -> b

f x :: ??  -- неопределённость
\end{code}

<p>Мы видим, что тип \In{x}, это какой-то тип, одновременно принадлежащий и классу \In{T} и классу \In{C}. Но мы не можем сказать какой это тип. У этого поведения есть исключение: по умолчанию числа приводятся к \In{Integer}, если они не содержат знаков после точки, и к \In{Double} – если содержат.</p>

\begin{code}
*Nat Prelude> let f = (1.5 + )
*Nat Prelude> :t f
f :: Double -> Double
*Nat Prelude> let x = 5 + 0
*Nat Prelude> :t x
x :: Integer
*Nat Prelude> let x = 5 + Zero
*Nat Prelude> :t x
x :: Nat
\end{code}

<p>Умолчания определены только для класса \In{Num}. Для этого есть специальное ключевое слово \In{default}. В рамках модуля мы можем указать какие типы считаются числами по умолчанию. Например, так (такое умолчание действует в каждом модуле, но мы можем переопределить его):</p>

\begin{code}
default (Integer, Double)
\end{code}

<p>Работает правило: если произошла неопределённость и один из участвующих классов является \In{Num}, а все остальные классы – это стандартные классы, определённые в \In{Prelude}, то компилятор начинает последовательно пробовать все типы, перечисленые за ключевым словом \In{default}, пока один из них не подойдёт. Если такого типа не окажется, компилятор скажет об ошибке.</p>
<h3 id="ограничение-мономорфизма">Ограничение мономорфизма</h3>
<p>С выводом типов в классах связана одна тонкость. Мы говорили, что не обязательно выписывать типы выражений, компилятор может вывести их самостоятельно. Например, мы постоянно пользуемся этим в интерпретаторе. Также когда мы говорили о частичном применении, мы сказали об очень полезном умолчании в типах функций. О том, что за счёт частичного применения, все функции являются функциями одного аргумента. Эта особенность позволяет записывать выражения очень кратко. Но иногда они получаются чересчур краткими, и вводят компилятор в заблуждение. Зайдём в интерпретатор:</p>

\begin{code}
Prelude> let add = (+)
Prelude> :t add
add :: Integer -> Integer -> Integer
\end{code}

<p>Мы хотели определить синоним для метода плюс из класса \In{Num}, но вместо ожидаемого общего типа получили более частный. Сработало умолчание для численного типа. Но зачем оно сработало? Если мы попробуем дать синоним методу из класса \In{Eq}, ситуация станет ещё более странной:</p>

\begin{code}
Prelude> let eq = (==)
Prelude> :t eq
eq :: () -> () -> Bool
\end{code}

<p>Мы получили какую-то ерунду. Если мы попытаемся загрузить модуль с этими определениями:</p>

\begin{code}
module MR where

add = (+)
eq  = (==)
\end{code}


<p>то получим:</p>

\begin{code}
*MR> :l MR
[1 of 1] Compiling MR               ( MR.hs, interpreted )

MR.hs:4:7:
    Ambiguous type variable `a0' in the constraint:
      (Eq a0) arising from a use of `=='
    Possible cause: the monomorphism restriction applied to the following:
      eq :: a0 -> a0 -> Bool (bound at MR.hs:4:1)
    Probable fix: give these definition(s) an explicit type signature
                  or use -XNoMonomorphismRestriction
    In the expression: (==)
    In an equation for `eq': eq = (==)
Failed, modules loaded: none.
\end{code}

<p>Компилятор жалуется о том, что в определении для \In{eq} ему встретилась неопределённость и он не смог вывести тип. Если же мы допишем недостающие типы:</p>

\begin{code}
module MR where

add :: Num a => a -> a -> a
add = (+)

eq :: Eq a => a -> a -> Bool
eq  = (==)
\end{code}

<p>то всё пройдёт гладко:</p>

\begin{code}
Prelude> :l MR
[1 of 1] Compiling MR               ( MR.hs, interpreted )
Ok, modules loaded: MR.
*MR> eq 2 3
False
\end{code}

<p>Но оказывается, что если мы допишем аргументы у функций и сотрём объявления, компилятор сможет вывести тип, и тип окажется общим. Это можно проверить в интерпретаторе. Для этого начнём новую сессию:</p>

\begin{code}
Prelude> let eq a b = (==) a b 
Prelude> :t eq
eq :: Eq a => a -> a -> Bool
Prelude> let add a = (+) a
Prelude> :t add
add :: Num a => a -> a -> a
\end{code}

<p>Запишите эти выражения в модуле без типов и попробуйте загрузить. Почему так происходит? По смыслу определения</p>

\begin{code}
add a b = (+) a b
add     = (+)
\end{code}


<p>ничем не отличаются друг от друга, но второе сбивает компилятор столку. Компилятор путается из-за того, что второй вариант похож на определение константы. Мы с вами знаем, что выражение справа от знака равно является функцией, но компилятор, посчитав аргументы слева от знака равно, думает, что это возможно константа, потому что она выглядит как константа. У таких возможно-констант есть специальное имя, они называются константными аппликативными формами (constant applicative form или сокращённо CAF). Константы можно вычислять один раз, на то они и константы. Но если тип константы перегружен, и мы не знаем что это за тип (если пользователь не подсказал нам об этом в объявлении типа), то нам приходится вычислять его каждый раз заново. Посмотрим на пример:</p>

\begin{code}
res = s + s

s = someLongLongComputation 10

someLongLongComputation :: Num a => a -> a
\end{code}

<p>Здесь значение \In{s} содержит результат вычисления какой-то большой-пребольшой функции. Перед компилятором стоит задача вывода типов. По тексту можно определить, что у \In{s} и \In{res} некоторый числовой тип. Проблема в том, что поскольку компилятор не знает какой тип у \In{s} конкретно в выражении \In{s + s}, он вынужден вычислить \In{s} дважды. Это привело разработчиков Haskell к мысли о том, что все выражения, которые выглядят как константы должны вычисляться как константы, то есть лишь один раз. Это ограничение называют ограничением <em>мономорфизма</em>. По умолчанию все константы должны иметь конкретный тип, если только пользователь не укажет обратное в типе или не подскажет компилятору косвенно, подставив неопределённое значение в другое значение, тип которого определён. Например, такой модуль загрузится без ошибок:</p>

\begin{code}
eqToOne = eq one

eq = (==)

one :: Int
one = 1
\end{code}

<p>Только в этом случае мы не получим общего типа для \In{eq}: компилятор постарается вывести значение, которое не содержит контекста. Поэтому получится, что функция \In{eq} определена на \In{Int}. Эта очень спорная особенность языка, поскольку на практике получается так, что ситуации, в которых она мешает, возникают гораздо чаще. Немного забегая вперёд, отметим, что это поведение компилятора по умолчанию, и его можно изменить. Компилятор даже подсказал нам как это сделать в сообщении об ошибке:</p>

\begin{code}
Probable fix: give these definition(s) an explicit type signature
         or use -XNoMonomorphismRestriction
\end{code}

<p>Мы можем активировать расширение языка, которое отменяет это ограничение. Сделать это можно несколькими способами. Мы можем запустить интерпретатор с флагом \In{-XNoMonomorphismRestriction}:</p>

\begin{code}
Prelude> :q
Leaving GHCi.
$ ghci -XNoMonomorphismRestriction
Prelude> let eq = (==)
Prelude> :t eq
eq :: Eq a => a -> a -> Bool
\end{code}


<p>или в самом начале модуля написать:</p>

\begin{code}
{-# Language NoMonomorphismRestriction #-}
\end{code}

<p>Расширение будет действовать только в рамках данного модуля.</p>
<h2 id="рекурсивные-типы">Рекурсивные типы</h2>
<p>Обсудим ещё одну особенность системы типов Haskell. Типы могут быть рекурсивными, то есть одним из подтипов в определении типа может быть сам определяемый тип. Мы уже пользовались этим в определении для \In{Nat}</p>

\begin{code}
data Nat = Zero | Succ Nat
\end{code}

<p>Видите, во второй альтернативе участвует сам тип \In{Nat}. Это приводит к бесконечному числу значений. Таким простым и коротким определением мы описываем все положительные числа. Рекурсивные определения типов приводят к рекурсивным функциям. Помните, мы определяли сложение и умножение:</p>

\begin{code}
(+) a Zero     = a
(+) a (Succ b) = Succ (a + b)

(*) a Zero     = Zero
(*) a (Succ b) = a + (a * b)   
\end{code}

<p>И та и другая функция получились рекурсивными. Они следуют по одному сценарию: сначала определяем базу рекурсии~– тот случай, в котором мы заканчиваем вычисление функции, и затем определяем путь к базе~– цепочку рекурсивных вызовов.</p>
<p>Рассмотрим тип по-сложнее. Списки:</p>

\begin{code}
data [a] = [] | a : [a]
\end{code}

<p>Деревья значений для \In{Nat} напоминают цепочку конструкторов \In{Succ}, которая венчается конструктором \In{Zero}. Дерево значений для списка отличается лишь тем, что теперь у каждого конструктора \In{Succ} есть отросток, который содержит значение неокоторого типа \In{a}. Значение заканчивается пустым списком \In{[]}.</p>
<p>Мы можем предположить, что функции для списков также будут рекурсивными. Это и правда так. Помотрим на три основные функции для списков. Все они определены в \In{Prelude}. Начнём с функции преобразования всех элементов списка:</p>

\begin{code}
map :: (a -> b) -> [a] -> [b]
\end{code}

<p>Посмотрим как она работает:</p>

\begin{code}
Prelude> map (+100) [1,2,3]
[101,102,103]
Prelude> map not [True, True, False, False, False]
[False,False,True,True,True]
Prelude> :m +Data.Char
Prelude Data.Char> map toUpper "Hello World"
"HELLO WORLD"
\end{code}

<p>Теперь опишем эту функцию. Базой рекурсии будет случай для пустого списка. В нём мы говорим, что если элементы закончились, нам нечего больше преобразовывать, и возвращаем пустой список. Во втором уравнении нам встретится узел дерева, который содержит конструктор \In{:}, а в дочерних узлах сидят элемент списка \In{a} и оставшаяся часть списка \In{as}. В этом случае мы составляем новый список, элемент которого содержит преобразованный элемент \In{(f a)} исходного списка и оставшуюся часть списка, которую мы также преобразуем с помощью функции \In{map}:</p>

\begin{code}
map :: (a -> b) -> [a] -> [b]
map f []     = []
map f (a:as) = f a : map f as
\end{code}

<p>Какое длинное объяснение для такой короткой функции! Надеюсь, что мне не удалось сбить вас с толку. Обратите внимание на то, что поскольку конструктор символьный (начинается с двоеточия) мы пишем его между дочерними поддеревьями, а не сначала. Немного отвлекитесь и поэкспериментируйте с этой функцией в интерпретаторе, она очень важная. Составляйте самые разные списки. Чтобы не перенабирать каждый раз списки водите синонимы с помощью \In{let}.</p>
<p>Перейдём к следующей функции. Это функция фильтрации:</p>

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
\end{code}

<p>Она принимает предикат и список, угдайте что она делает:</p>

\begin{code}
Prelude Data.Char> filter isUpper "Hello World"
"HW"
Prelude Data.Char> filter even [1,2,3,4,5]
[2,4]
Prelude Data.Char> filter (>10) [1,2,3,4,5]
[]
\end{code}

<p>Да, она оставляет лишь те элементы, на которых предикат вернёт истину. Потренируйтесь и с этой функцией.</p>
<p>Теперь определение:</p>

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter p []     = []
filter p (x:xs) = if p x then x : filter p xs else filter p xs
\end{code}

<p>Попробуйте разобраться с ним самостоятельно, по аналогии с \In{map}. Оно может показаться немного громоздким, но это ничего, совсем скоро мы узнаем как записать его гораздо проще.</p>
<p>Рассмотрим ещё одну функцию для списков, она называется функцией свёртки:</p>

\begin{code}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z []     = z
foldr f z (a:as) = f a (foldr f z as)
\end{code}

<p>Визуально её действие можно представить как замену всех конструкторов в дереве значения на подходящие по типу функции. В этой маленькой функции кроется невероятная сила. Посмотрим на несколько примеров:</p>

\begin{code}
Prelude Data.Char> :m -Data.Char
Prelude> let xs = [1,2,3,4,5]
Prelude> foldr (:) [] xs
[1,2,3,4,5]
\end{code}

<p>Мы заменили конструкторы на самих себя и получили исходный список, теперь давайте сделаем что-нибудь более конструктивное. Например вычислим сумму всех элементов или произведение:</p>

\begin{code}
Prelude> foldr (+) 0 xs
15
Prelude> foldr (*) 1 xs
120
Prelude> foldr max (head xs) xs
5
\end{code}

<h2 id="краткое-содержание">Краткое содержание</h2>
<p>В этой главе мы присмотрелись к типам и узнали как ограничения, общие для всех типов, сказываются на структуре значений. Мы узнали, что константы в Haskell очень похожи на деревья, а запись констант – на строчную запись дерева. Также мы присмотрелись к функциям и узнали, что операция определения синонима состоит из композиции и декомпозиции значений.</p>

\begin{code}
name   декомпозиция   =   композиция
\end{code}

<p>Существует несколько правил для построения композиций:</p>
<ul>
<li><p>Одно для функций в префиксной форме записи:</p>

\begin{code}
                    f :: a -> b,           x :: a 
                    -------------------------------
                              (f x) :: b
\end{code}
</li>
<li><p>И два для функций в инфиксной форме записи:</p>
<p>Это левое сечение:</p>

\begin{code}
                    (*) :: a -> (b -> c),     x :: a 
                    ---------------------------------
                             (x *) :: b -> c
\end{code}

<p>И правое сечение:</p>

\begin{code}
                    (*) :: a -> (b -> c),     x :: b 
                    ---------------------------------
                                (* x) :: a -> c
\end{code}
</li>
</ul>
<p>Декомпозиция происходит в аргументах функции. С её помощью мы можем извлечь из составной константы-дерева какую-нибудь часть или указать на какие константы мы реагируем в данном уравнении.</p>
<p>Ещё мы узнали о <em>частичном применении</em>. О том, что все функции в Haskell являются функциями одного аргумента, которые возвращают константы или другие функции одного аргумента.</p>
<p>Мы потренировались в составлении неправильных выражений и посмотрели как компилятор на основе правил применения узнаёт что они неправильные. Мы узнали, что такое ограничение мономорфизма и как оно появляется. Также мы присмотрелись к рекурсивным функциям.</p>
<p></p>
<h2 id="упражнения">Упражнения</h2>
<ul>
<li><p>Составьте в интерпретаторе как можно больше неправильных выражений и посмотрите на сообщения об ошибках. Разберитесь почему выражение оказалось неправильным. Для этого проверьте типы с помощью правил применения. Составьте несколько выражений, ведущих к ошибке из-за ограничения мономорфизма.</p></li>
<li><p>Потренируйтесь в интерпретаторе с функциями \In{map}, \In{filter} и \In{foldr}. Попробуйте их с самыми разными функциями. Воспользуйтесь и теми функциями, что были определены в прошлой главе в тексте или в упражнениях.</p></li>
<li><p>В этой главе было много картинок и графических аналогий, попробуйте попрограммировать в картинках. Нарисуйте определённые нами функции или какие-нибудь новые в виде деревьев. Например, это можно сделать так. Мы будем отличать конструкторы от синонимов. Конструкторы будем рисовать в одинарном кружке, а синонимы в двойном.</p>
<p></p>
<p>Мы будем все функции писать также как и прежде, но вместо аргументов слева от знака равно и выражений справа от знака равно, будем рисовать деревья.</p>
<p>Например, объявим простой синоним-константу (). Мы будем дорисовывать сверху типы значений вместо объявления типа функции.</p>
<p>Несколько функций для списков. Извлечение первого элемента () и функция преобразования всех элементов списка (). Попробуйте в таком же духе определить несколько функций.</p></li>
</ul>
<p></p>
<p></p>
</body>
</html>
