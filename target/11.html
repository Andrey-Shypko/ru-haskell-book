<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<h1 id="ленивые-чудеса">Ленивые чудеса</h1>
<p>В прошлой главе мы узнали, что такое ленивые вычисления. В этой главе мы посмотрим чем они хороши. С ними можно делать невозможные вещи. Обращаться к ещё не вычисленным значениям, работать с бесконечными данными.</p>
<p>Мы пишем программу, чтобы решить какую-нибудь сложную задачу. Часто так бывает, что сложная задача оказывается сложной до тех пор пока её не удаётся разбить на отдельные независимые подзадачи. Мы решаем задачи по-меньше, потом собираем из них решения, из этих решений собираем другие решения и вот уже готова программа. Но мы решаем задачу не на листочке, нам необходимо объяснить её компьютеру. И тот язык, на котором мы пишем программу, оказывает сильное влияние на то как мы будем решать задачу. Мы не можем разбить программу на независимые подзадачи, если в том языке на котором мы собираемся объяснять задачу компьютеру нет средств для того, чтобы собрать эти решения вместе.</p>
<p>Об этом говорит <em>Джон Хьюз</em> (John Huges) в статье “Why functional programming matters”. Он приводит такую метафору. Если мы делаем стул и у нас нет хорошего клея. Единственное что нам остаётся это вырезать из дерева стул целиком. Это невероятно трудная задача. Гораздо проще сделать отдельные части и потом собрать вместе. Функциональные языки программирования предоставляют два новых вида “клея”. Это функции высшего порядка и ленивые вычисления. В статье можно найти много примеров. Некоторые из них мы рассмотрим в этой главе.</p>
<p>С функциями высших порядков мы уже знакомы, они позволяют склеивать небольшие решения. С их помощью мы можем параметризовать функцию другой функцией (поведением). Они дают нам возможность выделять сложные закономерности и собирать их в функции. Ленивые вычисления же предназначены для склеивания больших программ. Они синхронизируют выполнение подзадач, избавляя нас от необходимости выполнять это вручную.</p>
<p>Эта идея разбиения программы на независимые части приводит нас к понятию модульности. Когда мы решаем задачу мы пытаемся разложить её на простейшие составляющие. При этом часто оказывается, что эти составляющие применимы не только для нашей задачи, но и для многих других. Мы получаем целый букет решений, там где искали одно.</p>
<h2 id="численные-методы">Численные методы</h2>
<p>Рассмотрим несколько численных методов. Все эти методы построены на понятии сходимости. У нас есть последовательность решений и она сходится к одному решению, но мы не знаем когда. Мы только знаем, что промежуточные решения будут всё ближе и ближе к итоговому.</p>
<p>Поскольку у нас ленивый язык мы сначала построим все возможные решения, а затем выберем итоговое. Так же как мы делали это в прошлой главе, когда искали корни уравнения методом неподвижной точки. Эти примеры взяты из статьи “Why functional programming matters” Джона Хьюза.</p>
<h3 id="дифференцирование">Дифференцирование</h3>
<p>Найдём производную функции в точке. Посмотрим на математическое определение производной:</p>
<p><br /><span class="math">$f^\prime(x)\ =\lim_{h\to0}\frac{f(x+h)-f(x)}{h}$</span><br /></p>
<p>Производная это предел последовательности таких отношений, при <span class="math"><em>h</em></span> стремящемся к нулю. Если предел сходится, то производная определена. Для того чтобы решить эту задачу мы начнём с небольшого значения <span class="math"><em>h</em></span> и будем постепенно уменьшать его, вычисляя промежуточные значения производной. Как только они перестанут сильно изменяться мы будем считать, что мы нашли предел последовательности</p>
<p>Этот процесс напоминает то, что мы делали при поиске корня уравнения методом неподвижной точки. Мы можем взять из того решения функцию определения сходимости последовательности:</p>

\begin{code}
converge :: (Ord a, Num a) => a -> [a] -> a
converge eps (a:b:xs) 
    | abs (a - b) <= eps    = a
    | otherwise             = converge eps (b:xs)
\end{code}

<p>Теперь осталось только создать последовательность значений производных. Напишем функцию, которая вычисляет промежуточные решения:</p>

\begin{code}
easydiff :: Fractional a => (a -> a) -> a -> a -> a
easydiff f x h = (f (x + h) - f x) / h
\end{code}

<p>Мы возьмём начальное значение шага и будем последовательно уменьшать его вдвое:</p>

\begin{code}
halves = iterate (/2) 
\end{code}

<p>Соберём все части вместе:</p>

\begin{code}
diff :: (Ord a, Fractional a) => a -> a -> (a -> a) -> a -> a
diff h0 eps f x = converge eps $ map (easydiff f x) $ iterate (/2) h0
    where easydiff f x h = (f (x + h) - f x) / h
\end{code}

<p>Сохраним эти определения в отдельном модуле и найдём производную какой-нибудь функции. Протестируем решение на экспоненте. Известно, что производная экспоненты равна самой себе:</p>

\begin{code}
*Numeric> let exp' = diff 1 1e-5 exp
*Numeric> let test x = abs $ exp x - exp' x
*Numeric> test 2
1.4093421286887065e-5
*Numeric> test 5
1.767240203776055e-5
\end{code}

<h3 id="интегрирование">Интегрирование</h3>
<p>Теперь давайте поинтегрируем функции одного аргумента. Интеграл это площадь кривой под графиком функции. Если бы кривая была прямой, то мы могли бы вычислить интеграл по формуле трапеций:</p>

\begin{code}
easyintegrate :: Fractional a => (a -> a) -> a -> a -> a
easyintegrate f a b = (f a + f b) * (b - a) / 2
\end{code}

<p>Но мы хотим интегрировать не только прямые линии. Мы представим, что функция является ломаной прямой линией. Мы посчитаем интеграл на каждом из участков и сложим ответы. При этом чем ближе точки друг к другу, тем точнее можно представить функцию в виде ломаной прямой линии, тем точнее будет значение интеграла.</p>
<p>Проблема в том, что мы не знаем заранее насколько близки должны быть точки друг к другу. Это зависит от функции, которую мы хотим проинтегрировать. Но мы можем построить последовательность решений. На каждом шаге мы будем приближать функцию ломаной прямой, и на каждом шаге число изломов будет расти вдвое. Как только решение перестанет меняться мы вернём ответ.</p>
<p>Построим последовательность решений:</p>

\begin{code}
integrate :: Fractional a => (a -> a) -> a -> a -> [a]
integrate f a b = easyintegrate f a b : 
    zipWith (+) (integrate a mid) (integrate mid b)
    where mid = (a + b)/2
\end{code}

<p>Первое решение является площадью под прямой, которая соединяет концы отрезка. Потом мы делим отрезок пополам, строим последовательность приближений и складываем частичные суммы с помощью функции \In{zipWith}.</p>
<p>Эта версия функции хоть и наглядная, но не эффективная. Функция \In{f} вычисляется заново при каждом рекурсивном вызове. Было бы хорошо вычислять её только для новых значений. Для этого мы будем передавать значения с предыдущего шага:</p>

\begin{code}
integrate :: Fractional a => (a -> a) -> a -> a -> [a]
integrate f a b = integ f a b (f a) (f b)
    where integ f a b fa fb = (fa+fb)*(b-a)/2 :
                zipWith (+) (integ f a m fa fm) 
                            (integ f m b fm fb)
                where m  = (a + b)/2
                      fm = f m 
\end{code}

<p>В этой версии мы вычисляем значения в функции \In{f} лишь один раз для каждой точки. Запишем итоговое решение:</p>

\begin{code}
int :: (Ord a, Fractional a) => a -> (a -> a) -> a -> a -> a
int eps f a b = converge eps $ integrate f a b
\end{code}

<p>Мы опять воспользовались функцией \In{converge}, нам не нужно было её переписывать. Проверим решение. Для проверки также воспользуемся экспонентой. В прошлой главе мы узнали, что</p>
<p><br /><span class="math"><em>e</em><sup><em>x</em></sup> = 1 + ∫ <sub>0</sub><sup><em>x</em></sup><em>e</em><sup><em>t</em></sup><em>d</em><em>t</em></span><br /></p>
<p>Посмотрим, так ли это для нашего алгоритма:</p>

\begin{code}
*Numeric> let exp' = int 1e-5 exp 0
*Numeric> let test x = abs $ exp x - 1 -  exp' x 
*Numeric> test 2
8.124102876649886e-6
*Numeric> test 5
4.576306736225888e-6
*Numeric> test 10
1.0683757864171639e-5
\end{code}

<p>Алгоритм работает. В статье ещё рассмотрены методы повышения точности этих алгоритмов. Что интересно для улучшения точности не надо менять существующий код. Функция принимает последовательность промежуточных решений и преобразует её.</p>
<h2 id="степенные-ряды">Степенные ряды</h2>
<p>Напишем модуль для вычисления степенных рядов. Этот пример взят из статьи Дугласа МакИлроя (Douglas McIlroy) “Power Series, Power Serious”. Степенной ряд представляет собой функцию, которая определяется списком коэффициентов:</p>
<p><br /><span class="math"><em>F</em>(<em>x</em>) = <em>f</em><sub>0</sub> + <em>f</em><sub>1</sub><em>x</em> + <em>f</em><sub>2</sub><em>x</em><sup>2</sup> + <em>f</em><sub>3</sub><em>x</em><sup>3</sup> + <em>f</em><sub>4</sub><em>x</em><sup>4</sup> + . . . </span><br /></p>
<p>Степенной ряд содержит бесконечное число слагаемых. Для вычисления нам потребуются функции сложения и умножения. Ряд <span class="math"><em>F</em>(<em>x</em>)</span> можно записать и по-другому:</p>
<p><br /><span class="math">$\begin{array}{l@{\ =\ }l}
F(x) &amp; F_0 (x) \\
     &amp; f_0 + x F_1 (x)  \\
     &amp; f_0 + x (f_1 + x F_2 (x)) \\   
\end{array}$</span><br /></p>
<p>Это определение очень похоже на определение списка. Ряд есть коэффициент <span class="math"><em>f</em><sub>0</sub></span> и другой ряд <span class="math"><em>F</em><sub>1</sub>(<em>x</em>)</span> умноженный на \In{x}. Поэтому для представления рядов мы выберем конструкцию похожую на список:</p>

\begin{code}
data Ps a = a :+: Ps a
    deriving (Show, Eq)
\end{code}

<p>Но в нашем случае списки бесконечны, поэтому у нас лишь один конструктор. Далее мы будем писать просто <span class="math"><em>f</em> + <em>x</em><em>F</em><sub>1</sub></span>, без скобок для аргумента.</p>
<p>Определим вспомогательные функции для создания рядов:</p>

\begin{code}
p0 :: Num a => a -> Ps a
p0 x = x :+: p0 0

ps :: Num a => [a] -> Ps a
ps []     = p0 0
ps (a:as) = a :+: ps as
\end{code}

<p>Обратите внимание на то, как мы дописываем бесконечный хвост нулей в конец ряда. Теперь давайте определим функцию вычисления ряда. Мы будем вычислять лишь конечное число степеней.</p>

\begin{code}
eval :: Num a => Int -> Ps a -> a -> a
eval 0 _         _ = 0
eval n (a :+: p) x = a + x * eval (n-1) p x
\end{code}

<p>В первом случае мы хотим вычислить ноль степеней ряда, поэтому мы возвращаем ноль, а во втором случае значение ряда <span class="math"><em>a</em> + <em>x</em><em>P</em></span> складывается из числа <span class="math"><em>a</em></span> и значения ряда <span class="math"><em>P</em></span> умноженного на заданное значение.</p>
<h3 id="арифметика-рядов">Арифметика рядов</h3>
<p>В результате сложения и умножения рядов также получается ряд. Также мы можем создать ряд из числа. Эти операции говорят о том, что мы можем сделать степенной ряд экземпляром класса \In{Num}.</p>
<h4 id="сложение">Сложение</h4>
<p>Рекурсивное представление ряда <span class="math"><em>f</em> + <em>x</em><em>F</em></span> позволяет нам очень кратко выражать операции, которые мы хотим определить. Теперь у нас нет бесконечного набора коэффициентов, у нас всего лишь одно число и ещё один ряд. Операции существенно упрощаются. Так сложение двух бесконечных рядов имеет вид:</p>
<p><br /><span class="math"><em>F</em> + <em>G</em> = (<em>f</em> + <em>x</em><em>F</em><sub>1</sub>) + (<em>g</em> + <em>x</em><em>G</em><sub>1</sub>) = (<em>f</em> + <em>g</em>) + <em>x</em>(<em>F</em><sub>1</sub> + <em>G</em><sub>1</sub>)</span><br /></p>
<p>Переведём на Haskell:</p>

\begin{code}
(f :+: fs) + (g :+: gs) = (f + g) :+: (fs + gs)
\end{code}

<h4 id="умножение">Умножение</h4>
<p>Умножим два ряда:</p>
<p><br /><span class="math"><em>F</em> * <em>G</em> = (<em>f</em> + <em>x</em><em>F</em><sub>1</sub>) * (<em>g</em> + <em>x</em><em>G</em><sub>1</sub>) = <em>f</em><em>g</em> + <em>x</em>(<em>f</em><em>G</em><sub>1</sub> + <em>F</em><sub>1</sub> * <em>G</em>)</span><br /></p>
<p>Переведём:</p>

\begin{code}
(.*) :: Num a => a -> Ps a -> Ps a
k .* (f :+: fs) = (k * f) :+: (k .* fs)  

(f :+: fs) * (g :+: gs) = (f * g) :+: (f .* gs + fs * (g :+: gs))
\end{code}

<p>Дополнительная операция \In{(.*)} выполняет умножение всех коэффициентов ряда на число.</p>
<h4 id="класс-num">Класс Num</h4>
<p>Соберём определения для методов класса \In{Num} вместе:</p>

\begin{code}
instance Num a => Num (Ps a) where
    (f :+: fs) + (g :+: gs) = (f + g) :+: (fs + gs)
    (f :+: fs) * (g :+: gs) = (f * g) :+: (f .* gs + fs * (g :+: gs))
    negate (f :+: fs) = negate f :+: negate fs
    fromInteger n = p0 (fromInteger n)


(.*) :: Num a => a -> Ps a -> Ps a
k .* (f :+: fs) = (k * f) :+: (k .* fs)  
\end{code}

<p>Методы \In{abs} и \In{signum} не определены для рядов. Обратите внимание на то, как рекурсивное определение рядов приводит к рекурсивным определениям функций для рядов. Этот приём очень характерен для Haskell. Поскольку наш ряд это число и ещё один ряд за счёт рекурсии мы можем воспользоваться операцией, которую мы определяем, на “хвостовом” ряде.</p>
<h4 id="деление">Деление</h4>
<p>Результат деления <span class="math"><em>Q</em></span> удовлетворяет соотношению:</p>
<p><br /><span class="math"><em>F</em> = <em>Q</em> * <em>G</em></span><br /></p>
<p>Переписав <span class="math"><em>F</em></span>, <span class="math"><em>G</em></span> и <span class="math"><em>Q</em></span> в нашем представлении, получим</p>
<p><br /><span class="math">$\begin{array}{l@{\ = \ }l}
f + x F_1 &amp;  (q + x Q_1) * G = qG + x Q_1 * G = q(g + x G_1) + x Q_1 * G \\
          &amp; q g + x (q G_1 + Q_1 * G) \\
\end{array}$</span><br /></p>
<p>Следовательно</p>
<p><br /><span class="math">$\begin{array}{l@{\ = \ }l}
q    &amp;  f/g  \\
Q_1  &amp;  (F_1 - q G_1)/G \\
\end{array}$</span><br /></p>
<p>Если <span class="math"><em>g</em> = 0</span> деление имеет смысл только в том случае, если и <span class="math"><em>f</em> = 0</span>. Переведём на Haskell:</p>

\begin{code}
class Fractional a => Fractional (Ps a) where
    (0 :+: fs) / (0 :+: gs) = fs / gs
    (f :+: fs) / (g :+: gs) = q :+: ((fs - q .* gs)/(g :+: gs))
        where q = f/g

    fromRational x = p0 (fromRational x)
\end{code}

<h3 id="производная-и-интеграл">Производная и интеграл</h3>
<p>Производная одного члена ряда вычисляется так:</p>
<p><br /><span class="math">$\frac{d}{dx} x^n = n x^{n-1}$</span><br /></p>
<p>Из этого выражения по свойствам производной</p>
<p><br /><span class="math">$\frac{d}{dx}(f(x) + g(x)) =  \frac{d}{dx}f(x) +  \frac{d}{dx}g(x)$</span><br /></p>
<p><br /><span class="math">$\frac{d}{dx} (k * f(x)) = k *  \frac{d}{dx} f(x)$</span><br /></p>
<p>мы можем получить формулу для всего ряда:</p>
<p><br /><span class="math">$\frac{d}{dx} F(x) = f_1 + 2 f_2 x + 3 f_3 x^2 + 4 f_4 x^3 + ...$</span><br /></p>
<p>Для реализации нам понадобится вспомогательная функция, которая будет обновлять значение дополнительного множителя <span class="math"><em>n</em></span> в выражении <span class="math"><em>n</em><em>x</em><sup><em>n</em> − 1</sup></span>:</p>

\begin{code}
diff :: Num a => Ps a -> Ps a
diff (f :+: fs) = diff' 1 fs
    where diff' n (g :+: gs) = (n * g) :+: (diff' (n+1) gs)
\end{code}

<p>Также мы можем вычислить и интеграл степенного ряда:</p>

\begin{code}
int :: Fractional a => Ps a -> Ps a
int (f :+: fs) = 0 :+: (int' 1 fs) 
    where int' n (g :+: gs) = (g / n) :+: (int' (n+1) gs)
\end{code}

<h3 id="элементарные-функции">Элементарные функции</h3>
<p>Мы можем выразить элементарные функции через операции взятия производной и интегрирования. К примеру уравнение для <span class="math"><em>e</em><sup><em>x</em></sup></span> выглядит так:</p>
<p><br /><span class="math">$\frac{dy}{dx} = y$</span><br /></p>
<p>Проинтегрируем с начальным условием <span class="math"><em>y</em>(0) = 1</span>:</p>
<p><br /><span class="math"><em>y</em>(<em>x</em>) = 1 + ∫ <sub>0</sub><sup><em>x</em></sup><em>y</em>(<em>t</em>)<em>d</em><em>t</em></span><br /></p>
<p>Теперь переведём на Haskell:</p>

\begin{code}
expx = 1 + int expx
\end{code}

<p>Кажется невероятным, но это и есть определение экспоненты. Так же мы можем определить и функции для синуса и косинуса:</p>
<p><br /><span class="math">$\begin{array}{ll}
\frac{d}{dx} \sin{x} = \cos{x},   &amp; \sin(0) = 0, \\
\frac{d}{dx} \cos{x} = - \sin{x},  &amp; \cos(0) = 1 \\
\end{array}$</span><br /></p>
<p>Что приводит нас к:</p>

\begin{code}
sinx = int cosx
cosx = 1 - int sinx
\end{code}

<p>И это работает! Вычисление этих функций возможно за счёт того, что вне зависимости от аргумента функция \In{int} вернёт ряд, у которого первый коэффициент равен нулю. Это значение подхватывается и используется на следующем шаге рекурсивных вычислений.</p>
<p>Через синус и косинус мы можем определить тангенс:</p>

\begin{code}
tanx = sinx / cosx
\end{code}

<h2 id="водосборы">Водосборы</h2>
<p>В этом примере мы рассмотрим одну интересную технику рекурсивных вычислений, которая называется <em>мемоизацией</em> (memoization). Она заключается в том, что мы запоминаем все значения, с которыми вызывалась функция и, если с данным значением функция уже вычислялась, просто используем значение из памяти, а если значение ещё не вычислялось, вычисляем его и сохраняем.</p>
<p>В ленивых языках программирования для мемоизации функций часто используется такой приём. Мы сохраняем все значения функции в некотором контейнере, а затем обращаемся к элементам. При этом значения сохраняются в контейнере и не перевычисляются. Это происходит за счёт ленивых вычислений. Что интересно вычисляются не все значения, а лишь те, которые нам действительно нужны, те которые мы извлекаем из контейнера хотя бы один раз.</p>
<p>Посмотрим на такой классический пример. Вычисление чисел Фибоначчи. Каждое последующее число ряда Фибоначчи равно сумме двух предыдущих. Наивное определение выглядит так:</p>

\begin{code}
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
\end{code}

<p>В этом определении число вычислений растёт экспоненциально. Для того чтобы вычислить \In{fib n} нам нужно вычислить \In{fib (n-1)} и \In{fib (n-2)}, для того чтобы вычислить каждое из них нам нужно вычислить ещё два числа, и так вычисления удваиваются на каждом шаге. Если мы вызовем в интерпретаторе \In{fib 40}, то вычислитель зависнет. Что интересно в этой функции вычисления пересекаются, они могут быть переиспользованы. Например для вычисления \In{fib (n-1)} и \In{fib (n-2)} нужно вычислить \In{fib (n-2)} (снова), \In{fib (n-3)}, \In{fib (n-3)} (снова) и \In{fib (n-4)}.</p>
<p>Если мы сохраним все значения функции в списке, каждый вызов функции будет вычислен лишь один раз:</p>

\begin{code}
fib' :: Int -> Int
fib' n = fibs !! n
    where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
\end{code}

<p>Попробуем вычислить для \In{40}:</p>

\begin{code}
*Fib> fib' 40
102334155
*Fib> fib' 4040
700852629
\end{code}

<p>Вычисления происходят мгновенно. Если задача состоит из множества подзадач, которые самоподобны и для вычисления последующих подзадач используются решения из предыдущих, стоит задуматься об использовании мемоизации. Такие задачи называются задачами <em>динамического программирования</em>. Вычисление чисел Фибоначчи яркий пример задачи динамического программирования.</p>
<p>Рассмотрим такую задачу. Дана прямоугольная “карта местности”, в каждой клетке целым числом указана высота точки. Необходимо разметить местность по следующим правилам:</p>
<ul>
<li><p>Из каждой клетки карты вода стекает не более чем в одном из четырёх возможных направлений (“север”, “юг”, “запад”, “восток”).</p></li>
<li><p>Если у клетки нет ни одного соседа с высотой меньше её собственной высоты, то эта клетка – водосток, и вода из неё никуда дальше не течёт.</p></li>
<li><p>Иначе вода из текущей клетки стекает на соседнюю клетку с минимальной высотой.</p></li>
<li><p>Если таких соседей несколько, то вода стекает по первому из возможных направлений из списка “на север”, “на запад”, “на восток”, “на юг”.</p></li>
</ul>
<p>Все клетки из которых вода стекает в один и тот же водосток принадлежат к одному бассейну водосбора. Необходимо отметить на карте все бассейны. Решение этой задачи встретилось мне в статье Дмитрия Астапова “Рекурсия+мемоизация = динамическое программирование”. Здесь оно и приводится с незначительными изменениями.</p>
<p>Карта местности представлена в виде двумерного массива, в каждой клетке которого отмечена высота точки, нам необходимо получить двумерный массив того же размера, который вместо высот содержит метки водостоков. Мы будем отмечать их буквами латинского алфавита в том порядке, в котором они встречаются при обходе карты сверху вниз, слева направо. Например:</p>

\begin{code}
1 2 3 4 5 6       a a a b b b
7 8 9 2 4 5       a a b b b b
3 5 3 3 6 7   ->  c c d b b e 
6 4 5 5 3 1       f g d b e e
2 2 4 5 3 7       f g g h h e
\end{code}

<p>Для представления двумерного массива мы воспользуемся типом \In{Array} из стандартного модуля \In{Data.Array}. Тип \In{Array} имеет два параметра:</p>

\begin{code}
data Array i a
\end{code}

<p>Первый указывает на индекс, а второй на содержание. Массивы уже встречались нам в главе о типе \In{ST}. Напомню, что подразумевается, что этот тип является экземпляром класса \In{Ix}, который описывает целочисленные индексы, вспомним его определение:</p>

\begin{code}
class Ord a => Ix a where
    range       :: (a, a) -> [a]
    index       :: (a, a) -> a -> Int
    inRange     :: (a, a) -> a -> Bool
    rangeSize   :: (a, a) -> Int
\end{code}

<p>Первый аргумент у всех этих функций это пара, которая представляет верхнюю и нижнюю грань последовательности. Попробуйте догадаться, что делают методы этого класса по типам и именам.</p>
<p>Для двумерного массива индекс будет задаваться парой целых чисел:</p>

\begin{code}
import Data.Array

type Coord = (Int, Int)
type HeightMap = Array Coord Int
type SinkMap   = Array Coord Coord
\end{code}

<p>Значение типа \In{HeightMap} хранит карту высот, значение типа \In{SinkMap} хранит в каждой координате, ту точку, которая является водостоком для данной точки. Нам необходимо построить функцию:</p>

\begin{code}
flow :: HeightMap -> SinkMap
\end{code}

<p>Мы будем решать эту задачу рекурсивно. Представим, что мы знаем водостоки для всех точек кроме данной. Для каждой точки мы можем узнать в какую сторону из неё стекает вода. При этом водосток для следующей точки такой же как и для текущей. Если же из данной точки вода никуда не течёт, то она сама является водостоком. Мы определим эту функцию через комбинатор неподвижной точки \In{fix}.:</p>

\begin{code}
flow :: HeightMap -> SinkMap
flow arr = fix $ \result -> listArray (bounds arr) $ 
    map (\x -> maybe x (result !) $ getSink arr x) $ 
    range $ bounds arr 

getSink :: HeightMap -> Coord -> Maybe Coord
\end{code}

<p>Мы ищем решение в виде неподвижной точки функции, которая принимает карту стоков и возвращает карту стоков. Функция \In{getSink} по данной точке на карте вычисляет соседнюю точку, в которую стекает вода. Эта функция частично определена, поскольку для водостоков нет такой соседней точки, в которую бы утекала вода. Функция \In{listArray} конструирует значение типа \In{Array} из списка значений. Первым аргументом она принимает диапазон значений для индексов. Размеры массива совпадают с размерами карты высот, поэтому первым аргументом мы передаём \In{bounds arr}.</p>
<p>Теперь разберёмся с тем как заполняются значения в список. Сначала мы создаём список координат исходной карты высот с помощью выражения:</p>

\begin{code}
range $ bounds arr
\end{code}

<p>После этого мы по координатам точек находим водостоки, причём сразу для всех точек. Это происходит в лямбда-функции:</p>

\begin{code}
\x -> maybe x (result !) $ getSink arr x
\end{code}

<p>Мы принимаем текущую координату и с помощью функции \In{getSink} находим соседнюю точку, в которую убегает вода. Если такой точки нет, то в следующем выражении мы вернём исходную точку, поскольку в этом случае она и будет водостоком, а если такая соседняя точка всё-таки есть мы спросим результат из будущего. Мы обратимся к результату \In{(result !)}, посмотрим каким окажется водосток для соседней точки и вернём это значение. Поскольку за счёт ленивых вычислений значения результирующего массива вычисляются лишь один раз, после того как мы найдём водосток для данной точки этим результатом смогут воспользоваться все соседние точки. При этом порядок обращения к значениям из будущих вычислений не играет роли.</p>
<p>Осталось только определить функцию поиска ближайшего стока и функцию разметки.</p>

\begin{code}
getSink :: HeightMap -> Coord -> Maybe Coord
getSink arr (x, y) 
    | null sinks = Nothing
    | otherwise  = Just $ snd $ minimum $ map (\i -> (arr!i, i)) sinks
    where sinks = filter p [(x+1, y), (x-1, y), (x, y-1), (x, y+1)]
          p i   = inRange (bounds arr) i && arr ! i < arr ! (x, y)
\end{code}

<p>В функции разметки мы воспользуемся ассоциативным массивом из модуля \In{Data.Map}. Функция \In{nub} из модуля \In{Data.List} убирает из списка повторяющиеся элементы. Затем мы составляем список пар из координат водостоков и меток и в самом конце размечаем исходный массив:</p>

\begin{code}
label :: SinkMap -> LabelMap
label a = fmap (m M.! ) a 
    where m = M.fromList $ flip zip ['a' .. ] $ nub $ elems a
\end{code}

<h2 id="ленивее-некуда">Ленивее некуда</h2>
<p>Мы выяснили, что значение может редуцироваться только при сопоставлении с образцом и в специальной функции \In{seq}. Функцию \In{seq} мы можем применять, а можем и не применять. Но кажется, что в декомпозиции мы не можем уйти от необходимости проведения хотя бы одной редукции. Оказывается можем, в Haskell для этого предусмотрены специальные <em>ленивые образцы</em> (lazy patterns). Они обозначаются знаком тильда:</p>

\begin{code}
lazyHead :: [a] -> a
lazyHead ~(x:xs) = x
\end{code}

<p>Перед скобками сопоставления с образцом пишется символ тильда. Этим мы говорим вычислителю: доверься мне, здесь точно такой образец, можешь даже не проверять дальше. Он и правда дальше не пойдёт. Например если мы напишем такое определение:</p>

\begin{code}
lazySafeHead :: [a] -> Maybe a
lazySafeHead ~(x:xs) = Just x
lazySafeHead []      = Nothing   
\end{code}

<p>Если мы подставим в эту функцию пустой список мы получим ошибку времени выполнения, вычислитель доверился нам в первом уравнении, а мы его обманули. Сохраним в модуле \In{Strict} и проверим:</p>

\begin{code}
Prelude Strict> :! ghc --make Strict
[1 of 1] Compiling Strict           ( Strict.hs, Strict.o )

Strict.hs:67:0:
    Warning: Pattern match(es) are overlapped
             In the definition of `lazySafeHead': lazySafeHead [] = ...
Prelude Strict> :l Strict
Ok, modules loaded: Strict.
Prelude Strict> lazySafeHead [1,2,3]
Just 1
Prelude Strict> lazySafeHead []
Just *** Exception: Strict.hs:(67,0)-(68,29): Irrefutable 
pattern failed for pattern (x : xs)
\end{code}

<p>При компиляции нам даже сообщили о том, что образцы в декомпозиции пересекаются. Но мы были упрямы и напоролись на ошибку, если мы поменяем образцы местами, то всё пройдёт гладко:</p>

\begin{code}
Prelude Strict> :! ghc --make Strict
[1 of 1] Compiling Strict           ( Strict.hs, Strict.o )
Prelude Strict> :l Strict
Ok, modules loaded: Strict.
Prelude Strict> lazySafeHead []
Nothing
\end{code}

<p>Отметим, что сопоставление с образцом в \In{let} и \In{where} выражениях является ленивым. Функцию \In{lazyHead} мы могли бы написать и так:</p>

\begin{code}
lazyHead a = x
    where (x:xs) = a

lazyHead a = 
    let (x:xs) = a
    in  x
\end{code}

<p>Посмотрим как используются ленивые образцы при построении потоков, или бесконечных списков. Мы будем представлять функции одного аргумента потоками значений с одинаковым шагом. Так мы будем представлять непрерывные функции дискретными сигналами. Считаем, что шаг дискретизации (или шаг между соседними точками) нам известен.</p>
<p><br /><span class="math"><em>f</em>: <em>R</em> → <em>R</em>  ⇒  <em>f</em><sub><em>n</em></sub> = <em>f</em>(<em>n</em><em>τ</em>),  <em>n</em> = 0, 1, 2, . . . </span><br /></p>
<p>Где <span class="math"><em>τ</em></span> – шаг дискретизации, а <span class="math"><em>n</em></span> пробегает все натуральные числа. Определим функцию решения дифференциальных уравнений вида:</p>
<p><br /><span class="math">$\frac{dx}{dt} = f(t)$</span><br /></p>
<p><br /><span class="math"><em>x</em>(0) = <em>x̂</em></span><br /></p>
<p>Символ <span class="math"><em>x̂</em></span> означает начальное значение функции <span class="math"><em>x</em></span>. Перейдём к дискретным сигналам:</p>
<p><span class="math">$\frac{x_n - x_{n-1}}{\tau} = f_n, \quad x_0 = \hat{x}$</span></p>
<p>Где <span class="math"><em>τ</em></span> – шаг дискретизации, а <span class="math"><em>x</em></span> и <span class="math"><em>f</em></span> – это потоки чисел, индекс \In{n} пробегает от нуля до бесконечности по всем точкам функции, превращённой в дискретный сигнал. Такой метод приближения дифференциальных уравнений называют методом Эйлера. Теперь мы можем выразить следующий элемент сигнала через предыдущий.</p>
<p><br /><span class="math"><em>x</em><sub><em>n</em></sub> = <em>x</em><sub><em>n</em> − 1</sub> + <em>τ</em><em>f</em><sub><em>n</em></sub>,  <em>x</em><sub>0</sub> = <em>x̂</em></span><br /></p>
<p>Закодируем это уравнение:</p>

\begin{code}
-- шаг дискретизации
dt :: Fractional a => a
dt = 1e-3

-- метод Эйлера
int :: Fractional a => a -> [a] -> [a]
int x0 (f:fs) = x0 : int (x0 + dt * f) fs
\end{code}

<p>Смотрите в функции \In{int} мы принимаем начальное значение \In{x0} и поток всех значений функции правой части уравнения, поток значений функции <span class="math"><em>f</em>(<em>t</em>)</span>. Мы помещаем начальное значение в первый элемент результата, а остальные значения получаем рекурсивно.</p>
<p>Определим две вспомогательные функции:</p>

\begin{code}
time :: Fractional a => [a]
time = [0, dt ..]

dist :: Fractional a => Int -> [a] -> [a] -> a
dist n a b = ( / fromIntegral n) $ 
    foldl' (+) 0 $ take n $ map abs $ zipWith (-) a b
\end{code}

<p>Функция \In{time} пробегает все значения отсчётов шага дискретизации по времени. Это тождественная функция представленная в виде потока с шагом \In{dt}.</p>
<p>Функция проверки результата \In{dist} принимает два потока и по ним считает расстояние между ними. Эта функция говорит, что расстояние между двумя потоками в \In{n} первых точках равно сумме модулей разности между значениями потоков. Для того чтобы оценить среднее расхождение, мы делим в конце результат на число точек.</p>
<p>Также импортируем для удобства символьный синоним для \In{fmap} из модуля \In{Control.Applicative}.</p>

\begin{code}
import Control.Applicative((<$>))
...
\end{code}

<p>Проверим функцию \In{int}. Для этого сохраним все новые функции в модуле \In{Stream.hs}. Загрузим модуль в интерпретатор и вычислим производную какой-нибудь функции. Найдём решение для правой части константы и проверим, что у нас получилась тождественная функция:</p>

\begin{code}
*Stream> dist 1000 time $ int 0 $ repeat 1
7.37188088351104e-17
\end{code}

<p>Функции практически совпадают, порядок ошибки составляет <span class="math">10<sup> − 16</sup></span>. Так и должно быть для линейных функций. Посмотрим, что будет если в правой части уравнения стоит тождественная функция:</p>

\begin{code}
*Stream> dist 1000 ((\t -> t^2/2) <$> time) $ int 0 time
2.497500000001403e-4
\end{code}

<p>Решение этого уравнения равно функции <span class="math">$\frac{t^2}{2}$</span>. Здесь мы видим, что результаты уже не такие хорошие.</p>
<p>Есть функции, которые определяются рекурсивно в терминах дифференциальных уравнений, например экспонента будет решением такого уравнения:</p>
<p><br /><span class="math">$\frac{dx}{dt} = x$</span><br /></p>
<p><br /><span class="math"><em>x</em>(<em>t</em>) = <em>x</em>(0) + ∫ <sub>0</sub><sup><em>t</em></sup><em>x</em>(<em>τ</em>)<em>d</em><em>τ</em></span><br /></p>
<p>Опишем это уравнение в Haskell:</p>

\begin{code}
e = int 1 e
\end{code}

<p>Наше описание копирует исходное математическое определение. Добавим это уравнение в модуль \In{Stream} и проверим результаты:</p>

\begin{code}
*Stream> dist 1000 (map exp time) e
^CInterrupted.
\end{code}

<p>К сожалению вычисление зависло. Нажмём \In{ctrl+c} и разберёмся почему. Для этого распишем вычисление потока чисел \In{e}:</p>

\begin{code}
        e                           -- раскроем e 
=>      int 1 e                     -- раскроем int, во втором варгументе
                                    -- int стоит декомпозиция, 
=>      int 1 e@(f:fs)              -- для того чтобы узнать какое уравнение 
                                    -- для int выбрать нам нужно раскрыть 
                                    -- второй аргумент, узнать корневой 
                                    -- конструктор, раскроем второй аргумент:
=>      int 1 (int 1 e)
=>      int 1 (int 1e@(f:fs))       -- такая же ситуация
=>      int 1 (int 1 (int 1 e))
\end{code}

<p>Проблема в том, что первый элемент решения мы знаем, мы передаём его первым аргументом и присоединяем к решению, но <em>справа</em> от знака равно. Но для того чтобы перейти в правую часть вычислителю нужно проверить все аргументы, в которых есть декомпозиция. И он начинает проверять, но слишком рано. Нам бы хотелось, чтобы он сначала присоединил к решению первый аргумент, а затем выполнял бы вычисления следующего элемента.</p>
<p>C помощью ленивых образцов мы можем отложить декомпозицию второго аргумента на потом:</p>

\begin{code}
int :: Fractional a => a -> [a] -> [a]
int x0 ~(f:fs) = x0 : int (x0 + dt * f) fs
\end{code}

<p>Теперь мы видим:</p>

\begin{code}
*Stream> dist 1000 (map exp time) e
4.988984990735441e-4
\end{code}

<p>Вычисления происходят. С помощью взаимно-рекурсивных функций мы можем определить функции синус и косинус:</p>

\begin{code}
sinx = int 0 cosx
cosx = int 1 (negate <$> sinx)
\end{code}

<p>Эти функции описывают точку, которая бегает по окружности. Вот математическое определение:</p>

<p>Проверим в интерпретаторе:</p>

\begin{code}
*Stream> dist 1000 (sin <$> time) sinx
1.5027460329809257e-4
*Stream> dist 1000 (cos <$> time) cosx
1.9088156807382827e-4
\end{code}

<p>Так с помощью ленивых образцов нам удалось попасть в правую часть уравнения для функции \In{int}, не раскрывая до конца аргументы в левой части. С помощью этого мы могли ссылаться в сопоставлении с образцом на значение, которое ещё не было вычислено.</p>
<h2 id="краткое-содержание">Краткое содержание</h2>
<p>Ленивые вычисления повышают модульность программ. Мы можем в одной части программы создать все возможные решения, а в другой выбрать лучшие по какому-либо признаку. Также мы посмотрели на интересную технику написания рекурсивных функций, которая называется мемоизацией. Мемоизация означает, что мы не вычисляем повторно значения некоторой функции, а сохраняем их и используем в дальнейших вычислениях. Мы узнали новую синтаксическую конструкцию. Оказывается мы можем не только бороться с ленью, но и поощрять её. Лень поощряется ленивыми образцами. Они отменяют приведение к слабой заголовочной нормальной форме при декомпозиции аргументов. Они пишутся как обычные образцы, но со знаком тильда:</p>

\begin{code}
lazyHead ~(x:xs) = x
\end{code}

<p>Мы говорим вычислителю: поверь мне, это значение может иметь только такой вид, потом посмотришь так ли это, когда значения тебе понадобятся. Поэтому ленивые образцы проходят сопоставление с образцом в любом случае.</p>
<p>Сопоставление с образцом в \In{let} и \In{where} выражениях является ленивым. Функцию \In{lazyHead} мы могли бы написать и так:</p>

\begin{code}
lazyHead a = x
    where (x:xs) = a

lazyHead a = 
    let (x:xs) = a
    in  x
\end{code}

<h2 id="упражнения">Упражнения</h2>
<p>Мы побывали на выставке ленивых программ. Присмотритесь ещё раз к решениям задач этой главы и подумайте какую роль сыграли ленивые вычисления в каждом из случаев, какие мотивы обыгрываются в этих примерах. Также подумайте каким было бы решение, если бы в Haskell использовалась стратегия вычисления по значению. Критически настроенные читатели могут с помощью профилирования проверить эффективность программ из этой главы.</p>
</body>
</html>
