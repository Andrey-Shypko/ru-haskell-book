<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<h1 id="поиграем">Поиграем</h1>
<p>Вот и закончилась первая часть книги. Мы узнали основные конструкции языка Haskell. В этой главе мы напишем законченную программу для игры в пятнашки. Ну или почти законченную, глава венчается упражнениями.</p>
<h2 id="стратегия-написания-программ">Стратегия написания программ</h2>
<h3 id="описание-задачи">Описание задачи</h3>
<p>Решение задачи начинается с описания проблемы и наброска решения. Мы хотим создать программу, в которой можно будет играть в пятнашки. Если вам не знакома это игра, то взгляните на рисунок. Игра начинается с позиции, в которой все фишки перемешаны. Необходимо, переставляя фишки, вернуться в исходное положение. Каждым ходом мы двигаем одну фишку на пустое поле. В исходном положении фишки идут по порядку.</p>
<p></p>
<p>Программа будет перемешивать фишки и отображать поле для игры. Она будет спрашивать следующий ход и обновлять поле после хода. Если мы расставим все фишки по порядку, программа сообщит нам об этом и предложит начать новую игру. В каждый момент мы можем не только сделать ход, но и покинуть игру или начать всё заново. Известно, что не из любого положения можно расставить фишки по порядку. Поэтому наш алгоритм перемешивания должен генерировать только такие позиции, для которых решение возможно.</p>
<h3 id="набросок-решения">Набросок решения</h3>
<p>Программа, которую мы хотим написать, будет вести диалог с пользователем. Она показывает поле для игры и спрашивает следующий ход. Потом она распознаёт ход, и показывает обновлённое поле. И так далее. Нам нужно как-то организовать этот диалог.</p>
<p>При этом в программе можно выделить две независимые части. Одна отвечает за сам диалог. Она принимает реплики пользователя и отображает поле для игры. А другая часть отвечает за правила игры пятнашки: как ходы влияют на поле, какое положение является победным, как перемешивать фишки.</p>
<p>У нас будет два отдельных модуля: один для описания игры, назовём его \In{Game}, а другой для описания диалога с пользователем. Мы назовём его \In{Loop} (петля или цикл), поскольку диалог это зацикленная процедура получения реплики и реакции на реплику.</p>
<p>Такой вот набросок-ориентир. После этого можно приступать к реализации. Но с чего начать?</p>
<h3 id="каркас.-типы-и-классы">Каркас. Типы и классы</h3>
<p>В Haskell программы обычно начинают строить с каркаса, т.е.~с типов и классов. Нам нужно выделить основные сущности и подумать какие типы подходят для их описания лучше всего.</p>
<p>В нашей задаче есть поле с фишками и ходы. Мы делаем ходы и фишки двигаются. Поле – это матрица или двумерный массив. У нас есть два индекса, которые пробегают значения от нуля до трёх. В каждой ячейке массива хранятся фишки. Фишки обозначаются целыми числами:</p>

\begin{code}
type Pos    = (Int, Int)
type Label  = Int

type Board  = Array Pos Label
\end{code}

<p>Пустую фишку мы будем также обозначать числом. Физически когда мы ходим, мы меняем положение одной фишки. Но в нашем описании мы меняем местами две фишки, поскольку пустая фишка также обозначается номером. Когда мы ходим, мы меняем положение пустой фишки, одним ходом мы можем сместить её вверх, вниз, влево или вправо. Введём специальный тип для обозначения ходов:</p>

\begin{code}
data Move = Up | Down | Left | Right
\end{code}

<p>Для того чтобы при каждом ходе не искать пустую клетку, давайте сохраним её текущее положение. Тип \In{Game} будет содержать текущее положение пустой клетки и положение фишек:</p>

\begin{code}
data Game = Game {
        emptyField  :: Pos,
        gameBoard   :: Board }
\end{code}

<p>Вот и все типы для описания игры. Сохраним их в модуле \In{Game}. Теперь подумаем о типах для диалога с пользователем. В этом модуле наверняка будет много функций с типом \In{IO}, потому что в нём происходит взаимодействие с игроком. Но, что является каркасом для диалога?</p>
<p>Если мы хотим с кем-нибудь общаться, необходимо чтобы у нас был с собеседником общий язык, он и будет каркасом для диалога. Вспомним, что мы ожидаем от пользователя. Пользователь может:</p>
<ul>
<li><p>Сделать ход</p></li>
<li><p>Начать новую игру</p></li>
<li><p>Выйти из игры</p></li>
</ul>
<p>Если пользователь делает ход мы показываем новое положение поля, если он начинает новую игру мы показываем ему новую перемешанную позицию, давайте у нас будет разная степень перемешанности фигур. При перемешивании мы стартуем из победного положения и начинаем случайным образом делать ходы. Чем больше ходов мы сделаем тем сложнее будет собрать игру. Поэтому пользователь будет указывать число шагов для перемешивания при запросе новой игры. Если пользователь попросит закончить игру мы попрощаемся и выйдем из игры.</p>
<p>На основе этих рассуждений вырисовывается следующий тип для сообщений:</p>

\begin{code}
data Query = Quit | NewGame Int | Play Move
\end{code}

<p>Значение типа \In{Query} (запрос) может быть константа \In{Quit} (выход), запрос новой игры \In{NewGame} с числом, которое указывает на сложность новой игры, также игрок может просто сделать ход \In{Play Move}.</p>
<p>А каков формат наших ответов? Все наши ответы на самом деле будут вызовами функции \In{putStrLn} мы будем отвечать пользователю изменениями экрана. Поэтому у нас нет специального типа для ответов. Итак у нас есть каркас, который можно начинать покрывать значениями. На этом этапе у нас есть два модуля. Это модуль \In{Loop}:</p>

\begin{code}
module Loop where

import Game

data Query = Quit | NewGame Int | Play Move
\end{code}


<p>И модуль \In{Game}:</p>

\begin{code}
module Game where

import Data.Array

data Move = Up | Down | Left | Right
    deriving (Enum)

type Label = Int

type Pos = (Int, Int)

type Board = Array Pos Label

data Game = Game {
        emptyField  :: Pos,
        gameBoard   :: Board }
\end{code}

<h3 id="ленивое-программирование">Ленивое программирование</h3>
<p>Мы уже знаем как происходят ленивые вычисления. Мы принимаем выражение и начинаем очищать его от синонимов от корня к листьям или сверху вниз. Оказывается таким способом можно писать программы. Более того в функциональном программировании это очень распространённый подход. Мы начинаем со спецификации задачи (неформального описания) и потихоньку вытягиваем из него выражения языка Haskell. Начинаем мы с корня, с самой верхней функции. Эта функция будет состоять из подвыражений. Когда мы напишем верхнюю функцию, мы перейдём к подвыражениям. И так мы будем спускаться пока не напишем всю программу.</p>
<p>Кажется, что такой подход очень не надёжен. Ведь мы сможем запустить программу только когда напишем её целиком. На каждом промежуточном шаге у нас есть неопределённые подвыражения. Получается, что очень долгое время мы будем писать программу, не зная работает она или нет.</p>
<p>Оказывается, что в Haskell есть решение этой проблемы. Нам поможет значение \In{undefined}. Мы будем писать только тип функции (и мысленно будем говорить, пусть она делает то-то), а вместо определения будем писать \In{undefined}. При этом конечно мы не сможем выполнять программу, вычислитель подорвётся на первом же значении, но мы сможем узнать осмысленна ли наша программа с точки зрения компилятора, проходит ли она проверку типов. В Haskell это большой плюс. Если программа прошла проверку типов, то скорее всего она будет работать.</p>
<p>Такой подход написания программ называется написанием сверху вниз. Мы начинаем с самой верхней функции и потихоньку вычищаем все \In{undefined}. Если вспомнить ленивые вычисления, то там роль \In{undefined} выполняли отложенные вычисления.</p>
<p>В чём преимущества такого подхода? Посмотрим на дерево (). Если мы идём сверху вниз, то в самом начале у нас лишь одна задача, потом их становится всё больше и больше. Они дробятся, но источник у них один. Мы всегда знаем, что нам нужно чтобы закончить нашу задачу. Написать это, это и это подвыражение. Беда только в том, что это подвыражение содержит ещё больше подвыражений. Но сложные подвыражения мы можем оставить на потом и заняться другими. А потом, когда мы их доделаем может вдруг оказаться, что это сложное выражение нам и не нужно.</p>
<p></p>
<p>Если же мы начинаем идти из листьев, то у нас много отправных точек, которые должны сойтись в одной цели. При этом они могут и не сойтись, мы можем застрять в одной точке и потратить слишком много времени. И на остальные задачи у нас не хватит сил или мы можем потратить много времени на решение задачи, которая совсем не нужна для итогового решения. Также как и в вычислениях по значению, мы можем застрять на вычислении бесконечного значения, даже если в итоговом ответе нам понадобится лишь его малая часть.</p>
<p>Ещё один плюс решения сверху вниз состоит в экономии усилий. Мы можем написать всю программу в виде функций, которые состоят лишь из определений типов. И утрясти общую схему программы на типах. Также при реализации отдельных частей программы, мы можем воспользоваться упрощёнными алгоритмами, достаточными для тестирования приложения, оставив отрисовку деталей на потом. Мы не тратим время на реализацию, а смотрим как программа выглядит “вцелом”. Если общий набросок нас устраивает мы можем начать заполнять дыры и детализировать отдельные выражения. Так мы будем детализировать-детализировать пока не придём к первоначальному решению. Далее если у нас останется время мы можем сменить реализацию некоторых частей. Но общая схема останется прежней, она уже устоялась на уровне типов. Часто такую стратегию разработки называют разработкой через прототипы (developing by prototyping). При этом процесс написания приложения можно представить как процесс сходимости, приближения к пределу. У нас есть серия промежуточных решений или прототипов, которые с каждым шагом всё точнее и точнее описывают итоговую программу. Также если мы работаем в команде, то дробление задачи на подзадачи происходит естественно, в ходе детализации, мы можем распределить нагрузку, распределив разные \In{undefined} между участниками проекта.</p>
<p>Слово \In{undefined} будет встречаться очень часто, буквально в каждом значении. Оно очень длинное, и часто писать его будет слишком утомительно. Определим удобный синоним. Я обычно использую \In{un} или \In{lol} (что-нибудь краткое и удобное для автоматического поиска):</p>

\begin{code}
un :: a
un = undefined
\end{code}

<p>Но давайте приступим к реализации нашей игры. Самая верхняя функция, будет запускать программу. Назовём её \In{play}. Это функция взаимодействия с пользователем она ведёт диалог, поэтому её тип будет \In{IO ()}:</p>

\begin{code}
play :: IO ()
play = un
\end{code}

<p>Итак у нас появилась корневая функция. Что мы будем в ней делать? Для начала мы поприветствуем игрока (функция \In{greetings}). Затем предложим ему начать игру (функция \In{setup}), после чего запустим цикл игры (функция \In{gameLoop}). Приветствие это просто надпись на экране, поэтому тип у него будет \In{IO ()}. Предложение игры вернёт стартовую позицию для игры, поэтому тип будет \In{IO Game}. Цикл игры принимает состояние и продолжает диалог. В типах это выражается так:</p>

\begin{code}
play :: IO ()
play = greetings >> setup >>= gameLoop

greetings :: IO ()
greetings = un

setup :: IO Game
setup = un

gameLoop :: Game -> IO ()
gameLoop = un
\end{code}

<p>Сохраним эти определения в модуле \In{Loop} и загрузим модуль с программой в интерпретатор:</p>

\begin{code}
Prelude> :l Loop
[1 of 2] Compiling Game             ( Game.hs, interpreted )
[2 of 2] Compiling Loop             ( Loop.hs, interpreted )
Ok, modules loaded: Game, Loop.
*Loop> 
\end{code}

<p>Модуль загрузился. Он потянул за собой модуль \In{Game}, потому что мы воспользовались типом \In{Move} из этого модуля. Программа прошла проверку типов, значит она осмысленна и мы можем двигаться дальше.</p>
<p>У нас три варианта дальнейшей детализации это функции \In{greetings}, \In{setup} и \In{gameLoop}. Мы пока пропустим \In{greetings} там мы напишем какое-нибудь приветствие и сообщим игроку куда он попал и как ходить.</p>
<p>В функции \In{setup} нам нужно начать первую игру. Для начала игры нам нужно узнать её сложность, т.е.~на сколько ходов перемешивать позицию. Это значит, что нам нужно спросить у игрока целое число. Мы спросим число функцией \In{getLine}, а затем попробуем его распознать. Если пользователь ввёл не число, то мы попросим его повторить ввод. Функция \In{readInt :: String -> Maybe Int} распознаёт число. Она возвращает целое число завёрнутое в \In{Maybe}, потому что строка может оказаться не числом. Затем это число мы используем в функции \In{shuffle} (перемешать), которая будет возвращать позицию, которая перемешана с заданной глубиной.</p>

\begin{code}
-- в модуль Loop

setup :: IO Game
setup = putStrLn "Начнём новую игру?" >>
    putStrLn "Укажите сложность (положительное целое число): " >>
    getLine >>= maybe setup shuffle . readInt 

readInt :: String -> Maybe Int
readInt = un

-- в модуль Game:

shuffle :: Int -> IO Game
shuffle = un
\end{code}

<p>Функция \In{shuffle} возвращает состояние игры \In{Game}, которое завёрнуто в \In{IO}. Оно завёрнуто в \In{IO}, потому что перемешивать позицию мы будем случайным образом, это значит, что мы воспользуемся функциями из модуля \In{Random}. Мы хотим чтобы каждая новая игра начиналась с новой позиции, поэтому скорее всего где-то в недрах функции \In{shuffle} мы воспользуемся \In{newStdGen}, которая и потянет за собой тип \In{IO}.</p>
<p>Игра перемешивается согласно правилам, поэтому функцию \In{shuffle} мы поселим в модуле \In{Game}. А функция \In{readInt} это скорее элемент взаимодействия с пользователем, ведь в ней мы распознаём число в строчном ответе, она останется в модуле \In{Loop}.</p>
<p>Проверим работает ли наша программа:</p>

\begin{code}
*Loop> :r
[1 of 2] Compiling Game             ( Game.hs, interpreted )
[2 of 2] Compiling Loop             ( Loop.hs, interpreted )
Ok, modules loaded: Game, Loop.
*Loop> 
\end{code}

<p>Работает! Можно спускаться по дереву выражения ниже. Сейчас нам предстоит написать одну из самых сложных функций, это функция \In{gameLoop}.</p>
<h2 id="пятнашки">Пятнашки</h2>
<h3 id="цикл-игры">Цикл игры</h3>
<p>Функция цикла игры принимает текущую позицию. При этом у нас два варианта. Возможно игра пришла в конечное положение (\In{isGameOver}) и мы можем сообщить игроку о том, что он победил (\In{showResults}), если это не так, то мы покажем текущее положение (\In{showGame}), спросим ход (\In{askForMove}) и среагируем на ход (\In{reactOnMove}).</p>

\begin{code}
-- в модуль Loop

gameLoop :: Game -> IO ()
gameLoop game 
    | isGameOver game   = showResults game >> setup >>= gameLoop
    | otherwise         = showGame game >> askForMove >>= reactOnMove game


showResults :: Game -> IO ()
showResults = un

showGame :: Game -> IO ()
showGame = un

askForMove :: IO Query
askForMove = un

reactOnMove :: Game -> Query -> IO ()
reactOnMove = un

-- в модуль Game

isGameOver :: Game -> Bool
isGameOver = un
\end{code}

<p>Как определить закончилась игра или нет это скорее дело модуля \In{Game}. Все остальные функции принадлежат модулю \In{Loop}. Функция \In{askForMove} возвращает реплику пользователя и тут же направляет её в функцию \In{reactOnMove}. Функции \In{showGame} и \In{showResults} ничего не возвращают, они только меняют состояния экрана. После того как игра закончится мы предложим игроку начать новую.</p>
<p>Обратите внимание на то, как даже не дав определение функции, мы всё же очерчиваем её смысл в объявлении типа. Так посмотрев на функцию \In{askForMove} и сопоставив тип с именем, мы можем понять, что эта функция предназначена для запроса значения типа \In{Query}, для запроса реплики пользователя. А по типу функции \In{showGame} мы можем понять, что она проводит какой-то побочный эффект, судя по имени что-то показывает, из типа видно что показывает значение типа \In{Game} или текущую позицию.</p>
<h4 id="отображение-позиции">Отображение позиции</h4>
<p>Определим функции отображения результата и позиции. Когда игра закончится мы покажем итоговое положение и объявим результат.</p>

\begin{code}
showResults :: Game -> IO ()
showResults g = showGame g >> putStrLn "Игра окончена."
\end{code}

<p>Теперь определим функцию \In{showGame}. Если тип \In{Game} является экземпляром класса \In{Show}, то определение окажется совсем простым:</p>

\begin{code}
-- в модуль Loop

showGame :: Game -> IO ()
showGame = putStrLn . show 

-- в модуль Game

instance Show Game where
    show = un
\end{code}

<h4 id="реакция-на-реплики-пользователя">Реакция на реплики пользователя</h4>
<p>Теперь нужно определить функции \In{askForMove} и \In{reactOnMove}. Первая функция требует установить протокол реплик пользователя, в каком виде он будет набирать значения типа \In{Query}. Нам пока лень об этом думать и мы перейдём к функции \In{reactOnMove}. Вспомним её тип:</p>

\begin{code}
reactOnMove :: Game -> Query -> IO ()
\end{code}

<p>Функция принимает текущее положение и запрос пользователя. И ничего не возвращает, она продолжает игру. В любом случае в этой функции будет сопоставление с образцом по запросам пользователя так что можно написать:</p>

\begin{code}
reactOnMove :: Game -> Query -> IO ()
reactOnMove game query = case query of
    Quit        -> 
    NewGame n   -> 
    Play    m   -> 
\end{code}

<p>Рассмотрим каждый из случаев. В первом случае пользователь говорит, что ему надоело и он уже наигрался. Чтож попрощаемся и вернём значение единичного типа.</p>

\begin{code}
...
    Quit        -> quit
...

quit :: IO ()
quit = putStrLn "До встречи." >> return ()
\end{code}

<p>В следующем варианте пользователь хочет начать всё заново. Так начнём!</p>

\begin{code}
    NewGame n   -> gameLoop =<< shuffle n
\end{code}

<p>Мы вызвали функцию перемешивания \In{shuffle} с заданным уровнем сложности. И рекурсивно вызвали цикл игры с новой позицией. Всё началось по новой. В третьей альтернативе пользователь делает ход, на это мы должны обновить позицию запустить цикл игры с новым значением:</p>

\begin{code}
-- в модуль Loop
    Play    m   -> gameLoop $ move m game

-- в модуль Game
move :: Move -> Game -> Game
move = un
\end{code}

<p>Функция \In{move} обновляет согласно правилам текущую позицию. Соберём все определения вместе:</p>

\begin{code}
reactOnMove :: Game -> Query -> IO ()
reactOnMove game query = case query of
    Quit        -> quit
    NewGame n   -> gameLoop =<< shuffle n
    Play    m   -> gameLoop $ move m game
\end{code}

<h4 id="слушаем-игрока">Слушаем игрока</h4>
<p>Теперь всё же вернёмся к функции \In{askForMove}, научимся слушать пользователя. Сначала мы скажем какую-нибудь вводную фразу, предложение ходить (\In{showAsk}) затем запросим строку стандартной функцией \In{getLine}, потом нам нужно будет распознать (\In{parseQuery}) в строке значение типа \In{Query}. Если распознать его нам не удастся, мы напомним пользователю как с нами общаться (\In{remindMoves}) и попросим сходить вновь:</p>

\begin{code}
askForMove :: IO Query
askForMove = showAsk >>
    getLine >>= maybe askAgain return . parseQuery 
    where askAgain = wrongMove >> askForMove


parseQuery :: String -> Maybe Query
parseQuery = un

wrongMove :: IO ()
wrongMove = putStrLn "Не могу распознать ход." >> remindMoves

showAsk :: IO ()
showAsk = un

remindMoves :: IO ()
remindMoves = un
\end{code}

<p>Механизм распознавания похож на случай с распознаванием числа. Значение завёрнуто в тип \In{Maybe}. И в самом деле функция определена лишь частично, ведь не все строки кодируют то, что нам нужно.</p>
<p>Функции \In{parseQuery} и \In{remindMoves} тесно связаны. В первой мы распознаём ввод пользователя, а во второй напоминаем пользователю как мы закодировали его запросы. Тут стоит остановиться и серьёзно подумать. Как закодировать значения типа \In{Query}, чтобы пользователю было удобно набирать их? Но давайте отвлечёмся от этой задачи, она слишком серьёзная. Оставим её на потом, а пока проверим не ушли ли мы слишком далеко, возможно наша программа потеряла смысл. Проверим типы!</p>

\begin{code}
*Loop> :r
[1 of 2] Compiling Game             ( Game.hs, interpreted )
[2 of 2] Compiling Loop             ( Loop.hs, interpreted )
Ok, modules loaded: Game, Loop.
\end{code}

<h3 id="приведём-код-в-порядок">Приведём код в порядок</h3>
<p>Нам осталось дописать функции распознавания запросов и несколько маленьких функций с фразами и модуль \In{Loop} будет готов. Но перед тем как сделать это давайте упорядочим функции. Видно, что у нас выделилось несколько задач по типу общения с пользователем. У нас есть задачи, в которых мы что-то показываем пользователю, меняем состояние экрана и есть задачи, в которых мы просим от пользователя какие-то данные, ожидаем запросы функцией \In{getLine}. Также в самом верху выражения программы у нас расположены функции, которые координируют действия остальных, это третья группа. Сгруппируем функции по этому принципу.</p>
<h4 id="основные-функции">Основные функции</h4>

\begin{code}
play :: IO ()
play = greetings >> setup >>= gameLoop

gameLoop :: Game -> IO ()
gameLoop game 
    | isGameOver game   = showResults game >> setup >>= gameLoop
    | otherwise         = showGame game >> askForMove >>= reactOnMove game

setup :: IO Game
setup = putStrLn "Начнём новую игру?" >>
    putStrLn "Укажите сложность (положительное целое число): " >>
    getLine >>= maybe setup shuffle . readInt 
\end{code}

<h4 id="запросы-от-пользователя">Запросы от пользователя (\In{getLine})</h4>

\begin{code}
reactOnMove :: Game -> Query -> IO ()
reactOnMove game query = case query of
    Quit        -> quit
    NewGame n   -> gameLoop =<< shuffle n
    Play    m   -> gameLoop $ move m game

askForMove :: IO Query
askForMove = showAsk >>
    getLine >>= maybe askAgain return . parseQuery 
    where askAgain = wrongMove >> askForMove

parseQuery :: String -> Maybe Query
parseQuery = un

readInt :: String -> Maybe Int
readInt = un
\end{code}

<h4 id="ответы-пользователю">Ответы пользователю (\In{putStrLn})</h4>

\begin{code}
greetings :: IO ()
greetings = un

showResults :: Game -> IO ()
showResults g = showGame g >> putStrLn "Игра окончена."

showGame :: Game -> IO ()
showGame = putStrLn . show

showAsk :: IO ()
showAsk = un

quit :: IO ()
quit = putStrLn "До встречи." >> return ()
\end{code}

<p>По этим функциям видно, что нам немного осталось. Теперь вернёмся к запросам пользователя.</p>
<h3 id="формат-запросов">Формат запросов</h3>
<p>Можно вывести с помощью \In{deriving} экземпляр класса \In{Read} для типа \In{Query} и читать их функцией \In{read}. Но это плохая идея, потому что пользователь нашей программы может и не знать Haskell. Лучше введём сокращённые имена для всех значений. Например такие:</p>

\begin{code}
left        -- Play Left
right       -- Play Rigth
up          -- Play Up
down        -- Play Down

quit        -- Quit
new n       -- NewGame n
\end{code}

<p>Можно обратить внимание на то, что все команды начинаются с разных букв. Воспользуемся этим и дадим пользователю возможность набирать команды одной буквой. Это приводит на с к таким определениям для функций разбора значения и напоминания ходов:</p>

\begin{code}
parseQuery :: String -> Maybe Query
parseQuery x = case x of
    "up"    -> Just $ Play Up
    "u"     -> Just $ Play Up
    "down"  -> Just $ Play Down 
    "d"     -> Just $ Play Down 
    "left"  -> Just $ Play Left
    "l"     -> Just $ Play Left
    "right" -> Just $ Play Right
    "r"     -> Just $ Play Right
    "quit"  -> Just $ Quit
    "q"     -> Just $ Quit

    'n':'e':'w':' ':n   -> Just . NewGame =<< readInt n
    'n':' ':n           -> Just . NewGame =<< readInt n  
    _       -> Nothing

remindMoves :: IO ()
remindMoves = mapM_ putStrLn talk
    where talk = [
            "Возможные ходы пустой клетки:",
            "   left     или l       -- налево",
            "   right    или r       -- направо",
            "   up       или u       -- вверх",
            "   down     или d       -- вниз",
            "Другие действия:",
            "   new int  или n int -- начать новую игру, int - целое число,", 
                                      "указывающее на сложность",
            "   quit     или q      -- выход из игры"]
\end{code}

<p>Проверим работоспособность:</p>

\begin{code}
Prelude> :l Loop
[1 of 2] Compiling Game             ( Game.hs, interpreted )
[2 of 2] Compiling Loop             ( Loop.hs, interpreted )

Loop.hs:46:28:
    Ambiguous occurrence `Left'
    It could refer to either `Prelude.Left',
                             imported from `Prelude' at Loop.hs:1:8-11
                             (and originally defined in `Data.Either')
                          or `Game.Left',
                             imported from `Game' at Loop.hs:5:1-11
                             (and originally defined at Game.hs:10:25-28)

Loop.hs:47:28:
    Ambiguous occurrence `Left'
...
...
Failed, modules loaded: Game.
*Game> 
\end{code}

<p>По ошибкам видно, что произошёл конфликт имён. Конструкторы \In{Left} и \In{Right} уже определены в \In{Prelude}. Это конструкторы типа \In{Either}. Давайте скроем их, добавим в модуль такую строчку:</p>

\begin{code}
import Prelude hiding (Either(..))
\end{code}

<p>Теперь проверим:</p>

\begin{code}
*Game> :r
[2 of 2] Compiling Loop             ( Loop.hs, interpreted )
Ok, modules loaded: Game, Loop.
*Loop> 
\end{code}

<p>Всё работает, можно двигаться дальше.</p>
<h3 id="последние-штрихи">Последние штрихи</h3>
<p>В модуле \In{Loop} нам осталось определить несколько маленьких функций. Поиск по слову \In{un} говорит нам о том, что осталось определить функции ``</p>

\begin{code}
greetings   :: IO ()
readInt     :: String -> Maybe Int
showAsk     :: IO ()
\end{code}

<p>Самая простая это функция \In{showAsk}, она приглашает игрока сделать ход:</p>

\begin{code}
showAsk :: IO ()
showAsk = putStrLn "Ваш ход: "
\end{code}

<p>Теперь функция распознавания целого числа:</p>

\begin{code}
import Data.Char (isDigit)
...

readInt :: String -> Maybe Int
readInt n 
    | all isDigit n = Just $ read n
    | otherwise     = Nothing
\end{code}

<p>В первой альтернативе мы с помощью стандартной функции \In{isDigit :: Char -> Bool} проверяем, что строка состоит из одних только чисел. Если все символы числа, то мы пользуемся функцией из модуля \In{Read} и читаем целое число, иначе возвращаем \In{Nothing}.</p>
<p>Последняя функция, это функция приветствия. Когда игрок входит в игру он сталкивается с её результатами. Определим её так:</p>

\begin{code}
-- в модуль Loop

greetings :: IO ()
greetings = putStrLn "Привет! Это игра пятнашки" >>
    showGame initGame >>
    remindMoves

-- в модуль Game

initGame :: Game
initGame = un
\end{code}

<p>Сначала мы приветствуем игрока, затем показываем состояние (\In{initGame}), к которому ему нужно стремиться, и напоминаем как делаются ходы. На этом определении мы раскрыли все выражения в модуле \In{Loop}, нам остался лишь модуль \In{Game}.</p>
<h3 id="правила-игры">Правила игры</h3>
<p>Определим модуль \In{Game}, но мы будем определять его не с чистого листа. Те функции, которые нам нужны уже определились в ходе описания диалога с пользователем. Нам нужно уметь составлять начальное состояние \In{initGame}, уметь составлять перемешанное состояние игры \In{shuffle}, нам нужно уметь реагировать на ходы \In{move}, определять какая позиция является выигрышной \In{isGameOver} и уметь показывать фишки в красивом виде. Приступим!</p>

\begin{code}
initGame    :: Game
shuffle     :: Int -> IO Game
isGameOver  :: Game -> Bool
move        :: Move -> Game -> Game

instance Show Game where
    show = un
\end{code}

<p>Таков наш план.</p>
<h4 id="начальное-состояние">Начальное состояние</h4>
<p>Начнём с самой простой функции, составим начальное состояние:</p>

\begin{code}
initGame :: Game
initGame = Game (3, 3) $ listArray ((0, 0), (3, 3)) $ [0 .. 15]
\end{code}

<p>Мы будем кодировать фишки цифрами от нуля до 14, а пустая клетка будет равна 15. Это просто соглашения о внутреннем представлении фишек, показывать мы их будем совсем по-другому.</p>
<p>С этим значением мы можем легко определить функцию определения конца игры. Нам нужно только добавить \In{deriving (Eq)} к типу \In{Game}. Тогда функция \In{isGameOver} примет вид:</p>

\begin{code}
isGameOver :: Game -> Bool
isGameOver = ( == initGame)
\end{code}

<h4 id="делаем-ход">Делаем ход</h4>
<p>Напишем функцию:</p>

\begin{code}
move :: Move -> Game -> Game
\end{code}

<p>Она обновляет позицию после хода. В пятнашках не во всех позициях доступны все ходы. Если пустышка находится на краю, мы не можем вывести её за пределы доски. Это необходимо как-то учесть. Каждый ход задаёт направление обмена фишками. Если у нас есть текущее положение пустышки и ход, то по ходу мы можем узнать направление, а по направлению ту фишку, которая займёт место пустышки после хода. При этом нам необходимо проверять находится ли та фишка, которую мы хотим поместить на пустое место в пределах доски. Например если пустышка расположена в самом верху и мы хотим сделать ход \In{Up}, т.е.~передвинуть её ещё выше, то положение игры не должно измениться.</p>

\begin{code}
import Prelude hiding (Either(..))

newtype Vec = Vec (Int, Int)

move :: Move -> Game -> Game
move m (Game id board)  
    | within id' = Game id' $ board // updates
    | otherwise  = Game id board
    where id' = shift (orient m) id
          updates = [(id, board ! id'), (id', emptyLabel)] 
            
-- определение того, что индексы внутри доски
within :: Pos -> Bool
within (a, b) = p a && p b
    where p x = x >= 0 && x <= 3

-- смещение положение по направдению
shift :: Vec -> Pos -> Pos
shift (Vec (va, vb)) (pa, pb) = (va + pa, vb + pb)

-- направление хода
orient :: Move -> Vec
orient m = Vec $ case m of
    Up      -> (-1, 0)
    Down    -> (1 , 0)
    Left    -> (0 ,-1)
    Right   -> (0 , 1)

-- метка для пустой фишки
emptyLabel :: Label
emptyLabel = 15
\end{code}

<p>Маленькие функции \In{within}, \In{shift}, \In{orient}, \In{emptyLabel} делают как раз то, что подписано в комментариях. Думаю, что их определение не сложно понять. Но есть одна тонкость, поскольку в функции \In{orient} мы пользуемся конструкторами \In{Left} и \In{Right} необходимо спрятать тип \In{Either} из \In{Prelude}. Мы ввели дополнительный тип \In{Vec} для обозначения смещения, чтобы случайно не подставить вместо него индексы.</p>
<p>Разберёмся с функцией \In{move}. Сначала мы вычисляем положение фишки, которая пойдёт на пустое место \In{id'}. Мы делаем это, сместив (\In{shift}) положение пустышки (\In{id}) по направлению хода (\In{orient a}).</p>
<p>Мы обновляем массив, который описывает доску с помощью специальной функции \In{//}. Посмотрим на её тип:</p>

\begin{code}
(//) :: Ix i => Array i a -> [(i, a)] -> Array i a
\end{code}

<p>Она принимает массив и список обновлений в этом массиве. Обновления представлены в виде пары индекс-значение. В охранном выражении мы проверяем, если индекс перемещаемой фишки в пределах доски, то мы возвращаем новое положение, в котором пустышка уже находится в положении \In{id'} и массив обновлён. Мы составляем список обновлений \In{updates} bз двух элементов, это перемещения фишки и пустышки. Если же фишка за пределами доски, то мы возвращаем исходное положение.</p>
<h4 id="перемешиваем-фишки">Перемешиваем фишки</h4>
<p>Игра начинается с такого положения, в котором все фишки перемешаны. Но перемешивать фишки произвольным образом было бы не честно, поскольку известно, что в пятнашках половина расстановок не приводит к выигрышу. Поэтому мы будем перемешивать так: мы стартуем из начального положения и делаем несколько ходов произвольным образом. Количество ходов определяет сложность игры:</p>

\begin{code}
shuffle :: Int -> IO Game
shuffle n = (iterate (shuffle1 =<<) $ pure initGame) !! n

shuffle1 :: Game -> IO Game
shuffle1 = un
\end{code}

<p>Функция \In{shuffle1} перемешивает фишки один раз. С помощью функции \In{iterate} мы строим список расстановок, которые мы получаем на каждом шаге перемешивания. В самом конце мы выбираем из списка \In{n}-тую позицию. Обратите внимание на то, что мы не можем просто написать:</p>

\begin{code}
iterate shuffle1 initGame
\end{code}

<p>Так у нас не совпадут типы. Для функции \In{iterate} нужно чтобы вход и выход функции имели одинаковые типы. Поэтому мы пользуемся в функции \In{iterate} методами классов \In{Monad} и \In{Applicative} (глава 6).</p>
<p>Теперь определим функцию \In{shuffle1}. Мы делаем ход в текущей позиции, который мы выбрали случайным образом из списка доступных ходов. Выбором случайного элемента из списка, будет заниматься функция \In{randomElem}, а функция \In{nextMoves} будет возвращать список доступных ходов для данного положения:</p>

\begin{code}
shuffle1 :: Game -> IO Game
shuffle1 g = flip move g <$> (randomElem $ nextMoves g)

randomElem :: [a] -> IO a
randomElem = un

nextMoves :: Game -> [Move]
nextMoves = un
\end{code}

<p>Нам осталось определить всего две функции, и всё готово для игры. Определим выбор случайного элемента из списка:</p>

\begin{code}
import System.Random
...

randomElem :: [a] -> IO a
randomElem xs = (xs !! ) <$> randomRIO (0, length xs - 1)
\end{code}

<p>Мы генерируем случайное число в диапазоне индексов списка и затем извлекаем элемент. Теперь функция определения ходов в текущем положении:</p>

\begin{code}
nextMoves g = filter (within . moveEmptyTo . orient) allMoves
    where moveEmptyTo v = shift v (emtyField g)
          allMoves = [Up, Down, Left, Right]
\end{code}

<p>Мы выполняем схожие операции с теми, что были в функции \In{move}. Мы фильтруем из списка всех ходов те, что выводят пустую фишку за пределы доски.</p>
<h4 id="отображение-положения">Отображение положения</h4>
<p>Я немного поторопился, нам осталась ещё одна функция. Это отображение позиции. Я не буду подробно останавливаться на теле функции, скажу лишь то, что она составляет строку так как это показано в комментарии к функции.</p>

\begin{code}
--  +----+----+----+----+
--  |  1 |  2 |  3 |  4 |
--  +----+----+----+----+
--  |  5 |  6 |  7 |  8 |
--  +----+----+----+----+
--  |  9 | 10 | 11 | 12 |
--  +----+----+----+----+
--  | 13 | 14 | 15 |    |
--  +----+----+----+----+
--
instance Show Game where
    show (Game _ board) = "\n" ++ space ++ line ++
        (foldr (\a b -> a ++ space ++ line ++ b) "\n" $ map column [0 .. 3])
        where post id = showLabel $ board ! id 
              showLabel n  = cell $ show $ case n of
                        15 -> 0
                        n  -> n+1
              cell "0"   = "    "
              cell [x]   = ' ':' ': x :' ':[]
              cell [a,b] = ' ': a : b :' ':[] 
              line = "+----+----+----+----+\n"
              nums = ((space ++ "|") ++ ) . foldr (\a b -> a ++ "|" ++ b) "\n". 
                        map post
              column i = nums $ map (\x -> (i, x)) [0 .. 3]
              space = "\t"
\end{code}

<p>Теперь мы можем загрузить модуль \In{Loop} в интерпретатор и набрать \In{play}. Немного отвлечёмся и поиграем.</p>

\begin{code}
Prelude> :l Loop
[1 of 2] Compiling Game             ( Game.hs, interpreted )
[2 of 2] Compiling Loop             ( Loop.hs, interpreted )
Ok, modules loaded: Loop, Game.
*Loop> play
Привет! Это игра пятнашки

	+----+----+----+----+
	|  1 |  2 |  3 |  4 |
	+----+----+----+----+
	|  5 |  6 |  7 |  8 |
	+----+----+----+----+
	|  9 | 10 | 11 | 12 |
	+----+----+----+----+
	| 13 | 14 | 15 |    |
	+----+----+----+----+
Возможные ходы пустой клетки:
   left     или l       -- налево
   right    или r       -- направо
   up       или u       -- вверх
   down     или d       -- вниз
Другие действия:
   new int  или n int -- начать новую игру, int - целое число,
указывающее на сложность
   quit     или q      -- выход из игры
Начнём новую игру?
Укажите сложность (положительное целое число): 
5
	+----+----+----+----+
	|  1 |  2 |  3 |  4 |
	+----+----+----+----+
	|  5 |  6 |  7 |  8 |
	+----+----+----+----+
	|  9 |    | 10 | 11 |
	+----+----+----+----+
	| 13 | 14 | 15 | 12 |
	+----+----+----+----+

Ваш ход: 
r
	+----+----+----+----+
	|  1 |  2 |  3 |  4 |
	+----+----+----+----+
	|  5 |  6 |  7 |  8 |
	+----+----+----+----+
	|  9 | 10 |    | 11 |
	+----+----+----+----+
	| 13 | 14 | 15 | 12 |
	+----+----+----+----+

Ваш ход: 
r
	+----+----+----+----+
	|  1 |  2 |  3 |  4 |
	+----+----+----+----+
	|  5 |  6 |  7 |  8 |
	+----+----+----+----+
	|  9 | 10 | 11 |    |
	+----+----+----+----+
	| 13 | 14 | 15 | 12 |
	+----+----+----+----+

Ваш ход: 
d
	+----+----+----+----+
	|  1 |  2 |  3 |  4 |
	+----+----+----+----+
	|  5 |  6 |  7 |  8 |
	+----+----+----+----+
	|  9 | 10 | 11 | 12 |
	+----+----+----+----+
	| 13 | 14 | 15 |    |
	+----+----+----+----+

Игра окончена.
\end{code}

<p>Ураа, получилось. Мы так долго писали программу, проверяя лишь типы, и в самом конце, когда мы закончили определение, всё работает. Конечно не всё работает так гладко, я уже написал эту программу и объясняю готовое решение, но когда общая схема программы утряслась, возможные ошибки определяются на раз. Мы могли вызвать отображение позиции не в том порядке или забыть проверку конца игры, всё это несколько строчек изменений.</p>
<p>Самые неприятные ошибки происходят, когда в середине выясняется, что мы ошиблись с типами. Типы, которые мы выбрали не могут описать явление, возможно мы не можем делать какие-то операции, которые нам, как неожиданно выяснилось, очень нужны. Это значит, что нужно менять каркас. Менять каркас, это значит сносить весь дом и строить новый. Возможно разрушения окажутся локальными, мы строим не дом, а город. И сносить придётся не всё, а несколько кварталов. Но это тоже большие перемены. Поэтому шаг определения типов очень важен. Впрочем сносить кварталы в Haskell одно удовольствие, посольку стоит нам изменить какой-нибудь тип, например убрать какой-нибудь тип или изменить имя, компилятор тут же подскажет нам какие функции стали бессмысленными. Более коварные изменения связаны с добавлением конструктора-альтернативы. Например нам вдруг не понравился тип \In{Bool} и мы решили сделать его более человечным. Мы решили добавить ещё одно значение:</p>

\begin{code}
data Bool = True | False | IDonTKnow
\end{code}

<p>Это может привести к неполному рассмотрению альтернатив в \In{case}-выражениях и сопоставлениях с образцом в аргументах функции. Такие ошибки крайн неприятны, поскольку они происходят на этапе выполнения программы, когда новое значение \In{IDonTKnow} дойдёт до \In{case}. В этом случае нам на выручку может прийти функция свёртки, если мы вместе с типом изменим и функцию свёртки, это скажется на всех функциях, которые были определены через неё. Чем больше таких функций, тем больше ошибок мы поймаем.</p>
<h2 id="упражнения">Упражнения</h2>
<ul>
<li><p>Измените диалог с пользователем. Сделайте так чтобы у игры было главное меню, в котором игрок выбирает разные побочные функции, вроде выхода, начать новую игру, подсказка и игровое меню, в котором игрок только передвигает фишки. Когда игрок собирает игру он попадает в главное меню.</p></li>
<li><p>Добавьте в игру подсчёт статистики. Если игрок дошёл до победной позиции он узнаёт за сколько ходов ему удалось решить задачу. Также ведётся история предыдущих попыток, по которой пользователь может следить как изменяются его результаты.</p></li>
<li><p>Подумайте можно ли выделить интерфейс игры в отдельный класс так, чтобы модуль \In{Loop} не зависел от конкретной реализации игры. Чтобы можно было, опираясь на абстрактные методы, вроде \In{show} для \In{Game}, или реакции на ход, вести диалог с пользователем. Попробуйте переписать игру пятнашки с помощью такого класса.</p></li>
<li><p>Попробуйте написать другую игру, например игру раскладывания пасьянса, крестики-нолики или шашки, не меняя модуля \In{Loop}. Так чтобы вы сделали необходимые экземпляры для классов из предыдущего упражнения, а всё остальное поведение следовало из них.</p></li>
</ul>
</body>
</html>
