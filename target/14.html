<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<!-- Switch escape character to ? to escape |  -->







<h1 id="лямбда-исчисление">Лямбда-исчисление</h1>
<p>В этой главе мы узнаем о лямбда-исчислении. Лямбда-исчисление описывает понятие алгоритма. Ещё до появления компьютеров в 30-е годы двадцатого века математиков интересовал вопрос о возможности создания алгоритма, который мог бы на основе заданных аксиом дать ответ о том верно или нет некоторое логическое высказывание. Например у нас есть базовые утверждения и логические связки такие как “и”, “или”, “для любого из”, “существует один из”, с помощью которых мы можем строить из базовых высказываний составные. Некоторые из них окажутся ложными, а другие истинными. Нам интересно узнать какие. Но для решения этой задачи прежде всего необходимо было понять а что же такое алгоритм?</p>
<p>Ответ на этот вопрос дали Алонсо Чёрч (Alonso Church) и Алан Тьюринг (Alan Turing). Чёрч разработал лямбда-исчисление, а Тьюринг теорию машин Тьюринга. Оказалось, что задача автоматического определения истинности формул в общем случае не имеет решения.</p>
<p>В основе лямбда-исчисление лежит понятие функции. Мы можем составлять сложные функции из простейших, а также подставлять в функции аргументы, которые могут быть как константами так и другими функциями. Как только мы составили выражение мы можем передать его вычислителю. Он подставляет аргументы в функции и возвращает такое выражение, в котором невозможно далее проводить подстановки аргументов. Этот процесс проведения подстановок считается вычислением алгоритма.</p>
<p>В рамках теории машин Тьюринга алгоритм описывается по-другому. Машина Тьюринга имеет внутреннее состояние, Состояние содержит некоторое значение, которое изменяется по ходу работы машины. Машина живёт не сама по себе, она читает ленту символов. Лента символов – это большая цепочка букв. На каждую букву машина реагирует серией действий. Она может изменить значение состояния, обновить букву в ленте или перейти к следующему или предыдущему символу. Есть состояния, которые обозначают конец работы, они называются терминальными. Как только машина дойдёт до терминального состояния мы считаем, что вычисление алгоритма закончилось. После этого мы можем считать результат из состояний машины.</p>
<p>Функциональные языки программирования основаны на лямбда-исчислении. Поэтому мы будем говорить именно об этом описании алгоритма.</p>
<h2 id="лямбда-исчисление-без-типов">Лямбда исчисление без типов</h2>
<h3 id="составление-термов">Составление термов</h3>
<p>Можно считать, что лямбда исчисление это такой маленький язык программирования. В нём есть множество символов, которые считаются переменными, они что-то обозначают и неделимы. В лямбда-исчислении программный код называется термом. Для написания программного кода у нас есть всего три правила:</p>
<ul>
<li><p>Переменные <span class="math"><em>x</em></span>, <span class="math"><em>y</em></span>, <span class="math"><em>z</em></span> … являются термами.</p></li>
<li><p>Если <span class="math"><em>M</em></span> и <span class="math"><em>N</em></span> – термы, то <span class="math">(<em>M</em><em>N</em>)</span> – терм.</p></li>
<li><p>Если <span class="math"><em>x</em></span> – переменная, а <span class="math"><em>M</em></span> – терм, то <span class="math">$(\lambda x \D M)$</span> – терм</p></li>
</ul>
<p>В формальном описании добавляют ещё одно правило, оно говорит о том, что других термов нет. Первое правило, говорит о том, что у нас есть алфавит символов, который что-то обозначает, эти символы являются базовыми строительными блоками программы. Второе и третье правила говорят о том как из базовых элементов получаются составные. Второе правило – это правило применения функции к аргументу. В нём <span class="math"><em>M</em></span> обозначает функцию, а <span class="math"><em>N</em></span> обозначает аргумент. Все функции являются функциями одного аргумента, но они могут принимать и возвращать функции. Поэтому применение трёх аргументов к функции <span class="math"><em>F</em><em>u</em><em>n</em></span> будет выглядеть так:</p>
<p><br /><span class="math">(((<em>F</em><em>u</em><em>n</em> <em>A</em><em>r</em><em>g</em>1) <em>A</em><em>r</em><em>g</em>2) <em>A</em><em>r</em><em>g</em>3)</span><br /></p>
<p>Третье правило говорит о том как создавать функции. Специальный символ лямбда (<span class="math"><em>λ</em></span>) в выражении <span class="math">$(\lambda x \D M)$</span> говорит о том, что мы собираемся определить функцию с аргументом <span class="math"><em>x</em></span> и телом функции <span class="math"><em>M</em></span>. С такими функциями мы уже сталкивались. Это безымянные функции. Приведём несколько примеров функций. Начнём с самого простого, определим тождественную функцию:</p>
<p><br /><span class="math">$(\lambda x \D x)$</span><br /></p>
<p>Функция принимает аргумент <span class="math"><em>x</em></span> и тут же возвращает его в теле. Теперь посмотрим на константную функцию:</p>
<p><br /><span class="math">$(\lambda x \D (\lambda y \D x))$</span><br /></p>
<p>Константная функция является функцией двух аргументов, поэтому наш терм принимает переменную <span class="math"><em>x</em></span> и возвращает другой терм функцию <span class="math">$(\lambda y \D x)$</span>. Эта функция принимает <span class="math"><em>y</em></span>, а возвращает \In{x}. В Haskell мы бы написали это так:</p>

\begin{code}
\x -> (\y -> x)
\end{code}

<p>Точка сменилась на стрелку, а лямбда потеряла одну ножку. Теперь определим композицию. Композиция принимает две функции одного аргумента и направляет выход второй функции на вход первой:</p>
<p><br /><span class="math">$(\lambda f \D (\lambda g \D (\lambda x \D (f(gx)))))$</span><br /></p>
<p>Переменные <span class="math"><em>f</em></span> и <span class="math"><em>g</em></span> – это функции, которые участвуют в композиции, а <span class="math"><em>x</em></span> это вход результирующей функции. Уже в таком простом выражении у нас пять скобок на конце. Давайте введём несколько соглашений, которые облегчат написание термов:</p>
<table>
<col width="32%" />
<col width="30%" />
<col width="31%" />
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Пишем</th>
<th align="left">Подразумеваем</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Опустим внешние скобки:</td>
<td align="left"><span class="math">$\lambda x \D x$</span></td>
<td align="left"><span class="math">$(\lambda x \D x)$</span></td>
</tr>
<tr class="even">
<td align="left">В применении группируем скобки влево:</td>
<td align="left"><span class="math"><em>f</em><em>g</em><em>h</em><em>x</em></span></td>
<td align="left"><span class="math">((<em>f</em><em>g</em>)<em>h</em>)<em>x</em></span></td>
</tr>
<tr class="odd">
<td align="left">Ф функциях группируем скобки вправо:</td>
<td align="left"><span class="math">$\lambda x\D \lambda y\D x$</span></td>
<td align="left"><span class="math">$(\lambda x \D (\lambda y \D x))$</span></td>
</tr>
<tr class="even">
<td align="left">Пишем функции нескольких аргументов с одной лямбдой:</td>
<td align="left"><span class="math">$\lambda xy \D x$</span></td>
<td align="left"><span class="math">$(\lambda x \D(\lambda y \D x))$</span></td>
</tr>
</tbody>
</table>
<p>С этими соглашениями мы можем переписать терм для композиции так:</p>
<p><br /><span class="math">$\lambda f g x \D f(gx)$</span><br /></p>
<p>Сравните с выражением на языке Haskell:</p>

\begin{code}
\f g x -> f (g x)
\end{code}

<p>Выражения очень похожи. Haskell иногда называют засахаренной версией лямбда исчисления. В лямбда-исчислении мы не будем ставить пробелы для применения аргументов к функции. Мы будем считать, что все имена однобуквенные. При этом переменные мы будем писать с маленькой буквы, а составные термы с большой.</p>
<p>Определим ещё несколько функций. Например так выглядит функция \In{flip}:</p>
<p><br /><span class="math">$\lambda fxy \D fyx$</span><br /></p>
<p>Или можно записать в более явном виде, выделим функцию двух аргументов:</p>
<p><br /><span class="math">$\lambda f \D \lambda xy \D fyx$</span><br /></p>
<p>Определим функцию \In{on}, она принимает функцию двух аргументов <span class="math"> * </span> и функцию одного аргумента <span class="math"><em>f</em></span>, а возвращает функцию двух аргументов, в которой к аргументам сначала применяется функция <span class="math"><em>f</em></span>, а затем они передаются в функцию <span class="math"> * </span>:</p>
<p><br /><span class="math">$\lambda * f \D \lambda x \D *(fx)(fx)$</span><br /></p>
<p>В лямбда-исчислении есть только префиксное применение поэтому мы написали <span class="math"> * (<em>f</em><em>x</em>)(<em>f</em><em>x</em>)</span> вместо привычного <span class="math">(<em>f</em><em>x</em>) * (<em>f</em><em>x</em>)</span>. Здесь операция <span class="math"> * </span> это не только умножение, а любая бинарная функция.</p>
<h3 id="абстракция">Абстракция</h3>
<p>Функции в лямбда-исчислении называют абстракциями. Мы берём терм <span class="math"><em>M</em></span> и параметризуем его по переменной <span class="math"><em>x</em></span> в выражении <span class="math"><em>λ</em><em>x</em>. <em>M</em></span>. При этом если в терме <span class="math"><em>M</em></span> встречается переменная <span class="math"><em>x</em></span>, то она становится связанной. Например в терме <span class="math"><em>λ</em><em>x</em>. <em>λ</em><em>y</em>. <em>x</em></span>$ Переменная <span class="math"><em>x</em></span> является <em>связанной</em>, но в терме <span class="math"><em>λ</em><em>y</em>. <em>x</em></span>, она уже не связана. Такие переменные называют <em>свободными</em>. Множество связанных переменных терма <span class="math"><em>M</em></span> мы будем обозначать <span class="math"><em>B</em><em>V</em>(<em>M</em>)</span>$ от англ.~bound variables, а множество свободных переменных мы будем обозначать <span class="math"><em>F</em><em>V</em>(<em>M</em>)</span> от англ.~free variables.</p>
<p>На интуитивном уровне процесс абстракции заключается в том, что мы смотрим на несколько частных случаев и видим в них что-то общее. Это общее мы выделяем в функцию, которая параметризована частностями. Например мы видим выражения:</p>
<p><br /><span class="math">$\lambda x \D +xx, \quad \lambda x \D *xx$</span><br /></p>
<p>И в том и в другом у нас есть функция двух аргументов <span class="math"> + </span> или <span class="math"> * </span> и мы делаем из неё функцию одного аргумента. Мы можем абстрагировать (параметризовать) это поведение в такую функцию:</p>
<p><br /><span class="math">$\lambda b\D \lambda x\D b xx$</span><br /></p>
<p>На Haskell мы бы записали это так:</p>

\begin{code}
\b -> \x -> b x x
\end{code}

<h3 id="редукция.-вычисление-термов">Редукция. Вычисление термов</h3>
<p>Процесс вычисления термов заключается в подстановке аргументов во все функции. Выражения вида:</p>
<p><br /><span class="math">$(\lambda x \D M)\ N$</span><br /></p>
<p>Заменяются на</p>
<p><br /><span class="math"><em>M</em>[<em>x</em> = <em>N</em>]</span><br /></p>
<p>Эта запись означает, что в терме <span class="math"><em>M</em></span> все вхождения <span class="math"><em>x</em></span> заменяются на терм <span class="math"><em>N</em></span>. Этот процесс называется <em>редукцией</em> терма. А выражения вида <span class="math">$(\lambda x \D M)\ N$</span> называются <em>редексами</em>. Проведём к примеру редукцию терма:</p>
<p><br /><span class="math">$(\lambda b\D \lambda x\D b xx) *$</span><br /></p>
<p>Для этого нам нужно в терме <span class="math">$(\lambda x\D b xx)$</span> заменить все вхождения переменной <span class="math"><em>b</em></span> на переменную <span class="math"> * </span>. После этого мы получим терм:</p>
<p><br /><span class="math">$\lambda x \D * xx$</span><br /></p>
<p>В этом терме нет редексов. Это означает, что он вычислен или находится в <em>нормальной форме</em>.</p>
<h4 id="alpha-преобразование"><span class="math"><em>α</em></span>-преобразование</h4>
<p>При подстановке необходимо следить за тем, чтобы у нас не появлялись лишние связывания переменных. Например рассмотрим такой редекс:</p>
<p><br /><span class="math">$(\lambda x y \D x)\ y$</span><br /></p>
<p>После подстановки за счёт совпадения имён переменных мы получим тождественную функцию:</p>
<p><br /><span class="math">$\lambda y \D y$</span><br /></p>
<p>Переменная <span class="math"><em>y</em></span> была свободной, но после подстановки стала связанной. Необходимо исключить такие случаи. Поскольку с ними получается, что имена связанных переменных в определении функции влияют на её смысл. Например смысл такого выражения</p>
<p><br /><span class="math">$(\lambda x z \D x)\ y$</span><br /></p>
<p>После подстановки будет совсем другим. Но мы всего лишь изменили обозначение локальной переменной <span class="math"><em>y</em></span> на <span class="math"><em>z</em></span>. И смысл изменился, для того чтобы исключить такие случаи пользуются переименованием переменных или <em><span class="math"><em>α</em></span>-преобразованием</em>. Для корректной работы функций необходимо следить за тем, чтобы все переменные, которые были свободными в аргументе, остались свободными и после подстановки.</p>
<h4 id="beta-редукция"><span class="math"><em>β</em></span>-редукция</h4>
<p>Процесс подстановки аргументов в функции называется <em><span class="math"><em>β</em></span>-редукцией</em>. В редексе <span class="math">$(\lambda x \D M) N$</span> вместо свободных вхождений <span class="math"><em>x</em></span> в <span class="math"><em>M</em></span> мы подставляем <span class="math"><em>N</em></span>. Посмотрим на правила подстановки:</p>
<p><br /><span class="math">$\begin{array}{l@{\ \RA\ }l}
x[x=N] &amp; N \\
y[x=N] &amp; y \\
(PQ)[x=N]   &amp; (P[x=N]\ Q[x=N]) \\
(\lambda y \D P)[x = N] &amp; (\lambda y \D P[x=N]), \quad y \notin FV(N)    \\ 
(\lambda x \D P)[x = N] &amp; (\lambda x \D P)   \\
\end{array}$</span><br /></p>
<p>Первые два правила определяют подстановку вместо переменных. Если переменная совпадает с той, на место которой мы подставляем терм <span class="math"><em>N</em></span>, то мы возвращаем терм <span class="math"><em>N</em></span>, иначе мы возвращаем переменную:</p>
<p><br /><span class="math">$\begin{array}{l@{\ \RA\ }l}
x[x=N] &amp; N \\
y[x=N] &amp; y \\
\end{array}$</span><br /></p>
<p>Подстановка применения термов равна применению термов, в которых произведена подстановка:</p>
<p><br /><span class="math">(<em>P</em><em>Q</em>)[<em>x</em> = <em>N</em>] ⇒ (<em>P</em>[<em>x</em> = <em>N</em>] <em>Q</em>[<em>x</em> = <em>N</em>])</span><br /></p>
<p>При подстановке в лямбда-функции необходимо учитывать связность переменных. Если переменная аргумента отличается от той переменной на место которой происходит подстановка, то мы заменяем в теле функции все вхождения этой переменной на <span class="math"><em>N</em></span>:</p>
<p><br /><span class="math">$(\lambda y \D P)[x = N] \Rightarrow (\lambda y \D P[x=N]), \quad y \notin FV(N)$</span><br /></p>
<p>Условие <span class="math"><em>y</em> ∉ <em>F</em><em>V</em>(<em>N</em>)</span> означает, что необходимо следить за тем, чтобы в <span class="math"><em>N</em></span> не оказалось свободной переменной с именем <span class="math"><em>y</em></span>, иначе после подстановки она окажется связанной. Если такая переменная в <span class="math"><em>N</em></span> всё-таки окажется мы проведём <span class="math"><em>α</em></span>-преобразование в терме $<span class="math">$\lambda y \D M$</span> и заменим <span class="math"><em>y</em></span> на какую-нибудь другую переменную.</p>
<p>В последнем правиле мы ничего не меняем, поскольку переменная <span class="math"><em>x</em></span> оказывается связанной. А мы проводим подстановку только вместо свободных переменных:</p>
<p><br /><span class="math">$(\lambda x \D P)[x = N] \RA (\lambda x \D P)$</span><br /></p>
<p>Отметим, что не любой терм можно вычислить, например у такого терма нет нормальной формы:</p>
<p><br /><span class="math">$(\lambda x \D x x)(\lambda x \D x x)$</span><br /></p>
<p>На каждом шаге редукции мы будем вновь и вновь возвращаться к исходному терму.</p>
<h4 id="стратегии-редукции">Стратегии редукции</h4>
<p>В главе о ленивых вычислениях нам встретились две стратегии вычисления выражений. Это вычисление по имени и вычисление по значению. Также там мы узнали о том, что ленивые вычисления это улучшенная версия вычисления по имени, в которой аргументы функций вычисляются не более одного раза.</p>
<p>Эти стратегии вычисления пришли из лямбда-исчисления. Если нам нужно избавиться от всех редексов в выражении, то с какого редекса лучше начать? В вычислении по значению (<em>аппликативная стратегия</em>) мы начинаем с самого левого редекса, который не содержит других редексов, т.е.~с самого маленького подвыражения. А в вычислении по имени (<em>нормальная стратегия</em>) мы начинаем с самого левого внешнего редекса. Левый редекс означает, что в записи выражения он находится ближе всех к началу выражения.</p>
<dl>
<dt><strong>Теорема</strong> (Карри)</dt>
<dd>Если у терма есть нормальная форма, то последовательное сокращение самого левого внешнего редекса приводит к ней.
</dd>
</dl>
<p>Эта теорема говорит о том, что стратегия вычисления по имени может вычислить все термы, которые имеют нормальную форму. В том, что вычисление по значению может не справиться с некоторыми такими термами мы можем на следующем примере:</p>
<p><br /><span class="math">$(\lambda x y \D x)\ z\ ((\lambda x \D xx) (\lambda x \D xx))$</span><br /></p>
<p>Этот терм имеет нормальную форму <span class="math"><em>z</em></span> несмотря на то, что мы передаём вторым аргументом в константную функцию терм, у которого нет нормальной формы. Алгоритм вычисления по значению зависнет при вычислении второго аргумента. В то время как алгоритм вычисления по имени начнёт с самого внешнего терма и там определит, что второй аргумент не нужен.</p>
<p>Ещё один важный результат в лямбда-исчислении был сформулирован в следующей теореме:</p>
<dl>
<dt><strong>Теорема</strong> (Чёрча-Россера)</dt>
<dd>Если терм <span class="math"><em>X</em></span> редуцируется к термам <span class="math"><em>Y</em><sub>1</sub></span> и <span class="math"><em>Y</em><sub>2</sub></span>, то существует терм <span class="math"><em>L</em></span>, к которому редуцируются и терм <span class="math"><em>Y</em><sub>1</sub></span> и терм <span class="math"><em>Y</em><sub>2</sub></span>.
</dd>
</dl>
<p>Эта теорема говорит о том, что у терма может быть только одна нормальная форма. Поскольку если бы их было две, то существовал третий терм, к которому можно было бы редуцировать эти нормальные формы. Но по определению нормальной формы, мы не можем её редуцировать. Из этого следует, что нормальные формы должны совпадать.</p>
<p>Теорема Чёрча-Россера указывает на способ сравнения термов. Для того чтобы понять равны термы или нет, необходимо привести их к нормальной форме и сравнить. Если термы совпадают в нормальной форме, значит они равны.</p>
<h3 id="рекурсия.-комбинатор-неподвижной-точки">Рекурсия. Комбинатор неподвижной точки</h3>
<p>В лямбда-исчислении все функции являются безымянными. Это означает, что мы не можем в теле функции вызвать саму функции, ведь мы не можем на неё сослаться, кажется, что у нас нет возможности строить рекурсивные функции. Однако это не так. Нам на помощь придёт комбинатор неподвижной точки. По определению комбинатор неподвижной точки решает задачу: для терма <span class="math"><em>F</em></span> найти терм <span class="math"><em>X</em></span> такой, что</p>
<p><br /><span class="math"><em>F</em><em>X</em> = <em>X</em></span><br /></p>
<p>Существует много комбинаторов неподвижной точки. Рассмотрим <span class="math"><em>Y</em></span>-комбинатор:</p>
<p><br /><span class="math">$Y\ =\ \lambda f \D (\lambda x \D f(xx)) (\lambda x \D f(xx))$</span><br /></p>
<p>Убедимся в том, что для любого терма <span class="math"><em>F</em></span>, выполнено тождество: <span class="math"><em>F</em>(<em>Y</em><em>F</em>) = <em>Y</em><em>F</em></span>:</p>
<p><br /><span class="math">$YF = (\lambda x \D F(xx)) (\lambda x \D F(xx)) = 
   F (\lambda x \D F(xx)) (\lambda x \D F(xx)) = F(YF)$</span><br /></p>
<p>Так с помощью <span class="math"><em>Y</em></span>-комбинатора можно составлять рекурсивные функции.</p>
<h3 id="кодирование-структур-данных">Кодирование структур данных</h3>
<p>Вы наверное заметили, что пока мы составляли лишь обобщённые функции. Эти функции комбинируют другие функции, они не выполняют никаких действий над элементами. Что если нам захочется вычислять логические значения или воспользоваться числами?</p>
<p>Оказывается, что логические значения, числа, пары, списки и другие конструкции могут быть закодированы с помощью термов лямбда-исчисления. Тезис Чёрча утверждает, что с помощью лямбда-терма можно представить любую вычислимую числовую функцию. В 1936 году Чёрч с помощью лямбда-исчисления доказал существование неразрешимых проблем в теории чисел. Из этого следовала неразрешимость арифметики и неразрешимость исчисления логики предикатов первого порядка. Система аксиом называется разрешимой в том случае, если существует такой алгоритм, который позволяет по виду формулы определить следует ли она из заданных аксиом или нет.</p>
<p>Посмотрим как с помощью термов кодируются структуры данных. Далее для сокращения записи мы будем считать, что в лямбда исчислении можно определять синонимы с помощью знака равно. Запись <span class="math"><em>N</em> = <em>M</em></span> говорит о том, что мы дали обозначение <span class="math"><em>N</em></span> терму <span class="math"><em>M</em></span>. Этой операции нет в лямбда-исчислении, но мы будем пользоваться ею для удобства.</p>
<h4 id="логические-значения">Логические значения</h4>
<p>Суть логических значений заключается в операторе <span class="math"><em>I</em><em>f</em></span>, с помощью которого мы можем организовывать ветвление алгоритма. Есть два терма <span class="math"><em>T</em><em>r</em><em>u</em><em>e</em></span> и <span class="math"><em>F</em><em>a</em><em>l</em><em>s</em><em>e</em></span>, которые для любых термов <span class="math"><em>a</em></span> и <span class="math"><em>b</em></span>, обладают свойствами:</p>

<p>Термы <span class="math"><em>T</em><em>r</em><em>u</em><em>e</em></span>, <span class="math"><em>F</em><em>a</em><em>l</em><em>s</em><em>e</em></span> и <span class="math"><em>I</em><em>f</em></span>, удовлетворяющие таким свойствам выглядят так:</p>

<p>Проверим выполнение свойств:</p>
<p><br /><span class="math">$If\ True\ a\ b \RA (\lambda b \ x \ y \D b x y) (\lambda t\ f \D t)\ a\ b 
    \RA (\lambda t\ f \D t)\ a\ b \RA a$</span><br /></p>
<p><br /><span class="math">$If\ False\ a\ b \RA (\lambda b \ x \ y \D b x y) (\lambda t\ f \D f)\ a\ b 
    \RA (\lambda t\ f \D f)\ a\ b \RA b$</span><br /></p>
<p>Свойства выполнены. Логические константы кодируются постоянными функциями двух аргументов. Функция \In{True} возвращает первый аргумент, игнорируя второй. А функция \In{False} делает то же самое, но наоборот. В такой интерпретации логическое отрицание можно закодировать с помощью функции \In{flip}. Также мы можем выразить и другие логические операции:</p>

<p>Мы определили логические значения не конкретными значениями, а свойствами функций. Мы построили функции, которые ведут себя как логические значения. Этот способ определения напоминает, определение класса типов. Мы объявили три метода <span class="math"><em>T</em><em>r</em><em>u</em><em>e</em></span>, <span class="math"><em>F</em><em>a</em><em>l</em><em>s</em><em>e</em></span> и <span class="math"><em>I</em><em>f</em></span> и сказали, что экземпляр класса должен удовлетворять определённым свойствам, которые накладывают взаимные ограничения на методы класса. Ни один из методов не имеет смысла по отдельности, важно то как они взаимодействуют.</p>
<h4 id="натуральные-числа">Натуральные числа</h4>
<p>Оказывается, что с помощью термов лямбда исчисления можно закодировать и натуральные числа с арифметическими операциями. Мы будем кодировать числа Пеано. Для этого нам понадобится нулевой элемент и функция определения следующего элемента. Их можно закодировать так:</p>

<p>Как и в случае логических значений числа кодируются функциями двух аргументов. Число определяется по терму, подсчётом цепочки первых аргументов <span class="math"><em>s</em></span>. Например так выглядит число два:</p>
<p><br /><span class="math">$Succ\ (Succ\ Zero) \RA (\lambda nsz \D s(nsz)) (Succ\ Zero) 
    \RA \lambda sz \D s((Succ\ Zero) sz) \RA$</span><br /></p>
<p><br /><span class="math">$\lambda sz \D s((\lambda nsz \D s(nsz))\ Zero)sz \RA
   \lambda sz \D s (s(Zero\ s\ z)) \RA \lambda sz \D s(sz)$</span><br /></p>
<p>И мы получили два вхождения первого аргумента в теле функции. Определим сложение и умножение. Сложение принимает две функции двух аргументов и возвращает функцию двух аргументов.</p>
<p><br /><span class="math">$Add = \lambda\ m\ n\ s\ z \D m\ s\ (n\ s\ z)$</span><br /></p>
<p>В этой функции мы применяем <span class="math"><em>m</em></span> раз аргумент <span class="math"><em>s</em></span> к значению, в котором аргумент <span class="math"><em>s</em></span> применён <span class="math"><em>n</em></span> раз, так мы и получаем <span class="math"><em>m</em> + <em>n</em></span> применений аргумента <span class="math"><em>s</em></span>. Сложим 3 и 2:</p>
<p><br /><span class="math">$Add\ 3\ 2 \RA \lambda s\ z \D 3\ s\ (2\ s\ z) 
    \RA \lambda s\ z \D 3\ s\ (s\ (s\ z)) 
    \RA \lambda s\ z \D s\ (\ s\ (s\ (s\ (s\ z)))) \RA 5$</span><br /></p>
<p>В умножении чисел <span class="math"><em>m</em></span> и <span class="math"><em>n</em></span> мы будем <span class="math"><em>m</em></span> раз складывать число <span class="math"><em>n</em></span>:</p>
<p><br /><span class="math">$Mul = \lambda m\ n\ s\ z \D m\ (Add\ n)\ Zero$</span><br /></p>
<h3 id="конструктивная-математика">Конструктивная математика</h3>
<p>В конструктивной математике существование объекта может быть доказано только описанием алгоритма, с помощью которого можно построить объект. Например доказательство методом “от противного” отвергается.</p>
<p>Лямбда исчисление строит конструктивное описание функции. По лямбда-терму мы можем не только вычислять значения функции, но и понять как она была построена. В классической теории, функция это множество пар <span class="math">(<em>x</em>,  <em>f</em>(<em>x</em>))</span> аргумент-значение, которое обладает свойством:</p>
<p><br /><span class="math">$x = y\ \RA\ f(x) = f(y)$</span><br /></p>
<p>По этому определению мы ничего не можем сказать о внутренней структуре функции. Мы можем собирать из одних функций другие с помощью подстановки значений, но мы никак не сможем понять, что находится внутри функции. Лямбда исчисление решает эту проблему.</p>
<h3 id="расширение-лямбда-исчисления">Расширение лямбда исчисления</h3>
<p>Предположим, что мы решили написать язык программирования на основе лямбда-исчисления. Было бы очень неэффективно представлять числа с помощью чисел Пеано. Ведь у нас есть процессор и мы можем спросить у него чему равно значение и получить ответ очень быстро.</p>
<p>В этом случае пользуются расширенным лямбда исчислением. В нём два типа примитивов это переменные и константы. Для констант мы можем определять специальные правила редукции. Например мы можем дополнить исчисление константами:</p>
<p><br /><span class="math"> + ,   * ,  0,  1,  2,  . . . </span><br /></p>
<p>И ввести для них правила редукции, которые запрашивают ответ у процессора:</p>

<p>Так же мы можем определить и константы для логических значений:</p>
<p><br /><span class="math"><em>T</em><em>r</em><em>u</em><em>e</em>,  <em>F</em><em>a</em><em>l</em><em>s</em><em>e</em>,  <em>I</em><em>f</em>,  <em>N</em><em>o</em><em>t</em>,  <em>A</em><em>n</em><em>d</em>,  <em>O</em><em>r</em></span><br /></p>
<p>И определить правила редукции:</p>

<p>Такие правила называют <span class="math"><em>δ</em></span>-редукцией (дельта-редукция).</p>
<h2 id="комбинаторная-логика">Комбинаторная логика</h2>
<p>Одновременно с лямбда-исчислением развивалась комбинаторная логика. Она отличается более компактным представлением. Есть всего лишь одно правило, это применение функции к аргументу. А функции строятся не из произвольных термов, а из набора основных функций. Набор основных функций называют <em>базисом</em>.</p>
<p>Рассмотрим лямбда-термы:</p>
<p><br /><span class="math">$\lambda x \D x, \quad \lambda y \D y, \quad \lambda z \D z$</span><br /></p>
<p>Все эти термы несут один и тот же смысл. Они представляют тождественную функцию. Они равны, но с точностью до обозначений. Эта навязчивая проблема с переобозначением аргументов была решена в комбинаторной логике. Посмотрим как строятся термы:</p>
<ul>
<li><p>Есть набор переменных <span class="math"><em>x</em></span>, <span class="math"><em>y</em></span>, <span class="math"><em>z</em></span>, …. Переменная – это терм.</p></li>
<li><p>Есть две константы <span class="math"><em>K</em></span> и <span class="math"><em>S</em></span>, они являются термами.</p></li>
<li><p>Если <span class="math"><em>M</em></span> и <span class="math"><em>N</em></span> – термы, то <span class="math">(<em>M</em><em>N</em>)</span> – терм.</p></li>
<li><p>Других термов нет.</p></li>
</ul>
<p>Определены правила редукции для базисных термов:</p>

<p>В этих правилах мы пользуемся соглашением о расстановки скобок. Также как и в лямбда исчислении в применении скобки группируются влево. Когда мы пишем <span class="math"><em>K</em><em>x</em><em>y</em></span>, мы подразумеваем <span class="math">((<em>K</em><em>x</em>)<em>y</em>)</span>. Термы в комбинаторной логике принято называть комбинаторами. Редукция происходит до тех пор пока мы можем заменять вхождения базисных комбинаторов. Так если мы видим связку <span class="math"><em>K</em><em>X</em><em>Y</em></span> или <span class="math"><em>S</em><em>X</em><em>Y</em><em>Z</em></span>, где <span class="math"><em>X</em></span>, <span class="math"><em>Y</em></span>, <span class="math"><em>Z</em></span> произвольные термы, то мы можем их заменить согласно правилам редукции. Такие связки называют редексами. Если в терме нет ни одного редекса, то он находится в нормальной форме. Замену редекса принято называть <em>свёрткой</em></p>
<p>Интересно, что комбинаторы <span class="math"><em>K</em></span> и <span class="math"><em>S</em></span> совпадают с определением класса \In{Applicative} для функций:</p>

\begin{code}
instance Applicative (r->) where
    pure a r = a
    (<*>) a b r = a r (b r)
\end{code}

<p>В этом определении у функций есть общее окружение <span class="math"><em>r</em></span>, из которого они могут читать значения, так же как и в случае типа \In{Reader}. В методе \In{pure} (комбинатор <span class="math"><em>K</em></span>) мы игнорируем окружение (это константная функция), а в методе \In{<*>} (комбинатор <span class="math"><em>S</em></span>) передаём окружение в функцию и аргумент и составляем применение функции в контексте окружения \In{r} к значению, которое было получено в контексте того же окружения.</p>
<p>Вернёмся к проблеме различного представления тождественной функции в лямбда-исчислении. В комбинаторной логике тождественная функция выражается так:</p>
<p><br /><span class="math"><em>I</em> = <em>S</em><em>K</em><em>K</em></span><br /></p>
<p>Проверим, определяет ли этот комбинатор тождественную функцию:</p>
<p><br /><span class="math"><em>I</em><em>x</em> = <em>S</em><em>K</em><em>K</em><em>x</em> = <em>K</em><em>x</em>(<em>K</em><em>x</em>) = <em>x</em></span><br /></p>
<p>Сначала мы заменили <span class="math"><em>I</em></span> на его определение, затем свернули по комбинатору <span class="math"><em>S</em></span>, затем по левому комбинатору <span class="math"><em>K</em></span>. В итоге получилось, что</p>
<p><br /><span class="math"><em>I</em><em>x</em> = <em>x</em></span><br /></p>
<h3 id="связь-с-лямбда-исчислением">Связь с лямбда-исчислением</h3>
<p>Комбинаторная логика и лямбда-исчисление тесно связаны между собой. Можно определить функцию <span class="math"><em>ϕ</em></span>, которая переводит термы комбинаторной логики в термы лямбда-исчисления:</p>

<p>В первом уравнении <span class="math"><em>x</em></span> – переменная. Также можно определить функцию <span class="math"><em>ψ</em></span>, которая переводит термы лямбда-исчисления в термы комбинаторной логики.</p>

<p>Запись <span class="math">$[x]\D T$</span>, где <span class="math"><em>x</em></span> – переменная, <span class="math"><em>T</em></span> – терм, обозначает такой терм <span class="math"><em>D</em></span>, из которого можно получить терм <span class="math"><em>T</em></span> подстановкой переменной <span class="math"><em>x</em></span>, выполнено свойство:</p>
<p><br /><span class="math">$([x]\D T)\ x = T$</span><br /></p>
<p>Эта запись означает параметризацию терма <span class="math"><em>T</em></span> по переменной <span class="math"><em>x</em></span>. Терм <span class="math">$[x]\D T$</span> можно получить с помощью следующего алгоритма:</p>

<p>В первом уравнении мы заменяем переменную на тождественную функцию, поскольку переменные совпадают. Запись <span class="math"><em>V</em>(<em>X</em>)</span> во втором уравнении обозначает множество всех переменных в терме <span class="math"><em>X</em></span>. Поскольку переменная по которой мы хотим параметризовать терм (или абстрагировать) не участвует в самом терме, мы можем проигнорировать её с помощью постоянной функции <span class="math"><em>K</em></span>. В последнем уравнении мы параметризуем применение.</p>
<p>С помощью этого алгоритма можно для любого терма <span class="math"><em>T</em></span>, все переменные которого содержатся в <span class="math">{<em>x</em><sub>1</sub>, . . . <em>x</em><sub><em>n</em></sub>}</span> составить такой комбинатор <span class="math"><em>D</em></span>, что <span class="math"><em>D</em><em>x</em><sub>1</sub>. . . <em>x</em><sub><em>n</em></sub> = <em>T</em></span>. Для этого мы последовательно парметризуем терм <span class="math"><em>T</em></span> по всем переменным:</p>
<p><br /><span class="math">$[x1,...,\ x_n] \D T = [x_1] \D ([x_2, ... ,\ x_n] \D T)$</span><br /></p>
<p>Так постепенно мы придём к выражению, считаем что скобки группируются вправо:</p>
<p><br /><span class="math">$[x_1] \D [x_2] \D ... [x_n] \D T$</span><br /></p>
<h3 id="немного-истории">Немного истории</h3>
<p>Комбинаторную логику открыл Моисей Шейнфинкель. В 1920 году на докладе в Гёттингене он рассказал основные положения этой теории. Комбинаторная логика направлена на выделение простейших строительных блоков математической логики. В этом докладе появилось понятие частичного применения. Шейнфинкель показал как функции многих переменных могут быть сведены к функциям одного переменного. Далее в докладе описываются пять основных функций, называемых комбинаторами:</p>
<p><br /><span class="math">$\begin{array}{l@{\ =\ }l@{\qquad }l}
Ix      &amp; x     &amp; \text{-- функция тождества} \\
Cxy     &amp; x     &amp; \text{-- константная функция} \\
Txyz    &amp; xzy   &amp; \text{-- функция перестановки} \\
Zxyz    &amp; x(yz) &amp; \text{-- функция группировки} \\
Sxyz    &amp; xz(yz)&amp; \text{-- функция слияния} \\
\end{array}$</span><br /></p>
<p>С помощью этих функций можно избавиться в формулах от переменных, так например свойство коммутативности функции <span class="math"><em>A</em></span> можно представить так: <span class="math"><em>T</em><em>A</em> = <em>A</em></span>. Эти комбинаторы зависят друг от друга. Можно убедиться в том, что:</p>

<p>Все комбинаторы выражаются через комбинаторы <span class="math"><em>C</em></span> и <span class="math"><em>S</em></span>. Ранее мы пользовались другими обозначениями для этих комбинаторов. Обозначения <span class="math"><em>K</em></span> и <span class="math"><em>S</em></span> ввёл Хаскель Карри (Haskell Curry). Независимо от Шейнфинкеля он переоткрыл комбинаторную логику и существенно развил её. В современной комбинаторной логике для обозначения комбинаторов <span class="math"><em>I</em></span>, <span class="math"><em>C</em></span>, <span class="math"><em>T</em></span>, <span class="math"><em>Z</em></span> и <span class="math"><em>S</em></span> (по Шейнфинкелю) принято использовать имена <span class="math"><em>I</em></span>, <span class="math"><em>K</em></span>, <span class="math"><em>C</em></span>, <span class="math"><em>B</em></span>, <span class="math"><em>S</em></span> (по Карри).</p>
<h2 id="лямбда-исчисление-с-типами">Лямбда-исчисление с типами</h2>
<p>Мы можем добавить в лямбда-исчисление типы. Предположим, что у нас есть множество <span class="math"><em>V</em></span> базовых типов. Тогда тип это:</p>
<p><br /><span class="math">$T = V \Or T \Ra T$</span><br /></p>
<p>Тип может быть либо одним элементом из множества базовых типов. Либо стрелочным (функциональным) типом. Выражение “терм <span class="math"><em>M</em></span> имеет тип <span class="math"><em>α</em></span>” принято писать так: <span class="math"><em>M</em><sup><em>α</em></sup></span>. Стрелочный тип <span class="math">$\alpha \Ra \beta$</span> как и в Haskell говорит о том, что если у нас есть значение типа <span class="math"><em>α</em></span>, то с помощью операции применения мы можем из терма с этим стрелочным типом получить терм типа <span class="math"><em>β</em></span>.</p>
<p>Опишем правила построения термов в лямбда-исчислении с типами:</p>
<ul>
<li><p>Переменные <span class="math"><em>x</em><sup><em>α</em></sup></span>, <span class="math"><em>y</em><sup><em>β</em></sup></span>, <span class="math"><em>z</em><sup><em>γ</em></sup></span>, … являются термами.</p></li>
<li><p>Если <span class="math">$M^{\alpha \Ra \beta}$</span> и <span class="math"><em>N</em><sup><em>α</em></sup></span> – термы, то <span class="math">$(M^{\alpha \Ra \beta}N^\alpha)^\beta$</span> – терм.</p></li>
<li><p>Если <span class="math"><em>x</em><sup><em>α</em></sup></span> – переменная и <span class="math"><em>M</em><sup><em>β</em></sup></span> – терм, то <span class="math">$(\lambda x^\alpha \D M^\beta)^{\alpha \Ra \beta}$</span> – терм</p></li>
<li><p>Других термов нет.</p></li>
</ul>
<p>Типизация накладывает ограничение на то, какие выражения мы можем комбинировать. В этом есть плюсы и минусы. Теперь наша система является <em>строго нормализуемой</em>, это означает, что любой терм имеет нормальную форму. Но теперь мы не можем выразить все функции на числах. Например мы не можем составить <span class="math"><em>Y</em></span>-комбинатор, поскольку теперь самоприменение <span class="math">(<em>e</em><em>e</em>)</span> невозможно.</p>
<p>Мы ввели типы, но лишились рекурсии. Как нам быть? Эта проблема решается с помощью введения специальной константы <span class="math">$Y_\tau^{(\tau \Ra \tau) \Ra \tau}$</span>, которая обозначает комбинатор неподвижной точки. Правило редукции для <span class="math"><em>Y</em></span>:</p>
<p><br /><span class="math">$(Y_\tau f^{\tau \Ra \tau})^\tau = 
    (f^{\tau \Ra \tau}(Y_\tau f^{\tau \Ra \tau}))^\tau$</span><br /></p>
<p>Можно убедиться в том, что это правило роходит проверку типов. Типизированное лямбда-исчисление дополненное комбинатором неподвижной точки способно выразить все числовые функции.</p>
<h2 id="краткое-содержание">Краткое содержание</h2>
<p>В этой главе мы познакомились с лямбда-исчислением и комбинаторной логикой, двумя конструктивными теориями функций. Конструктивными в том смысле, что определение функции содержит не набор значений, а рецепт получения этих значений. В лямбда-исчислении мы видим как функция была построена, из каких простейших частей она состоит. Редукция термов позволяет вычислять функции.</p>
<p>Мы узнали, что функциями можно кодировать логические значения и числа. Узнали, что все численные функции могут быть закодированы лямбда-термами.</p>
<h2 id="упражнения">Упражнения</h2>
<ul>
<li>С помощью редукции убедитесь в том, что верны формулы (в терминах Карри) :
</li>
</ul>

<ul>
<li>Попробуйте закодировать пары с помощью лямбда термов. Вам необходимо построить три функции: <span class="math"><em>P</em><em>a</em><em>i</em><em>r</em></span>, <span class="math"><em>F</em><em>s</em><em>t</em></span>, <span class="math"><em>S</em><em>n</em><em>d</em></span>, которые обладают свойствами:</li>
</ul>

<ul>
<li><p>в комбинаторной логике тоже есть комбинатор неподвижной точки, найдите его с помощью алгоритма приведения термов лямбда исчисления к термам комбинаторной логики. Для краткости лучше вместо <span class="math"><em>S</em><em>K</em><em>K</em></span> писать просто <span class="math"><em>I</em></span>.</p></li>
<li><p>Напишите типы \In{Lam} и \In{App}, которые описывают лямбда-термы и термы комбинаторной логики в Haskell. Напишите функции перевода из значений \In{Lam} в \In{App} и обратно.</p></li>
</ul>
</body>
</html>
