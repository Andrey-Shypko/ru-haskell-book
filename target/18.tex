\chapter{Средства разработки}

В этой главе мы познакомимся с основными средствами разработки больших
программ. Мы научимся устанавливать и создавать библиотеки, писать
документацию.

\section{Пакеты}

В Haskell есть ещё один уровень организации данных, мы можем объединять
модули в \emph{пакеты} (package). Также как и модули пакеты могут
зависеть от других пакетов, если они пользуются модулями их этих
пакетов. Одним пакетом мы уже пользовались и довольно часто, это пакет
\In{base}, который содержит все стандартные модули, например такие как
\In{Prelude}, \In{Control.Applicative} или \In{Data.Function}. Для
создания и установки пакетов существует приложение \In{cabal}. Оно
определяет протокол организации и распространения модулей Haskell.

\subsection{Создание пакетов}

Предположим, что мы написали программу, которая состоит из нескольких
модулей. Пусть все модули хранятся в директории с именем \In{src}. Для
того чтобы превратить набор модулей в пакет, нам необходимо поместить в
одну директорию с \In{src} два файла:

\begin{itemize}
\item
  \In{имяПакета.cabal} -- файл с описанием пакета.
\item
  \In{Setup.hs} -- файл с инструкциями по установке пакета
\end{itemize}

\subsubsection{.cabal}

Посмотрим на простейший файл с описанием библиотеки, этот файл находится
в одной директории с той директорией, в которой содержатся все модули
приложения и имеет расширение \In{.cabal}:


\begin{code}
Name        : Foo
Version     : 1.0

Library
  build-depends     : base
  exposed-modules   : Foo
\end{code}

Сначала идут свойства пакета. Общий формат определения свойства:


\begin{code}
ИмяСвойства : Значение
\end{code}

В примере мы указали имя пакета \In{Foo}, и версию \In{1.0}. После того,
как мы указали все свойства, мы определяем будет наш пакет библиотекой
или исполняемой программой или возможно он будет и тем и другим. Если
пакет будет библиотекой, то мы помещаем за набором атрибутов слово
\In{Library}, а если это исполняемая программа, то мы помещаем слово
\In{Executable}, после мы пишем описание модулей пакета, зависимости от
других пакетов, какие модули будут видны пользователю. Формат
составления описаний в этой части такой же как и в самом начале файла.
Сначала идёт зарезервированное слово-атрибут, затем через двоеточие
следует значение. Обратите внимание на отступы за словом \In{Library},
они обязательны и сделаны с помощью \emph{пробелов}, \In{cabal} не
воспринимает табуляцию.

Файл \In{.cabal} может содержать комментарии, они делаются также как и в
Haskell, закомментированная строка начинается с двойного тире.

\subsubsection{Setup.hs}

Файл \In{Setup.hs} содержит информацию о том как устанавливается
библиотека. При установке могут использоваться другие программы и
библиотеки. Пока мы будем пользоваться простейшим случаем:


\begin{code}
import Distribution.Simple
main = defaultMain
\end{code}

Этот файл позволяет нам создавать библиотеки и приложения, которые
созданы только с помощью Haskell. Это не так уж и мало!

\subsection{Создаём библиотеки}

Типичный файл \In{.cabal} для библиотеки выглядит так:


\begin{code}
Name:           pinocchio
Version:        1.1.1
Cabal-Version:  >= 1.2
License:        BSD3
License-File:   LICENSE
Author:         Mister Geppetto
Homepage:       http://pinocchio.sourceforge.net/
Category:       AI
Synopsis:       Tools for creation of woodcrafted robots
Build-Type:     Simple


Library
  Build-Depends: base
  Hs-Source-Dirs: src/  
  Exposed-modules:
    Wood.Robot.Act, Wood.Robot.Percept, Wood.Robot.Think
  Other-Modules:
    Wood.Robot.Internals
\end{code}

Этим файлом мы описали библиотеку с именем \In{pinocchio}, версия 1.1.1,
она использует версию \In{cabal} не ниже \In{1.2}. Библиотека выпущена
под лицензией BSD3. Файл с лицензией находится в текущей директории под
именем \In{LICENSE}. Автор библиотеки \In{Mister Geppetto}. Подробнее
узнать о библиотеке можно на её домашней странице
\In{http://pinocchio.sourceforge.net/}. Атрибут \In{Category} указывает
на широкую отрасль знаний, к которой принадлежит наша библиотека. В
данном случае мы описываем библиотеку для построения роботов из дерева,
об этом мы пишем в атрибуте \In{Synopsis} (краткое описание), поэтому
наша библиотека принадлежит к категории искусственный интеллект или
сокращённо \In{AI}. Последний атрибут \In{Build-Type} указывает на тип
сборки пакета. Мы будем пользоваться значением \In{Simple}, который
соответствует сборке с помощью простейшего файла \In{Setup.hs}, который
мы рассмотрели в предыдущем разделе.

После описания пакета, идёт слово \In{Library}, ведь мы создаём
библиотеку. Далее в атрибуте \In{Build-Depends}\\мы указываем
зависимости для нашего пакета. Здесь мы перечисляем все пакеты, которые
мы используем в своей библиотеке. В данном случае мы пользовались лишь
стандартной библиотекой \In{base}. В атрибуте \In{hs-source-dirs} мы
указываем, где искать директорию с исходным кодом библиотеки. Затем мы
указываем три внешних модуля, они будут доступны пользователю после
установки библиотеки (атрибут \In{Exposed-Modules}), и внутренние
скрытые модули (атрибут \In{Other-Modules}).

\subsection{Создаём исполняемые программы}

Типичный файл \In{.cabal} для исполняемой программы:


\begin{code}
Name:           micro
Version:        0.0
Cabal-Version:  >= 1.2
License:        BSD3
Author:         Tony Reeds
Synopsis:       Small programming language
Build-Type:     Simple

Executable micro
  Build-Depends:  base, parsec
  Main-Is:        Main.hs
  Hs-Source-Dirs: micro

Executable micro-repl
  Main-Is:        Main.hs
  Build-Depends:  base, parsec
  Hs-Source-Dirs: repl
  Other-Modules:  Utils
\end{code}

В этом файле мы описываем две программы. Компилятор языка и
интерпретатор языка \In{micro}. Если сравнить этот файл с файлом для
библиотеки, то мы заметим лишь один новый атрибут. Это \In{Main-Is}. Он
указывает в каком модуле содержится функция \In{main}. После установки
этого пакета будут созданы два исполняемых файла. С именами \In{micro} и
\In{micro-repl}.

\subsection{Установка пакета}

Пакеты устанавливаются с помощью команды \In{install}. Необходимо
перейти в директорию пакета, ту, в которой находятся два служебных файла
(\In{.cabal} и \In{Setup.hs}) и директория с исходниками, и запустить
команду:


\begin{code}
cabal install
\end{code}

Если мы нигде не ошиблись в описании пакета, не перепутали табуляцию с
пробелами при отступах, или указали без ошибок все зависимости, то пакет
успешно установится. Если это библиотека, то мы сможем подключать
экспортируемые ей модули в любом другом модуле, просто указав их в
директиве \In{import}. При этом нам уже не важно, где находятся модули
библиотеки. Мы имеем возможность импортировать их из любого модуля. Если
же пакет был исполняемой программой, будут созданы бинарные файлы
программ. В конце \In{cabal} сообщит нам куда он их положил.

Иногда возникают проблемы с пакетами, которые генерируют исполняемые
файлы, а затем с их помощью устанавливают другие пакеты. Проблема
возникает из-за того, что \In{cabal} может положить бинарный файл в
директорию, которая не видна следующим программам, которые хотят
продолжить установку. В этом случае необходимо либо переложить созданные
бинарные файлы в директорию, которая будет им видна, или добавить
директорию с новыми бинарными файлами в \In{PATH} (под UNIX, Linux).
Переменная операционной системы PATH содержит список всех путей, в
которых система ищет исполняемые программы, если путь не указан явно.
Посмотреть содержание \In{PATH} можно, вызвав:


\begin{verbatim}
$ echo $PATH
\end{verbatim}

Появится строка директорий, которые записаны через двоеточие. Для того
чтобы добавить директорию \In{/data/dir} в \In{PATH} необходимо
написать:


\begin{verbatim}
$ PATH=$PATH:/data/dir
\end{verbatim}

Эта команда добавит директорию в \In{PATH} для текущей сессии в
терминале, если мы хотим записать её насовсем, мы добавим эту команду в
специальный скрытый файл \In{.bashrc}, он находится в домашней
директории пользователя. Под Windows добавить директорию в \In{PATH}
можно с помощью графического интерфейса. Кликните правой кнопкой мыши на
иконку \In{My Computer} (Мой Компьютер), в появившемся меню выберите
вкладку \In{Properties} (Свойства). Появится окно \In{System Properties}
(Свойства системы), в нём выберите вкладку \In{Advanced} и там нажмите
на кнопку \In{Environment variables} (Переменные среды). И в этом окне
будет строка \In{Path}, её мы и хотим отредактировать, добавив
необходимые нам пути.

Давайте потренируемся и создадим библиотеку и исполняемую программу.
Создадим библиотеку, которая выводит на экран \In{Hello World}. Создадим
директорию \In{hello}, и в ней создадим директорию \In{src}. Эта
директория будет содержать исходный код. Главный модуль библиотеки
экспортирует функцию приветствия:


\begin{code}
module Hello where

import Utility.Hello(hello)
import Utility.World(world)

helloWorld = hello ++ ", " ++ world ++ "!"
\end{code}

Главный модуль программы \In{Main.hs} определяет функцию \In{main},
которая выводит текст приветствия на экран:


\begin{code}
module Main where

import Hello 

main = print helloWorld
\end{code}

У нас будет два внутренних модуля, каждый из которых определяет синоним
для одного слова. Мы поместим их в папку \In{Utility}. Это модуль
\In{Utility.Hello}


\begin{code}
module Utility.Hello where
hello = "Hello"
\end{code}

И модуль \In{Utility.World}:


\begin{code}
module Utility.World where
world = "World"
\end{code}

Исходники готовы, теперь приступим к описанию пакета. Создадим в
корневой директории пакета файл \In{hello.cabal}.


\begin{code}
Name:           hello
Version:        1.0
Cabal-Version:  >= 1.2
License:        BSD3
Author:         Anton
Synopsis:       Little example of cabal usage
Category:       Example
Build-Type:     Simple

Library
  Build-Depends: base == 4.*
  Hs-Source-Dirs: src/
  Exposed-modules:
    Hello
  Other-Modules:
    Utility.Hello
    Utility.World

Executable hello
  Build-Depends: base == 4.*
  Main-Is: Main.hs
  Hs-Source-Dirs: src/
\end{code}

В этом файле мы описали библиотеку и программу. В строке
\In{base == 4.*} мы указали версию пакета \In{base}. Запись \In{4.*}
означает любая версия, которая начинается с четвёрки. Осталось только
поместить в корневую директорию пакета файл \In{Setup.hs}.


\begin{code}
import Distribution.Simple
main = defaultMain
\end{code}

Теперь мы можем переключиться на корневую директорию пакета и установить
пакет:


\begin{code}
anton@anton-desktop:~/haskell-notes/code/ch-17/hello$ cabal install
Resolving dependencies...
Configuring hello-1.0...
Preprocessing library hello-1.0...
Preprocessing executables for hello-1.0...
Building hello-1.0...
[1 of 3] Compiling Utility.World    ( src/Utility/World.hs, dist/build/Utility/World.o )
[2 of 3] Compiling Utility.Hello    ( src/Utility/Hello.hs, dist/build/Utility/Hello.o )
[3 of 3] Compiling Hello            ( src/Hello.hs, dist/build/Hello.o )
Registering hello-1.0...
[1 of 4] Compiling Utility.World    ( src/Utility/World.hs, dist/build/hello/hello-tmp/Utility/World.o )
[2 of 4] Compiling Utility.Hello    ( src/Utility/Hello.hs, dist/build/hello/hello-tmp/Utility/Hello.o )
[3 of 4] Compiling Hello            ( src/Hello.hs, dist/build/hello/hello-tmp/Hello.o )
[4 of 4] Compiling Main             ( src/Main.hs, dist/build/hello/hello-tmp/Main.o )
Linking dist/build/hello/hello ...
Installing library in /home/anton/.cabal/lib/hello-1.0/ghc-7.4.1
Installing executable(s) in /home/anton/.cabal/bin
Registering hello-1.0...
\end{code}

Мы видим сообщения о процессе установки. После установки в текущей
директории пакета появилась директория \In{dist}, в которую были
помещены скомпилированные файлы библиотеки. В последних строках
\In{cabal} сообщил нам о том, что он установил библиотеку в директорию:


\begin{code}
Installing library in /home/anton/.cabal/lib/hello-1.0/ghc-7.4.1
\end{code}

\noindent 

и исполняемый файл в директорию:


\begin{code}
Installing executable(s) in /home/anton/.cabal/bin
\end{code}

С помощью различных флагов мы можем контролировать процесс установки
пакета. Назначать дополнительные директории, указывать куда поместить
скомпилированные файлы. Подробно об этом можно почитать в справке,
выполнив в командной строке одну из команд:


\begin{code}
cabal --help
cabal install --help
\end{code}

Если у вас не получилось сразу установить пакет не отчаивайтесь и
почитайте сообщения об ошибках из \In{cabal}, он информативно жалуется о
забытых зависимостях и неспособности правильно прочитать файл с
описанием пакета.

\subsection{Удаление библиотеки}

Установленные с помощью \In{cabal} файлы видны из любого модуля. Имена
модулей регистрируются глобально. Если нам захочется установить
библиотеку с уже зарегистрированным именем, произойдёт хаос. Возможно
прежняя библиотека нам уже не нужна. Как нам удалить её? Посмотрим на
решение для компилятора ghc. Мы можем посмотреть список всех
зарегистрированных в ghc библиотек с помощью команды:


\begin{verbatim}
$ ghc-pkg list
   Cabal-1.8.0.6
   array-0.3.0.1
   base-4.2.0.2
   ...
   ...
\end{verbatim}

Появится длинный список с именами библиотек. Для удаления одной из них
мы можем выполнить команду:


\begin{code}
ghc-pkg unregister имя-библиотеки
\end{code}

Например так мы можем удалить только что установленную библиотеку
\In{hello}:


\begin{verbatim}
$ ghc-pkg unregister hello
\end{verbatim}

\subsection{Репозиторий пакетов Hackage}

Если у нас подключен интернет, то мы можем воспользоваться наследием
сообщества Haskell и установить пакет с \In{Hackage}. Там расположено
много-много-много пакетов. Любой разработчик Haskell может добавить свой
пакет на \In{Hackage}. Посмотреть на пакеты можно на сайте этого
репозитория:

\begin{quote}
\url{http://hackage.haskell.org}
\end{quote}

Если для вашей задачи необходимо выполнить какую-нибудь довольно общую
задачу, например написать тип красно-чёрных деревьев или построить
парсер или возможно вам нужен веб-сервер, поищите этот пакет на
\In{Hackage}, он там наверняка окажется, ещё и в нескольких вариантах.

Для установки пакета с \In{Hackage} нужно просто написать


\begin{code}
cabal install имя-пакета
\end{code}

Возможно нам нужен очень новый пакет, который был только что залит
автором на \In{Hackage}. Тогда выполняем:


\begin{code}
cabal update
\end{code}

Происходит обновление данных о загруженных на \In{Hackage}. Что хорошо,
вы можете загрузить исходники из \In{Hackage}, например у вас никак не
получается написать пакет, который устанавливался бы без ошибок. Просто
загрузим исходники какого-нибудь пакета из \In{Hackage} и посмотрим на
пример рабочего пакета.

\subsection{Дополнительные атрибуты пакета}

В файле \In{.cabal} также часто указывают такие атрибуты как:

\begin{description}
\item[\In{Maintainer}]
Поле содержит адрес электронной почты тех.\textasciitilde{}поддержки
\item[\In{Stability}]
Статус версии библиотеки (стабильная, экспериментальная, нестабильная).
\item[\In{Description}]
Подробное описание назначения пакета. Оно помещается на главную страницу
пакета в документации.
\item[\In{Extra-Source-Files}]
В этом поле можно через пробел указать дополнительные файлы, включаемые
в пакет. Это могут быть примеры использования, описание в формате PDF
или хроника изменений и другие служебные файлы.
\item[\In{License-file}]
Путь к файлу с лицензией.
\item[\In{ghc-options}]
Флаги компиляции для GHC. Если в нашей библиотеке мы активно пользуемся
продвинутыми прагмами оптимизации, необходимо сообщить об этом
компилятору пользователя. Например, мы можем написать в этом атрибуте
\In{-O} или \In{-O2}.
\end{description}

\subsection{Установка библиотек для профилирования}

Помните когда-то мы занимались профилированием? Это было в главе,
посвящённой устройству GHC. Мы включали флаг \In{-prof} и всё шло
гладко. Там мы профилировали код, в котором участвовали лишь стандартные
библиотеки из пакета \In{base}, такие как \In{Prelude}. Но если мы
попробуем профилировать код с какими-нибудь другими библиотеками,
установленными с помощью \In{cabal}, GHC возмутится и скажет, что для
профилирования не хватает специальной версии библиотеки \In{имярек}. Для
того чтобы иметь возможность профилировать код, в котором участвуют
другие библиотеки необходимо установить их с возможностью
профилирования. Это делается при установке с помощью специального флага
\In{--``enable-library-profiling} или
\In{--``enable-executable-profiling} (если мы устанавливаем исполняемое
приложение):


\begin{verbatim}
$ cabal install имярек --reinstall --enable-library-profiling
\end{verbatim}

Библиотека будет установлена в двух экземплярах: для исполнения и
профилирования. Возможно библиотека \In{имярек} потребует переустановки
некоторых библиотек, от которых она зависит. Повторяем эту процедуру для
этих библиотек и возвращаемся к исходной библиотеке. К сожалению,
избежать переустановки библиотек нельзя. Но мы можем сделать так, чтобы
все будущие библиотеки устанавливались с возможностью профилирования.
Для этого необходимо отредактировать файл настроек программы \In{cabal}.
Ищем директори, в которой \In{cabal} хранит свои служебные файлы. Если
вы пользуетесь Linux, то скорее всего это скрытая директория \In{.cabal}
в вашей домашней директории. Если вы пользуетесь Windows, положение
директории зависит от версии системы. Но ничего, узнать её положение
можно, выполнив в \In{ghci}


\begin{code}
Prelude> :m System.Directory
Prelude System.Directory> getAppUserDataDirectory "cabal"
\end{code}

Присмотритесь к этой директории в ней вы найдёте много полезных данных.
В ней находятся исполняемые программы, скомпилированные библиотеки, а
также исходный код библиотек. В этой директории находится и файл
\In{config} с настройками для \In{cabal}. Ищем строчку с полем
\In{library-profiling: False}. Меняем значение на \In{True} и
раскомментируем эту строчку, если она закомментирована. После этого
\In{cabal install} будет устанавливать библиотеки для профилирования. На
первых порах это вызовет массу неудобств из-за необходимости
переустановки многих библиотек.

\section{Создание документации с помощью Haddock}

Если мы зайдём на Hackage, то там мы увидим длинный список пакетов,
отсортированных по категориям. К какой категории какой пакет относится
мы указываем в \In{.cabal}-файле в атрибуте \In{Category}. Далее рядом с
именем пакета мы видим краткое описание, оно берётся из атрибута
\In{Synopsis}. Если мы зайдём на страницу одного из пакетов, то там мы
увидим страницу в таком же формате, что и документация к стандартным
библиотекам. Мы видим описание пакета и ниже иерархию модулей. Мы можем
зайти в заинтересовавший нас модуль и посмотреть на объявленные функции,
типы и классы. В самом низу страницы находится ссылка к исходникам
пакета.

``Домашняя страница'' пакета была создана с помощью приложения
\In{Haddock}. Оно генерирует документацию в формате \In{html} по
специальным комментариям. \In{Haddock} встроен в \In{cabal}, например мы
можем сделать документацию к нашему пакету \In{hello}. Для этого нужно
переключиться на корневую директорию пакета и вызвать:


\begin{code}
cabal haddock
\end{code}

После этого в директории \In{dist} появится директория \In{doc}, в
которой внутри директории \In{html} находится созданная документация. Мы
можем открыть файл \In{index.html} и там мы увидим ``иерархию нашего''
модуля. В модуле пока нет ни одной функции, так получилось потому, что
\In{Haddock} помещает в документацию лишь те функции, у которых есть
объявление типа. Если мы добавим в модуле \In{Hello.hs}: к единственной
функции объявление типа:


\begin{code}
helloWorld :: String
helloWorld = hello ++ ", " ++ world ++ "!"
\end{code}

И теперь перезапустим \In{haddock}. То мы увидим, что в модуле
\In{Hello} появилась одна запись.

\subsection{Комментарии к определениям}

Прокомментировать любое определение можно с помощью комментария
следующего вида:


\begin{code}
-- | Here is the comment
helloWorld :: String
helloWorld = hello ++ ", " ++ world ++ "!"
\end{code}

Обратите внимание на значок ``или'', сразу после комментариев. Этот
комментарий будет включен в документацию. Также можно писать комментарии
после определения для этого к комментарию добавляется значок степени:


\begin{code}
helloWorld :: String
helloWorld = hello ++ ", " ++ world ++ "!"
-- ^ Here is the comment
\end{code}

К сожалению на момент написания этих строк \In{Haddock} может включать в
документацию лишь латинские символы. Комментарии могут простираться
несколько строк:


\begin{code}
-- | Here is the type.
-- It contains three elements.
-- That's it.
data T = A | B | C
\end{code}

Также они могут быть блочными:


\begin{code}
{-|
   Here is the type.
   It contains three elements.
   That's it.
 -}
data T = A | B | C
\end{code}

Мы можем комментировать не только определение целиком, но и отдельные
части. Например так мы можем пояснить отдельные аргументы у функции:


\begin{code}
add :: Num a => a   -- ^ The first argument
             -> a   -- ^ The second argument   
             -> a   -- ^ The return value   
\end{code}

Методы класса и отдельные конструкторы типа можно комментировать как
обычные функции:


\begin{code}
data T
        -- | constructor A    
       = A      
        -- | constructor B
       | B      
        -- | constructor C
       | C     
\end{code}

Или так:


\begin{code}
data T = A      -- ^ constructor A
       | B      -- ^ constructor B
       | C      -- ^ and so on
\end{code}

Комментарии к классу:


\begin{code}
-- | С-class
class С a where
    -- | f-function
    f :: a -> a
    -- | g-function
    g :: a -> a
\end{code}

\subsection{Комментарии к модулю}

Комментарии к модулю помещаются перед объявлением имени модуля. Эта
информация попадёт в самое начало страницы документации:


\begin{code}
-- | Little example
module Hello where
\end{code}

\subsection{Структура страницы документации}

Если модуль большой, то его бывает удобно разделить на части, словно
разделы в главе книги. Определения группируются по функциональности и
помещаются в разные разделы или даже подразделы. Структура документации
определяется с помощью специальных комментариев в экспорте модуля.
Посмотрим на пример:


\begin{code}
-- | Little example
module Hello(
    -- * Introduction
    -- | Here is the little example to show you
    -- how to make docs with Haddock
    
    -- * Types
    -- | The types.
    T(..),
    -- * Classes
    -- | The classes.
    C(..),
    -- * Functions
    helloWorld
    -- ** Subfunctions1
    -- ** Subfunctions2    
) where

...
\end{code}

Комментарии со звёздочкой создают раздел, а с двумя звёздочками --
подраздел. Те определения, которые экспортируются за комментариями со
звёздочкой попадут в один раздел или подраздел. Если сразу за
комментарием со звёздочкой идёт комментарий со знаком ``или'', то он
будет помещён в самое начало раздела. В нём мы можем пояснить по какому
принципу группируются определения в данном разделе.

\subsection{Разметка}

С помощью специальных символов можно выделять различные элементы текста,
например, ссылки, куски кода, названия определений или модулей.
\In{Haddock} установит необходимые ссылки и выделит элемент в
документации.

При этом символы \In{}\verb!\!\In{}, \In{'}, \In{`}, \In{}\verb!"!\In{},
\In{@}, \In{<} являются специальными, если вы хотите воспользоваться
одним из специальных символов в тексте необходимо написать перед ним
обратный слэш \In{}\verb!\!\In{}. Также символы для обозначения
комментариев \In{*}, \In{|}, \In{^} и \In{>} являются специальными, если
они расположены в самом начале строки.

\subsubsection{Параграфы}

Параграфы определяются по пустой сроке в комментарии. Так например мы
можем разбить текст на два параграфа:


\begin{code}
-- | The first paragraph goes here.
--
-- The second paragraph goes here.
fun :: a -> b
\end{code}

\subsubsection{Блоки кода}

Существует два способа обозначения блоков кода:


\begin{code}
-- | This documentation includes two blocks of code:
--
-- @
--     f x = x + x
--     g x = x
-- @
--
-- >  g x = x * 42
\end{code}

В первом варианте мы заключаем блок кода в окружение \In{@...@}. Так мы
можем выделить целый кусок кода. Для выделения одной строки мы можем
воспользоваться знаком \In{>}.

\subsubsection{Примеры вычисления в интерпретаторе}

В \In{Haddock} мы можем привести пример вычисления выражения в
интерпретаторе. Это делается с помощью тройного символа \In{>}:


\begin{code}
-- | Two examples are given bellow:
--
-- >>> 2+3
-- 5
--
-- >>> print 1 >> print 2
-- 1
-- 2
\end{code}

Строки, которые идут сразу за строкой с символом \In{>>>} помечаются как
результат выполнения выражения в интерпретаторе.

\subsubsection{Имена определений}

Для того чтобы выделить имя любого определения, будь то функция, тип или
класс, необходимо заключить его в ординарные кавычки, как в \In{'T'}.
При этом \In{Haddock} установит ссылку к определению и подсветит имя в
тексте. Для того чтобы сослаться на определение из другого модуля
необходимо написать его полное имя, т.е.\textasciitilde{}с приставкой
имени модуля, например функция \In{fun}, определённая в модуле \In{M},
имеет полное имя \In{M.fun}, тогда в комментариях мы обозначаем её
\In{'M.fun'}.

Ординарные кавычки часто используются в английском языке как апострофы,
в таких сочетаниях как don't, isn't. Перед такими вхождениями ординарных
кавычек можно не писать обратный слэш. \In{Haddock} сумеет отличить их
от идентификатора.

\subsubsection{Курсив и моноширинный шрифт}

Для выделения текста курсивом, он заключается в окружение \In{...}. Для
написания текста моноширинным шрифтом, он заключается в окружение
\In{@...@}.

\subsubsection{Модули}

Для обозначения модулей используются двойные кавычки, как в


\begin{code}
-- | This is a reference to the "Foo" module.
\end{code}

\subsubsection{Списки}

Список без нумерации обозначается с помощью звёздочек:


\begin{code}
-- | This is a bulleted list:
--
--     * first item
--
--     * second item
\end{code}

Пронумерованный список, обозначается символами \In{(n)} или \In{n.}
(\In{n} с точкой), где \In{n} -- некоторое целое число:


\begin{code}
-- | This is an enumerated list:
--
--     (1) first item
--
--     2. second item
\end{code}

\subsubsection{Список определений}

Определения обозначаются квадратными скобками, например комментарий:


\begin{code}
-- | This is a definition list:
--
--   [@foo@] The description of @foo@.
--
--   [@bar@] The description of @bar@.
\end{code}

\noindent 

в документации будет выглядеть так:

\begin{description}
\item[\In{foo}]
The description of \In{foo}.
\item[\In{bar}]
The description of \In{bar}.
\end{description}

\smallskip

Для выделения текста моноширинным шрифтом мы воспользовались окружением
\In{@...@}.

\subsubsection{URL}

Ссылки на сайты включаются с помощью окружения \In{<...>}.

\subsubsection{Ссылки внутри модуля}

Для того чтобы сослаться на какой-нибудь текст внутри модуля, его
необходимо отметить ссылкой. Для этого мы помещаем в том месте, на
которое мы хотим сослаться, запись \In{#label#}, где \In{label} -- это
идентификатор ссылки. Теперь мы можем сослаться на это место из другого
модуля с помощью записи \In{}\verb!"!\In{module#label}\verb!"!\In{}, где
\In{module} -- имя модуля, в котором находится ссылка \In{label}.

\section{Краткое содержание}

В этой главе мы познакомились с основными элементами арсенала
разработчика программ. Мы научились создавать библиотеки и
документировать их.

\section{Упражнения}

Вспомните один из примеров и превратите его в библиотеку. Например,
напишите библиотеку для натуральных чисел Пеано.
