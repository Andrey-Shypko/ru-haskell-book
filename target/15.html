<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<!-- Switch argument character to $ to escape |  -->








<h1 id="теория-категорий">Теория категорий</h1>
<p>Многие понятия в Haskell позаимствованы из теории категорий, например это функторы, монады. Теория категорий – это скорее язык, математический жаргон, она настолько общая, что кажется ей нет никакого применения. Возможно это и так, но в этом языке многие сущности, которые лишь казались родственными и было смутное интуитивное ощущение их близости, становятся тождественными.</p>
<p>Теория категорий занимается описанием функций. В лямбда-исчислении основной операцией была подстановка значения в функцию, а в теории категорий мы сосредоточимся на операции композиции. Мы будем соединять различные объекты так, чтобы структура объектов сохранялась. Структура объекта будет определяться свойствами, которые продолжают выполнятся после преобразования объекта.</p>
<h2 id="категория">Категория</h2>
<p>Мы будем говорить об объектах и связях между ними. Связи принято называть “стрелками” или “морфизмами”. Далее мы будем пользоваться термином стрелка. У стрелки есть начальный объект, его называют <em>доменом</em> (domain) и конечный объект, его называют <em>кодоменом</em> (codomain).</p>

<p>В этой записи стрелка <span class="math"><em>f</em></span> соединяет объекты <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span>, в тексте мы будем писать это так <span class="math">$f:A \Ra B$</span>, словно стрелка это функция, а объекты это типы. Мы будем обозначать объекты большими буквами <span class="math"><em>A</em></span>, <span class="math"><em>B</em></span>, <span class="math"><em>C</em></span>, …, а стрелки – маленькими буквами <span class="math"><em>f</em></span>, <span class="math"><em>g</em></span>, <span class="math"><em>h</em></span>, … Для того чтобы связи было интереснее изучать мы введём такое правило:</p>

<p>Если конец стрелки <span class="math"><em>f</em></span> указывает на начало стрелки <span class="math"><em>g</em></span>, то должна быть такая стрелка <span class="math">$f \Co g$</span>, которая обозначает <em>составную</em> стрелку. Вводится специальная операция “точка с запятой”, которая называется композицией стрелок: Это правило говорит о том, что связи распространяются по объектам. Теперь у нас есть не просто объекты и стрелки, а целая сеть объектов, связанных между собой. Тот факт, что связи действительно распространяются отражается свойством:</p>
<p><br /><span class="math">$f \Co (g \Co h) = (f \Co g) \Co h$</span><br /></p>
<p>Это свойство называют ассоциативностью. Оно говорит о том, что стрелки, которые образуют составную стрелку являются цепочкой и нам не важен порядок их группировки, важно лишь кто за кем идёт. Подразумевается, что стрелки <span class="math"><em>f</em></span>, <span class="math"><em>g</em></span> и <span class="math"><em>h</em></span> имеют подходящие типы для композиции, что их можно соединять. Это свойство похоже на интуитивное понятие пути, как цепочки отрезков.</p>
<p>Связи между объектами можно трактовать как преобразования объектов. Стрелка <span class="math">$f : A \Ra B$</span> – это способ, с помощью которого мы можем перевести объект <span class="math"><em>A</em></span> в объект <span class="math"><em>B</em></span>. Композиция в этой аналогии приобретает естественную интерпретацию. Если у нас есть способ <span class="math">$f : A \Ra B$</span> преобразования объекта <span class="math"><em>A</em></span> в объект <span class="math"><em>B</em></span>, и способ <span class="math">$g : B \Ra C$</span> преобразования объекта <span class="math"><em>B</em></span> в объект <span class="math"><em>C</em></span>, то мы конечно можем, применив сначала <span class="math"><em>f</em></span>, а затем <span class="math"><em>g</em></span>, получить из объекта <span class="math"><em>A</em></span> объект <span class="math"><em>C</em></span>.</p>
<p>Когда мы думаем о стрелках как о преобразовании, то естественно предположить, что у нас есть преобразование, которое ничего не делает, как тождественная функция. В будем говорить, что для каждого объекта <span class="math"><em>A</em></span> есть стрелка <span class="math"><em>i</em><em>d</em><sub><em>A</em></sub></span>, которая начинается из этого объекта и заканчивается в нём же.</p>
<p><br /><span class="math">$id_A : A \Ra A$</span><br /></p>
<p>Тот факт, что стрелка <span class="math"><em>i</em><em>d</em><sub><em>A</em></sub></span> ничего не делает отражается свойствами, которые должны выполняться для всех стрелок:</p>

<p>Если мы добавим к любой стрелке тождественную стрелку, то от этого ничего не изменится.</p>
<p>Всё готово для того чтобы дать формальное определение понятия  <em>категории</em> (category). Категория это:</p>
<ul>
<li><p>Набор <em>объектов</em> (object).</p></li>
<li><p>Набор <em>стрелок</em> (arrow) или <em>морфизмов</em> (morphism).</p></li>
<li><p>Каждая стрелка соединяет два объекта, но объекты могут совпадать. Так обозначают, что стрелка <span class="math"><em>f</em></span> начинается в объекте <span class="math"><em>A</em></span> и заканчивается в объекте <span class="math"><em>B</em></span>:</p>
<p><br /><span class="math">$f : A \Ra B$</span><br /></p>
<p>При этом стрелка соединяет только два объекта:</p>
<p><br /><span class="math">$f : A \Ra B,\ f : A' \Ra B' \qquad \RA \qquad A=A',\ B=B'$</span><br /></p></li>
<li><p>Определена операция композиции или соединения стрелок. Если конец одной стрелки совпадает с началом другой, то их можно соединить вместе:</p>
<p><br /><span class="math">$f:A \Ra B,\ g : B\Ra C \quad \RA \quad f \Co g : A \Ra C$</span><br /></p></li>
<li><p>Для каждого объекта есть стрелка, которая начинается и заканчивается в этом объекте. Эту стрелку называют <em>тождественной</em> (identity):</p>
<p><br /><span class="math">$id_A : A \Ra A$</span><br /></p></li>
</ul>
<p>Должны выполняться аксиомы:</p>
<ul>
<li><p>Тождество <span class="math"><em>i</em><em>d</em></span></p>
<p><br /><span class="math">$id \Co f = f$</span><br /></p>
<p><br /><span class="math">$f \Co id = f$</span><br /></p></li>
<li><p>Ассоциативность <span class="math">$\Co$</span></p>
<p><br /><span class="math">$f \Co (g \Co h) = (f \Co g) \Co h$</span><br /></p></li>
</ul>
<p>Приведём примеры категорий.</p>
<ul>
<li><p>Одна точка с одной тождественной стрелкой образуют категорию.</p></li>
<li><p>В категории <strong>Set</strong> объектами являются все множества, а стрелками – функции. Стрелки соединяются с помощью композиции функций, тождественная стрелка, это тождественная функция.</p></li>
<li><p>В категории <strong>Hask</strong> объектами являются типы Haskell, а стрелками – функции, стрелки соединяются с помощью композиции функций, тождественная стрелка, это тождественная функция.</p></li>
<li><p>Ориентированный граф может определять категорию. Объекты – это вершины, а стрелки это связанные пути в графе. Соединение стрелок – это соединение путей, а тождественная стрелка, это путь в котором нет ни одного ребра.</p></li>
<li><p>Упорядоченное множество, в котором есть операция сравнения на больше либо равно задаёт категорию. Объекты – это объекты множества. А стрелки это пары объектов таких, что первый объект меньше второго. Первый объект в паре считается начальным, а второй конечным.</p>
<p><br /><span class="math">$(a, b) : a \Ra b  \qquad \text{если } a \leq b$</span><br /></p>
<p>Стрелки соединяются так:</p>
<p><br /><span class="math">$(a, b) \Co (b, c) = (a, c)$</span><br /></p>
<p>Тождественная стрелка состоит из двух одинаковых объектов:</p>
<p><br /><span class="math"><em>i</em><em>d</em><sub><em>a</em></sub> = (<em>a</em>, <em>a</em>)</span><br /></p>
<p>Можно убедиться в том, что это действительно категория. Для этого необходимо проверить аксиомы ассоциативности и тождества. Важно проверить что те стрелки, которые получаются в результате композиции, не нарушали бы основного свойства данной структуры, т.е.~тот факт, что второй элемент пары всегда больше либо равен первого элемента пары.</p></li>
</ul>
<p>Отметим, что бывают такие области, в которых стрелки или преобразования с одинаковыми именами могут соединять несколько разных объектов. Например в Haskell есть классы, поэтому функции с одними и теми же именами могут соединять разные объекты. Если все условия категории для объектов и стрелок выполнены, кроме этого, то такую систему называют <em>прекатегорией</em> (pre-category). Из любой прекатегории не сложно сделать категорию, если включить имена объектов в имя стрелки. Тогда у каждой стрелки будут только одна пара объектов, которые она соединяет.</p>
<h2 id="функтор">Функтор</h2>
<p>Вспомним определение класса \In{Functor}:</p>

\begin{code}
class Functor f where
    fmap :: (a -> b) -> (f a -> f b)
\end{code}

<p>В этом определении участвуют тип \In{f} и метод \In{fmap}. Можно сказать, что тип \In{f} переводит произвольные типы \In{a} в специальные типы \In{f a}. В этом смысле тип \In{f} является функцией, которая определена на типах. Метод \In{fmap} переводит функции общего типа \In{a -> b} в специальные функции \In{f a -> f b}.</p>
<p>При этом должны выполняться свойства:</p>

\begin{code}
fmap id  = id
fmap (f . g) = fmap f . fmap g
\end{code}

<p>Теперь вспомним о категории \In{Hask}. В этой категории объектами являются типы, а стрелками функции. Функтор \In{f} отображает объекты и стрелки категории \In{Hask} в объекты и стрелки \In{f Hask}. При этом оказывается, что за счёт свойств функтора \In{f Hask} образует категорию.</p>
<ul>
<li><p>Объекты – это типы \In{f a}.</p></li>
<li><p>Стрелки – это функции \In{fmap f}.</p></li>
<li><p>Композиция стрелок это просто композиция функций.</p></li>
<li><p>Тождественная стрелка это \In{fmap id}.</p></li>
</ul>
<p>Проверим аксиомы:</p>

\begin{code}
fmap f . fmap id = fmap f . id = fmap f
fmap id . fmap f = id . fmap f = fmap f

    fmap f . (fmap g . fmap h) 
=   fmap f . fmap (g . h) 
=   fmap (f . (g . h))
=   fmap ((f . g) . h)
=   fmap (f . g) . fmap h
=   (fmap f . fmap g) . fmap h
\end{code}

<p>Видно, что аксиомы выполнены, так функтор \In{f} порождает категорию \In{f Hask}. Интересно, что поскольку \In{Hask} содержит все типы, то она содержит и типы \In{f Hask}. Получается, что мы построили категорию внутри категории. Это можно пояснить на примере списков. Тип \In{[]} погружает любой тип в список, а функцию для любого типа можно превратить в функцию, которая работает на списках с помощью метода \In{fmap}. При этом с помощью класса \In{Functor} мы проецируем все типы и все функции в мир списков \In{[a]}. Но сам этот мир списков содержится в категории \In{Hask}.</p>
<p>С помощью функторов мы строим внутри одной категории другую категорию, при этом внутренняя категория обладает некоторой структурой. Так если раньше у нас были только произвольные типы \In{a} и произвольные функции \In{a -> b}, то теперь все объекты имеют тип \In{[a]} и все функции имеют тип \In{[a] -> [b]}. Также и функтор \In{Maybe} переводит произвольное значение, в значение, которое обладает определённой структурой. В нём выделен дополнительный элемент \In{Nothing}, который обозначает отсутствие значения. Если по типу \In{val :: a} мы ничего не можем сказать о содержании значения \In{val}, то по типу \In{val :: Maybe a}, мы знаем один уровень конструкторов. Например мы уже можем проводить сопоставление с образцом.</p>
<p>Теперь давайте вернёмся к теории категорий и дадим формальное определение понятия. Пусть <span class="math">$\CatA$</span> и <span class="math">$\CatB$</span> – категории, тогда  <em>функтором</em> из <span class="math">$\CatA$</span> в <span class="math">$\CatB$</span> называют отображение <span class="math"><em>F</em></span>, которое переводит объекты <span class="math">$\CatA$</span> в объекты <span class="math">$\CatB$</span> и стрелки <span class="math">$\CatA$</span> в стрелки <span class="math">$\CatB$</span>, так что выполнены следующие свойства:</p>

<p>Здесь запись <span class="math">$\Ra_\CatA$</span> и <span class="math">$\Ra_\CatB$</span> означает, что эти стрелки в разных категориях. После отображения стрелки <span class="math"><em>f</em></span> из категории <span class="math">$\CatA$</span> мы получаем стрелку в категории <span class="math">$\CatB$</span>, это и отражено в типе <span class="math">$Ff : FA \Ra_\CatB FB$</span>. Первое свойство говорит о том, что после отображения стрелки соединяют те же объекты, что и до отображения. Второе свойства говорит о сохранении тождественных стрелок. А последнее свойство, говорит о том, что “пути” между объектами также сохраняются. Если мы находимся в категории <span class="math">$\CatA$</span> в объекте <span class="math"><em>A</em></span> и перед нами есть путь состоящий из нескольких стрелок в объект <span class="math"><em>B</em></span>, то неважно как мы пойдём в <span class="math"><em>F</em><em>B</em></span> либо мы пройдём этот путь в категории <span class="math">$\CatA$</span> и в самом конце переместимся в <span class="math"><em>F</em><em>B</em></span> или мы сначала переместимся в <span class="math"><em>F</em><em>A</em></span> и затем пройдём по образу пути в категории <span class="math"><em>F</em><em>B</em></span>. Так и так мы попадём в одно и то же место. Схематически это можно изобразить так:</p>

<p>Стрелки сверху находятся в категории <span class="math">$\CatA$</span>, а стрелки снизу находятся в категории <span class="math">$\CatB$</span>. Функтор <span class="math">$F : \CatA \Ra \CatA$</span>, который переводит категорию <span class="math">$\CatA$</span> в себя называют  <em>эндофунктором</em> (endofunctor). Функторы отображают одни категории в другие сохраняя структуру первой категории. Мы словно говорим, что внутри второй категории есть структура подобная первой. Интересно, что последовательное применение функторов, также является функтором. Мы будем писать последовательное применение функторов <span class="math"><em>F</em></span> и <span class="math"><em>G</em></span> слитно, как <span class="math"><em>F</em><em>G</em></span>. Также можно определить и тождественный функтор, который ничего не делает с категорией, мы будем обозначать его как <span class="math">$I_\CatA$</span> или просто <span class="math"><em>I</em></span>, если категория на которой он определён понятна из контекста. Это говорит о том, что мы можем построить категорию, в которой объектами будут другие категории, а стрелками будут функторы.</p>
<h2 id="естественное-преобразование">Естественное преобразование</h2>
<p>В программировании часто приходится переводить данные из одной структуры в другую. Каждая из структур хранит какие-то конкретные значения, но мы ничего с ними не делаем мы просто перекладываем содержимое из одного ящика в другой. Например в нашем ящике только один отсек, но вдруг нам пришло бесконечно много подарков, что поделать нам приходится сохранить первый попавшийся, отбросив остальные. Главное в этой аналогии это то, что мы ничего не меняем, а лишь перекладываем содержимое из одной структуры в другую.</p>
<p>В Haskell это можно описать так:</p>

\begin{code}
onlyOne :: [a] -> Maybe a
onlyOne []      = Nothing
onlyOne (a:as)  = Just a
\end{code}

<p>В этой функции мы перекладываем элементы из списка \In{[a]} в частично определённое значение \In{Maybe}. Тоже самое происходит и в функции \In{concat}:</p>

\begin{code}
concat :: [[a]] -> [a]
\end{code}

<p>Элементы перекладываются из списка списков в один список. В теории категорий этот процесс называется естественным преобразованием. Структуры определяются функторами. Поэтому в определении будет участвовать два функтора. В функции \In{onlyOne} это были функторы \In{[]} и \In{Maybe}. При перекладывании элементов мы можем просто выбросить все элементы:</p>

\begin{code}
burnThemALl :: [a] -> ()
burnThemAll = const ()
\end{code}

<p>Можно сказать, что единичный тип также определяет функтор. Это константный функтор, он переводит любой тип в единственное значение \In{()}, а функцию в \In{id}:</p>

\begin{code}
data Empty a = Empty

instance Functor Empty where
    fmap = const id
\end{code}

<p>Тогда тип функции \In{burnThemAll} будет параметризован и слева и справа от стрелки:</p>

\begin{code}
burnThemAll :: [a] -> Empty a
burnThemAll = const Empty
\end{code}

<p>Пусть даны две категории <span class="math">$\CatA$</span> и <span class="math">$\CatB$</span> и два функтора <span class="math">$F,G : \CatA \Ra \CatB$</span>. <em>Преобразованием</em> (transformation) в <span class="math">$\CatB$</span> из <span class="math"><em>F</em></span> в <span class="math"><em>G</em></span> называют семейство стрелок <span class="math"><em>ɛ</em></span>:</p>
<p><br /><span class="math">$\varepsilon_A : FA \Ra_\CatB GA 
        \qquad \text{для любого } A \text{ из } \CatA$</span><br /></p>
<p>Рассмотрим преобразование \In{onlyOne :: [a] -> Maybe a}. Категории <span class="math">$\CatA$</span> и <span class="math">$\CatB$</span> в данном случае совпадают~– это категория \In{Hask}. Функтор <span class="math"><em>F</em></span> – это список, а функтор <span class="math"><em>G</em></span> это \In{Maybe}. Преобразование \In{onlyOne} для каждого объекта \In{a} из \In{Hask} определяет стрелку</p>

\begin{code}
onlyOne :: [a] -> Maybe a
\end{code}

<p>Так мы получаем семейство стрелок, параметризованное объектом из \In{Hask}:</p>

\begin{code}
onlyOne :: [Int] -> Maybe Int
onlyOne :: [Char] -> Maybe Char
onlyOne :: [Int -> Int] -> Maybe (Int -> Int)
...
...
\end{code}

<p>Теперь давайте определим, что значит перекладывать из одной структуры в другую, не меняя содержания. Представим, что функтор – это контейнер. Мы можем менять его содержание с помощью метода \In{fmap}. Например мы можем прибавить единицу ко всем элементам списка \In{xs} с помощью выражения . Точно так же мы можем прибавить единицу к частично определённому значению. С точки зрения теории категорий суть понятия “останется неизменным при перекладывании” заключается в том, что если мы возьмём любую функцию к примеру прибавление единицы, то нам неважно когда её применять до функции \In{onlyOne} или после. И в том и в другом случае мы получим одинаковый ответ. Давайте убедимся в этом:</p>

\begin{code}
    onlyOne $ fmap (+1) [1,2,3,4,5]
=>  onlyOne [2,3,4,5,6]
=>  Just 2

    fmap (+1) $ onlyOne [1,2,3,4,5]
=>  fmap (+1) $ Just 1
=>  Just 2
\end{code}

<p>Результаты сошлись, обратите внимание на то, что функции \In{fmap (+1)} в двух вариантах являются разными функциями. Первая работает на списках, а вторая на частично определённых значениях. Суть в том, что если при перекладывании значение не изменилось, то нам не важно когда выполнять преобразование внутри функтора \In{[]} или внутри функтора \In{Maybe}. Теперь давайте выразим это на языке теории категорий.</p>
<p>Преобразование <span class="math"><em>ɛ</em></span> в категории <span class="math">$\CatB$</span> из функтора <span class="math"><em>F</em></span> в функтор <span class="math"><em>G</em></span> называют  <em>естественным</em> (natural), если</p>
<p><br /><span class="math">$Ff \Co \varepsilon_B \ =\ \varepsilon_A \Co Gf 
    \qquad \text{для любого } f : A \Ra_\CatA B$</span><br /></p>
<p>Это свойство можно изобразить графически:</p>

<p>По смыслу ясно, что если у нас есть три структуры данных (или три функтора), если мы просто переложили данные из первой во вторую, а затем переложили данные из второй в третью, ничего не меняя. То итоговое преобразование, которое составлено из последовательного применения перекладывания данных также не меняет данные. Это говорит о том, что композиция двух естественных преобразований также является естественным преобразованием. Также мы можем составить тождественное преобразование, для двух одинаковых функторов <span class="math">$F : \CatA \Ra \CatB$</span>, это будет семейство тождественных стрелок в . Получается, что для двух категорий <span class="math">$\CatA$</span> и <span class="math">$\CatB$</span> мы можем составить категорию <span class="math">$Ftr(\CatA,\CatB)$</span>, в которой объектами будут функторы из <span class="math">$\CatA$</span> в <span class="math">$\CatB$</span>, а стрелками будут естественные преобразования. Поскольку естественные преобразования являются стрелками, которые соединяют функторы, мы будем обозначать их как обычные стрелки. Так запись <span class="math">$\eta : F \Ra G$</span> обозначает преобразование <span class="math"><em>η</em></span>, которое переводит функтор <span class="math"><em>F</em></span> в функтор <span class="math"><em>G</em></span>.</p>
<p>Интересно, что изначально создатели теории категорий Саундедерс Маклейн и Сэмюэль Эйленберг придумали понятие естественного преобразования, а затем, чтобы дать ему обоснование было придумано понятие функтора, и наконец для того чтобы дать обоснование функторам были придуманы категории. Категории содержат объекты и стрелки, для стрелок есть операция композиции. Также для каждого объекта есть тождественная стрелка. Функторы являются стрелками в категории, в которой объектами являются другие категории. А естественные преобразования являются стрелками в категории, в которой объектами являются функторы. Получается такая иерархия структур.</p>
<h2 id="монады">Монады</h2>
<p> <em>Монадой</em> называют эндофунктор <span class="math">$T:\CatA \Ra \CatA$</span>, для которого определены два естественных преобразования <span class="math">$\eta : I \Ra T$</span> и <span class="math">$\mu : TT \Ra T$</span> и выполнены два свойства:</p>
<ul>
<li><p><span class="math">$T \eta_A \Co \mu_{A} \ =\ id_{TA}$</span></p></li>
<li><p><span class="math">$T \mu_A \Co \mu_{TA} = \mu_{TTA} \Co \mu_A$</span></p></li>
</ul>
<p>Преобразование <span class="math"><em>η</em></span> – это функция \In{return}, а преобразование <span class="math"><em>μ</em></span> – это функция \In{join}. В теории категорий в классе \In{Monad} другие методы. Перепишем эти свойства в виде функций Haskell:</p>

\begin{code}
join . fmap return   = id
join . fmap join     = join . join
\end{code}

<p>Порядок следования аргументов изменился, потому что мы пользуемся обычной композицией (через точку). Выражение <span class="math"><em>T</em><em>η</em><sub><em>A</em></sub></span> означает применение функтора <span class="math"><em>T</em></span> к стрелке <span class="math"><em>η</em><sub><em>A</em></sub></span>. Ведь преобразование это семейство стрелок, которые параметризованы объектами категории. На языке Haskell это означает применить \In{fmap} к полиморфной функции (функции с параметром).</p>
<p>Также эти свойства можно изобразить графически:</p>


<h3 id="категория-клейсли">Категория Клейсли</h3>
<p>Если у нас есть монада <span class="math"><em>T</em></span>, определённая в категории <span class="math">$\CatA$</span>, то мы можем построить в этой категории категорию специальных стрелок вида <span class="math">$A \Ra TB$</span>. Эту категорию называют категорией Клейсли.</p>
<ul>
<li><p>Объекты категории Клейсли <span class="math">$\CatA_T$</span> – это объекты исходной категории <span class="math">$\CatA$</span>.</p></li>
<li><p>Стрелки в <span class="math">$\CatA_T$</span> это стрелки из <span class="math">$\CatA$</span> вида <span class="math">$A \Ra TB$</span>, мы будем обозначать их <span class="math">$A \Ra_T B$</span></p></li>
<li><p>Композиция стрелок <span class="math">$f : A \Ra_T B$</span> и <span class="math">$g : B \Ra_T C$</span> определена с помощью естественных преобразований монады <span class="math"><em>T</em></span>:</p>
<p><br /><span class="math">$f \CoT g = f \Co Tg \Co \mu$</span><br /></p>
<p>Значок <span class="math">$\CoT$</span> указывает на то, что слева от равно композиция в <span class="math">$\CatA_T$</span>. Справа от знака равно используется композиция в исходной категории <span class="math">$\CatA$</span>.</p></li>
<li><p>Тождественная стрелка – это естественное преобразование <span class="math"><em>η</em></span>.</p></li>
</ul>
<p>Можно показать, что категория Клейсли действительно является категорией и свойства операций композиции и тождества выполнены.</p>
<h2 id="дуальность">Дуальность</h2>
<p>Интересно, что если в категории <span class="math">$\CatA$</span> перевернуть все стрелки, то снова получится категория. Попробуйте нарисовать граф со стрелками, и затем мысленно переверните направление всех стрелок. Все пути исходного графа перейдут в перевёрнутые пути нового графа. При этом пути будут проходить через те же точки. Сохранятся композиции стрелок, только все они будут перевёрнуты. Такую категорию обозначают <span class="math">$\CatA^{op}$</span>. Но оказывается, что переворачивать мы можем не только категории но и свойства категорий, или утверждения о категориях, эту операцию называют <em>дуализацией</em>. Определим её:</p>

<p>Есть такое свойство, если и в исходной категории <span class="math">$\CatA$</span> выполняется какое-то утверждение, то в перевёрнутой категории <span class="math">$\CatA^{op}$</span> выполняется перевёрнутое (дуальное) свойство. Часто в теории категорий из одних понятий получают другие дуализацией. При этом мы можем не проверять свойства для нового понятия, они будут выполняться автоматически. К дуальным понятиям обычно добавляют приставку “ко”. Приведём пример, получим понятие комонады.</p>
<p>Для начала вспомним определение монады. Монада – это эндофунктор (функтор, у которого совпадают начало и конец или домен и кодомен) <span class="math">$T : \CatA \Ra \CatA$</span> и два естественных преобразования <span class="math">$\eta : I \Ra T$</span> и <span class="math">$\mu : TT \Ra T$</span>, такие что выполняются свойства:</p>
<ul>
<li><p><span class="math">$T \eta \Co \mu = id$</span></p></li>
<li><p><span class="math">$T \mu \Co \mu = \mu \Co \mu$</span></p></li>
</ul>
<p>Дуализируем это определение. Комонада – это эндофунктор <span class="math">$T : \CatA \Ra \CatA$</span> и два естественных преобразования <span class="math">$\eta : T \Ra I$</span> и <span class="math">$\mu : TT \Ra T$</span>, такие что выполняются свойства</p>
<ul>
<li><p><span class="math">$\mu \Co T \eta = id$</span></p></li>
<li><p><span class="math">$\mu \Co T \mu = \mu \Co \mu$</span></p></li>
</ul>
<p>Мы просто переворачиваем домены и кодомены в стрелках и меняем порядок в композиции. Проверьте сошлись ли типы. Попробуйте нарисовать графическую схему свойств комонады и сравните со схемой для монады.</p>
<p>Можно также определить и категорию коКлейсли. В категории коКлейсли все стрелки имеют вид <span class="math">$TA \Ra B$</span>. Теперь дуализируем композицию из категории Клейсли:</p>
<p><br /><span class="math">$f \CoT g = f \Co Tg \Co \mu$</span><br /></p>
<p>Теперь получим композицию в категории коКлейсли:</p>
<p><br /><span class="math">$g \CoT f = \mu \Co Tg \Co f$</span><br /></p>
<p>Мы перевернули цепочки композиций слева и справа от знака равно. Проверьте сошлись ли типы. Не забывайте что в этом определении <span class="math"><em>η</em></span> и <span class="math"><em>μ</em></span> естественные преобразования для комонады. Нам не нужно проверять является ли категория коКлейсли действительно категорией. Нам не нужно опять проверять свойства стрелки тождества и ассоциативности композиции, если мы уже проверили их для монады. Следовательно перевёрнутое утверждение будет выполняться в перевёрнутой категории коКлейсли. В этом основное преимущество определения через дуализацию.</p>
<p>Этим приёмом мы можем воспользоваться и в Haskell, дуализируем класс \In{Monad}:</p>

\begin{code}
class Monad m where
    return  :: a -> m a
    (>>=)   :: m a -> (a -> m b) -> m b
\end{code}

<p>Перевернём все стрелки:</p>

\begin{code}
class Comonad c where
    coreturn    :: c a -> a
    cobind      :: c b -> (c b -> a) -> c a
\end{code}

<h2 id="начальный-и-конечный-объекты">Начальный и конечный объекты</h2>
<h3 id="начальный-объект">Начальный объект</h3>
<p>Представим, что в нашей категории есть такой объект <span class="math">0</span>, который соединён со всеми объектами. Причём стрелка начинается из этого объекта и для каждого объекта может быть только одна стрелка которая соединят данный объект с <span class="math">0</span>. Графически эту ситуацию можно изобразить так:</p>

<p> Такой объект называют <em>начальным</em> (initial object). Его принято обозначать нулём, словно это начало отсчёта. Для любого объекта <span class="math"><em>A</em></span> из категории <span class="math">$\CatA$</span> с начальным объектом <span class="math">0</span> существует и только одна стрелка . Можно сказать, что начальный объект определяет функцию, которая переводит объекты <span class="math"><em>A</em></span> в стрелки <span class="math">$f : 0 \Ra A$</span>. Эту функцию обозначают специальными скобками <span class="math">$\cata{\cdot}$</span>, она называется   <em>катаморфизмом</em> (catamorphism).</p>
<p><br /><span class="math">$\cata{A} = f : 0 \Ra A$</span><br /></p>
<p>У начального объекта есть несколько важных свойств. Они очень часто встречаются в разных вариациях, в понятиях, которые определяются через понятие начального объекта:</p>

<p>Эти свойства следуют из определения начального объекта. Свойство тождества говорит о том, что стрелка ведущая из начального объекта в начальный является тождественной стрелкой. В самом деле по определению начального объекта для каждого объекта может быть только одна стрелка, которая начинается в <span class="math">0</span> и заканчивается в этом объекте. Стрелка <span class="math">$\cata{0}$</span> начинается в <span class="math">0</span> и заканчивается в <span class="math">0</span>, но у нас уже есть одна такая стрелка, по определению категории для каждого объекта определена тождественная стрелка, значит эта стрелка является единственной.</p>
<p>Второе свойство следует из единственности стрелки, ведущей из начального объекта в данный. Третье свойство лучше изобразить графически:</p>

<p>Поскольку стрелки <span class="math">$\cata{A}$</span> и <span class="math"><em>f</em></span> можно соединить, то должна быть определена стрелка <span class="math">$\cata{A} \Co f : 0 \Ra B$</span>, но поскольку в категории с начальным объектом из начального объекта <span class="math">0</span> в объект <span class="math"><em>B</em></span> может вести лишь одна стрелка, то стрелка <span class="math">$\cata{A} \Co f$</span> должна совпадать с <span class="math">$\cata{B}$</span>.</p>
<h3 id="конечный-объект">Конечный объект</h3>
<p>Дуализируем понятие начального объекта. Пусть в категории <span class="math">$\CatA$</span> есть объект <span class="math">1</span>, такой что для любого объекта <span class="math"><em>A</em></span> существует и только одна стрелка, которая начинается из этого объекта и заканчивается в объекте <span class="math">1</span>. Такой объект называют  <em>конечным</em> (terminal object):</p>

<p>Конечный объект определяет в категории функцию, которая ставит в соответствие объектам стрелки, которые начинаются из данного объекта и заканчиваются в конечном объекте. Такую функцию называют   <em>анаморфизмом</em> (anamorphism), и обозначают специальными скобками <span class="math">$\ana{\cdot}$</span>, которые похожи на перевёрнутые скобки для катаморфизма:</p>
<p><br /><span class="math">$\ana{A} = f : A \Ra  1$</span><br /></p>
<p>Можно дуализировать и свойства:</p>

<p>Приведём иллюстрацию для свойства слияния:</p>

<h2 id="сумма-и-произведение">Сумма и произведение</h2>
<p>Давным-давно, когда мы ещё говорили о типах, мы говорили, что типы конструируются с помощью двух базовых операций: суммы и произведения. Сумма говорит о том, что значение может быть либо одним значением либо другим. А произведение обозначает сразу несколько значений. В Haskell есть два типа, которые представляют собой сумму и произведение в общем случае. Тип для суммы это \In{Either}:</p>

\begin{code}
data Either a b = Left a | Right b
\end{code}

<p>Произведение в самом общем виде представлено кортежами:</p>

\begin{code}
data (a, b) = (a, b)
\end{code}

<p>В теории категорий сумма и произведение определяются как начальный и конечный объекты в специальных категориях. Теория категорий изучает объекты по тому как они взаимодействуют с остальными объектами. Взаимодействие обозначается с помощью стрелок. Специальные свойства стрелок определяют объект.</p>
<p>Например представим, что мы не можем заглядывать внутрь суммы типов, как бы мы могли взаимодействовать с объектом, который представляет собой сумму двух типов <span class="math"><em>A</em> + <em>B</em></span>? Нам необходимо уметь создавать объект типа <span class="math"><em>A</em> + <em>B</em></span> из объектов <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span> извлекать их из суммы. Создание объектов происходит с помощью двух специальных конструкторов:</p>
<p><br /><span class="math">$inl : A \Ra A+B$</span><br /></p>
<p><br /><span class="math">$inr : B \Ra A+B$</span><br /></p>
<p>Также нам хочется уметь как-то извлекать значения. По смыслу внутри суммы <span class="math"><em>A</em> + <em>B</em></span> хранится либо объект <span class="math"><em>A</em></span> либо объект <span class="math"><em>B</em></span> и мы не можем заранее знать какой из них, поскольку внутреннее содержание <span class="math"><em>A</em> + <em>B</em></span> от нас скрыто, но мы знаем, что это только <span class="math"><em>A</em></span> или <span class="math"><em>B</em></span>. Это говорит о том, что если у нас есть две стрелки <span class="math">$A \Ra C$</span> и <span class="math">$B \Ra C$</span>, то мы как-то можем построить <span class="math">$A+B \Ra C$</span>. У нас есть операция:</p>
<p><br /><span class="math">$out(f,g) : A+B \Ra C \qquad f : A \Ra C,\ g : B \Ra C$</span><br /></p>
<p>При этом для того, чтобы стрелки <span class="math"><em>i</em><em>n</em><em>l</em></span>, <span class="math"><em>i</em><em>n</em><em>r</em></span> и <span class="math"><em>o</em><em>u</em><em>t</em></span> были согласованы необходимо, чтобы выполнялись свойства:</p>
<p><br /><span class="math">$inl \Co out(f,g)\ =\ f$</span><br /></p>
<p><br /><span class="math">$inr \Co out(f,g)\ =\ g$</span><br /></p>
<p>Для любых функций <span class="math"><em>f</em></span> и <span class="math"><em>g</em></span>. Графически это свойство можно изобразить так:</p>

<p>Итак суммой двух объектов <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span> называется объект <span class="math"><em>A</em> + <em>B</em></span> и две стрелки <span class="math">$inl : A \Ra A+B$</span> и <span class="math">$inr : B \Ra A+B$</span> такие, что для любых двух стрелок <span class="math">$f : A \Ra C$</span> и <span class="math">$g : B \Ra C$</span> определена одна и только одна стрелка <span class="math">$h : A+B \Ra C$</span> такая, что выполнены свойства:</p>
<p><br /><span class="math">$inl \Co h = f$</span><br /> <br /><span class="math">$inr \Co h = g$</span><br /></p>
<p>В этом определении объект <span class="math"><em>A</em> + <em>B</em></span> вместе со стрелками <span class="math"><em>i</em><em>n</em><em>l</em></span> и <span class="math"><em>i</em><em>n</em><em>r</em></span>, определяет функцию, которая по некоторому объекту <span class="math"><em>C</em></span> и двум стрелкам <span class="math"><em>f</em></span> и <span class="math"><em>g</em></span> строит стрелку <span class="math"><em>h</em></span>, которая ведёт <em>из</em> объекта <span class="math"><em>A</em> + <em>B</em></span> в объект <span class="math"><em>C</em></span>. Этот процесс определения стрелки по объекту напоминает определение начального элемента. Построим специальную категорию, в которой объект <span class="math"><em>A</em> + <em>B</em></span> будет начальным. Тогда функция <span class="math"><em>o</em><em>u</em><em>t</em></span> будет катаморфизмом.</p>
<p>Функция <span class="math"><em>o</em><em>u</em><em>t</em></span> принимает две стрелки и возвращает третью. Посмотрим на типы:</p>
<p><br /><span class="math">$f : A \Ra C  \qquad\qquad inl : A \Ra A+B$</span><br /></p>
<p><br /><span class="math">$g : B \Ra C  \qquad\qquad inr : B \Ra A+B$</span><br /></p>
<p>Каждая из пар стрелок в столбцах указывают на один и тот же объект, а начинаются они из двух разных объектов <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span>. Определим категорию, в которой объектами являются пары стрелок <span class="math">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>)</span>, которые начинаются из объектов <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span> и заканчиваются в некотором общем объекте <span class="math"><em>D</em></span>. Эту категорию ещё называют клином. Стрелками в этой категории будут такие стрелки <span class="math">$f : (d_1, d_2) \Ra (e_1, e_2)$</span>, что стрелки в следующей диаграмме коммутируют (не важно по какому пути идти из двух разных точек).</p>

<p>Композиция стрелок – это обычная композиция в исходной категории, в которой определены объекты <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span>, а тождественная стрелка для каждого объекта, это тождественная стрелка для того объекта, в котором сходятся обе стрелки. Можно проверить, что это действительно категория.</p>
<p>Если в этой категории есть начальный объект, то мы будем называть его суммой объектов <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span>. Две стрелки, которые содержит этот объект мы будем называть <span class="math"><em>i</em><em>n</em><em>l</em></span> и <span class="math"><em>i</em><em>n</em><em>r</em></span>, а общий объект в котором эти стрелки сходятся будем называть <span class="math"><em>A</em> + <em>B</em></span>. Теперь если мы выпишем определение для начального объекта, но вместо произвольных стрелок и объектов подставим наш конкретный случай, то мы получим как раз исходное определение суммы.</p>
<p>Начальный объект <span class="math">$(inl : A \Ra A+B,\ inr : B \Ra A+B)$</span> ставит в соответствие любому объекту <span class="math">$(f : A \Ra C,\ g : B \Ra C)$</span> стрелку <span class="math">$h : A+B \Ra C$</span> такую, что выполняются свойства:</p>

<p>А как на счёт произведения? Оказывается, что произведение является дуальным понятием по отношению к сумме. Его иногда называют косуммой, или сумму называют копроизведением. Дуализируем категорию, которую мы строили для суммы.</p>
<p>У нас есть категория <span class="math">$\CatA$</span> и в ней выделено два объекта <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span>. Объектами новой категории будут пары стрелок <span class="math">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>)</span>, которые <em>начинаются</em> в общем объекте <span class="math"><em>C</em></span> а заканчиваются в объектах <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span>. Стрелками в этой категории будут стрелки исходной категории <span class="math">$h : (e_1,e_2) \Ra (d_1,d_2)$</span> такие что следующая диаграмма коммутирует:</p>

<p>Композиция и тождественные стрелки позаимствованы из исходной категории <span class="math">$\CatA$</span>. Если в этой категории существует <em>конечный</em> объект. То мы будем называть его произведением объектов <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span>. Две стрелки этого объекта обозначаются как <span class="math">(<em>e</em><em>x</em><em>l</em>, <em>e</em><em>x</em><em>r</em>)</span>, а общий объект из которого они начинаются мы назовём <span class="math"><em>A</em> × <em>B</em></span>. Теперь распишем определение конечного объекта для нашей категории пар стрелок с общим началом.</p>
<p>Конечный объект <span class="math">$(exl : A \times B \Ra A, \ exr : A \times B \Ra B)$</span> ставит в соответствие любому объекту категории <span class="math">$(f : C \Ra A,\ g : C \Ra B)$</span> стрелку <span class="math">$h : C \Ra A \times B$</span>. При этом выполняются свойства:</p>

<p>Итак мы определили сумму, а затем на автомате, перевернув все утверждения, получили определение произведения. Но что это такое? Соответствует ли оно интуитивному понятию произведения?</p>
<p>Так же как и в случае суммы в теории категорий мы определяем понятие, через то как мы можем с ним взаимодействовать. Посмотрим, что нам досталось от абстрактного определения. У нас есть обозначение произведения типов <span class="math"><em>A</em> × <em>B</em></span>. Две стрелки <span class="math"><em>e</em><em>x</em><em>l</em></span> и <span class="math"><em>e</em><em>x</em><em>r</em></span>. Также у нас есть способ получить по двум функциям <span class="math">$f : C \Ra A$</span> и <span class="math">$g : C \Ra B$</span> стрелку <span class="math">$h : C \Ra A \times B$</span>. Для начала посмотрим на типы стрелок конечного объекта:</p>
<p><br /><span class="math">$exl : A \times B \Ra A$</span><br /></p>
<p><br /><span class="math">$exr : A \times B \Ra B$</span><br /></p>
<p>По типам видно, что эти стрелки разбивают пару на составляющие. По смыслу произведения мы точно знаем, что у нас есть в <span class="math"><em>A</em> × <em>B</em></span> и объект <span class="math"><em>A</em></span> и объект <span class="math"><em>B</em></span>. Эти стрелки позволяют нам извлекать компоненты пары. Теперь посмотрим на анаморфизм:</p>
<p><br /><span class="math">$\ana{f,g} : C \Ra A \times B \qquad f : C \Ra A,\ g : C \Ra B$</span><br /></p>
<p>Эта функция позволяет строить пару по двум функциям и начальному значению. Но, поскольку здесь мы ничего не вычисляем, а лишь связываем объекты, мы можем по паре стрелок, которые начинаются из общего источника связать источник с парой конечных точек <span class="math"><em>A</em> × <em>B</em></span>.</p>
<p>При этом выполняются свойства:</p>
<p><br /><span class="math">$\ana{f,g} \Co exl = f$</span><br /></p>
<p><br /><span class="math">$\ana{f,g} \Co exr = g$</span><br /></p>
<p>Эти свойства говорят о том, что функции построения пары и извлечения элементов из пары согласованы. Если мы положим значение в первый элемент пары и тут же извлечём его, то это тоже само если бы мы не использовали пару совсем. То же самое и со вторым элементом.</p>
<h2 id="экспонента">Экспонента</h2>
<p>Если представить, что стрелки это функции, то может показаться, что все наши функции являются функциями одного аргумента. Ведь у стрелки есть только один источник. Как быть если мы хотим определить функцию нескольких аргументов, что она связывает? Если в нашей категории определено произведение объектов, то мы можем представить функцию двух аргументов, как стрелку, которая начинается из произведения:</p>
<p><br /><span class="math">$(+) : Num \times Num \Ra Num$</span><br /></p>
<p>Но в лямбда-исчислении нам были доступны более гибкие функции, функции могли принимать на вход функции и возвращать функции. Как с этим обстоят дела в теории категорий? Если перевести определение функций высшего порядка на язык теории категорий, то мы получим стрелки, которые могут связывать другие стрелки. Категория с функциями высшего порядка может содержать свои стрелки в качестве объектов. Стрелки как объекты обозначаются с помощью степени, так запись <span class="math"><em>B</em><sup><em>A</em></sup></span> означает стрелку <span class="math">$A \Ra B$</span>. При этом нам необходимо уметь интерпретировать стрелку, мы хотим уметь подставлять значения. Если у нас есть объект <span class="math"><em>B</em><sup><em>A</em></sup></span>, то должна быть стрелка</p>
<p><br /><span class="math">$eval : B^A \times A \Ra B$</span><br /></p>
<p>На языке функций можно сказать, что стрелка <span class="math"><em>e</em><em>v</em><em>a</em><em>l</em></span> принимает функцию высшего порядка <span class="math">$A \Ra B$</span> и значение типа <span class="math"><em>A</em></span>, а возвращает значение типа <span class="math"><em>B</em></span>. Объект <span class="math"><em>B</em><sup><em>A</em></sup></span> называют экспонентой. Теперь дадим формальное определение.</p>
<p>Пусть в категории <span class="math">$\CatA$</span> определено произведение.  <em>Экспонента</em> – это объект <span class="math"><em>B</em><sup><em>A</em></sup></span> вместе со стрелкой <span class="math">$eval : B^A \times A \Ra B$</span> такой, что для любой стрелки <span class="math">$f : C \times A \Ra B$</span> определена стрелка <span class="math">$curry(f):C \Ra B^A$</span> при этом следующая диаграмма коммутирует:</p>

<p>Давайте разберёмся, что это всё означает. По смыслу стрелка <span class="math"><em>c</em><em>u</em><em>r</em><em>r</em><em>y</em>(<em>f</em>)</span> это каррированная функция двух аргументов. Вспомните о функции \In{curry} из Haskell. Диаграмма говорит о том, что если мы каррированием функции двух аргументов получим функцию высшего порядка <span class="math">$C \Ra B^A$</span>, а затем с помощью функции <span class="math"><em>e</em><em>v</em><em>a</em><em>l</em></span> получим значение, то это всё равно, что подставить два значения в исходную функцию. Запись <span class="math">(<em>c</em><em>u</em><em>r</em><em>r</em><em>y</em>(<em>f</em>), <em>i</em><em>d</em>)</span> означает параллельное применение двух стрелок внутри пары:</p>
<p><br /><span class="math">$(f, g) : A \times A' \Ra B \times B' 
            , \qquad f : A\Ra B , \ g : A' \Ra B'$</span><br /></p>
<p>Так применив стрелки <span class="math">$curry(f) : C \Ra B^A$</span> и <span class="math">$id : A \Ra A$</span> к паре <span class="math"><em>C</em> × <em>A</em></span>, мы получим пару <span class="math"><em>B</em><sup><em>A</em></sup> × <em>A</em></span>. Применение здесь условное мы подразумеваем применение в функциональной аналогии, в теории категорий происходит связывание пар объектов с помощью стрелки <span class="math">(<em>f</em>, <em>g</em>)</span>.</p>
<p>Интересно, что и экспоненту можно получить как конечный объект в специальной категории. Пусть есть категория <span class="math">$\CatA$</span> и в ней определено произведение объектов <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span>. Построим категорию, в которой объектами являются стрелки вида:</p>
<p><br /><span class="math">$C \times A \Ra B$</span><br /></p>

<p>где <span class="math"><em>C</em></span> – это произвольный объект исходной категории. Стрелкой между объектами <span class="math">$c : C \times A \Ra B$</span> и <span class="math">$d : D \times A \Ra B$</span> в этой категории будет стрелка <span class="math">$f : C \Ra D$</span> из исходной категории, такая, что следующая диаграмма коммутирует:</p>

<p>Если в этой категории существует конечный объект, то он является экспонентой. А функция <span class="math"><em>c</em><em>u</em><em>r</em><em>r</em><em>y</em></span> является анаморфизмом для экспоненты.</p>
<h2 id="краткое-содержание">Краткое содержание</h2>
<p>Теория категорий изучает понятия через то как эти понятия взаимодействуют друг с другом. Мы забываем о том, как эти понятия реализованы, а смотрим лишь на свойства связей.</p>
<p>Мы узнали что такое категория. Категория это структура с объектами и стрелками. Стрелки связывают объекты. Причём связи могут соединятся. Также считается, что объект всегда связан сам с собой. Мы узнали, что есть такие категории, в которых сами категории являются объектами, а стрелки в таких категориях мы назвали функторами. Также мы узнали, что сами функторы могут стать объектами в некоторой категории, тогда стрелки в этой категории мы будем называть естественными преобразованиями.</p>
<p>Мы узнали что такое начальный и конечный объект и как с помощью этих понятий можно определить сумму и произведение типов. Также мы узнали как в теории категорий описываются функции высших порядков.</p>
<h2 id="упражнения">Упражнения</h2>
<ul>
<li><p>Проверьте аксиомы категории (ассоциативность и тождество) для категории функторов и категории естественных преобразований.</p></li>
<li><p>Изоморфизмом называют такие стрелки <span class="math">$f:A \Ra B$</span> и <span class="math">$g : B \Ra A$</span>, для которых выполнено свойство:</p>
<p><br /><span class="math">$f \Co g = id_A$</span><br /> <br /><span class="math">$g \Co f = id_B$</span><br /></p>
<p>Объекты <span class="math"><em>A</em></span> и <span class="math"><em>B</em></span> называют изоморфными, если они связаны изоморфизмом, это обозначают так: <span class="math"><em>A</em> ≅ <em>B</em></span>. Докажите, что все начальные и конечные элементы изоморфны.</p></li>
<li><p>Поскольку сумма и произведение типов являются начальным и конечным объектами в специальных категориях для них также выполняются свойства тождества, уникальности и слияния. Выпишите эти свойства для суммы и произведения.</p></li>
<li><p>Подумайте как можно определить экземпляр класса \In{Comonad} для потоков:</p>

\begin{code}
data Stream a = a :& Stream a
\end{code}

<p>Можно ли придумать экземпляр для класса \In{Monad}?</p></li>
<li><p>Дуальную категорию для категории <span class="math">$\CatA$</span> обозначают <span class="math">$\CatA^{op}$</span>. Если <span class="math"><em>F</em></span> является функтором в категории <span class="math">$\CatA^{op}$</span>, то в исходной категории его называют <em>контравариантным</em> функтором. Выпишите определение функтора в <span class="math">$\CatA^{op}$</span>, а затем с помощью дуализации получите свойства контравариантного функтора в исходной категории <span class="math">$\CatA$</span>.</p></li>
</ul>
</body>
</html>
