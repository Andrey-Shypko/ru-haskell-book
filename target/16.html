<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<!-- Switch argument character to $ to escape |  -->









<h1 id="категориальные-типы">Категориальные типы</h1>
<p>В этой главе мы узнаем как в теории категорий определяются типы. В теории категорий типы определяются как начальные и конечные объекты в специальных категориях, которые называются алгебрами функторов. Для понимания этой главы хорошо освежить в памяти главу о структурной рекурсии, там где мы говорили о свёртках и развёртках.</p>
<h2 id="программирование-в-стиле-оригами">Программирование в стиле оригами</h2>
<p>Оригами – состоит из двух слов “свёртка” и “бумага”. При программировании в стиле оригами все функции строятся через функции свёртки и развёртки. Есть даже такие языки программрования, в которых это единственный способ определения рекурсии. Этот стиль очень хорошо подходит для ленивых языков программирования, поскольку в связке:</p>

\begin{code}
fold f . unfold g
\end{code}


<p>функции свёртки и развёртки работают синхронно. Функция развёртки не производит новых элементов до тех пор пока они не понадобятся во внешней функции свёртки.</p>
<p>Помните в одной из глав мы говорили о том, что рекурсивные функции можно определять через функцию \In{fix}.<br />Например так выглядит рекурсивная функция сложения всех чисел от одного до \In{n}:</p>

\begin{code}
sumInt :: Int -> Int
sumInt 0 = 0
sumInt n = n + sumInt (n-1)
\end{code}

<p>Эту функцию мы можем переписать с помощью функции \In{fix}. При вычислении \In{fix f} будет составлено значение</p>

\begin{code}
f (f (f (f ...)))
\end{code}

<p>Теперь перепишем функцию \In{sumInt} через \In{fix}:</p>

\begin{code}
sumInt = fix $ \f n ->
    case n of 
        0   -> 0
        n   -> n + f (n - 1)    
\end{code}

<p>Смотрите лямбда функция в аргументе \In{fix} принимает функцию и число, а возвращает число. Тип этой функции \In{(Int -> Int) -> (Int -> Int)}. После применения функции \In{fix} мы как раз и получим функцию типа \In{Int -> Int}. В лямбда функции рекурсивный вызов был заменён на вызов функции-параметра \In{f}.</p>
<p>Оказывается, что этот приём может быть применён и для рекурсивных типов данных. Мы можем создать обобщённый тип, который обозначает рекурсивный тип:</p>

\begin{code}
newtype Fix f = Fix { unFix :: f (Fix f) }
\end{code}

<p>В этой записи мы получаем уравнение неподвижной точки \In{Fix f = f (Fix f)}, где \In{f} это некоторый тип с параметром. Определим тип целых чисел:</p>

\begin{code}
data N a = Zero | Succ a

type Nat = Fix N
\end{code}

<p>Теперь создадим несколько конструкторов:</p>

\begin{code}
zero :: Nat
zero = Fix Zero

succ :: Nat -> Nat
succ = Fix . Succ
\end{code}

<p>Сохраним эти определения в модуле \In{Fix.hs} и посмотрим в интерпретаторе на значения и их типы, ghc не сможет вывести экземпляр \In{Show} для типа \In{Fix}, потому что он зависит от типа с параметром, а не от конкретного типа. Для решения этой проблемы нам придётся определить экземпляры вручную и подключить несколько расширений языка. Помните в главе о ленивых вычислениях мы подключали расширение \In{BangPatterns}? Нам понадобятся:</p>

\begin{code}
{-# Language FlexibleContexts, UndecidableInstances #-}
\end{code}

<p>Теперь определим экземпляры для \In{Show} и \In{Eq}:</p>

\begin{code}
instance Show (f (Fix f)) => Show (Fix f) where
    show x = "(" ++ show (unFix x) ++ ")"

instance Eq (f (Fix f)) => Eq (Fix f) where
    a == b = unFix a == unFix b
\end{code}

<p>Определим списки-оригами:</p>

\begin{code}
data L a b = Nil | Cons a b
    deriving (Show)

type List a = Fix (L a)

nil :: List a
nil = Fix Nil

infixr 5 `cons`

cons :: a -> List a -> List a
cons a = Fix . Cons a
\end{code}

<p>В типе \In{L} мы заменили рекурсивный тип на параметр. Затем в записи \In{List a = Fix (L a)} мы производим замыкание по параметру. Мы бесконечно вкладываем тип \In{L a} во второй параметр. Так получается рекурсивный тип для списков. Составим какой-нибудь список:</p>

\begin{code}
*Fix> :r
[1 of 1] Compiling Fix              ( Fix.hs, interpreted )
Ok, modules loaded: Fix.
*Fix> 1 `cons` 2 `cons` 3 `cons` nil
(Cons 1 (Cons 2 (Cons 3 (Nil))))
\end{code}

<p>Спрашивается, зачем нам это нужно? Зачем нам записывать рекурсивные типы через тип \In{Fix}? Оказывается при такой записи мы можем построить универсальные функции \In{fold} и \In{unfold}, они будут работать для любого рекурсивного типа.</p>
<p>Помните как мы составляли функции свёртки? Мы строили воображаемый класс, в котором сворачиваемый тип заменялся на параметр. Например для списка мы строили свёртку так:</p>

\begin{code}
class [a] b where
    (:) :: a -> b -> b
    []  :: b
\end{code}

<p>После этого мы легко получали тип для функции свёртки:</p>

\begin{code}
foldr :: (a -> b -> b) -> b -> ([a] -> b)
\end{code}

<p>Она принимает методы воображаемого класса, в котором тип записан с параметром, а возвращает функцию из рекурсивного типа в тип параметра.</p>
<p>Сейчас мы выполняем эту процедуру замены рекурсивного типа на параметр в обратном порядке. Сначала мы строим типы с параметром, а затем получаем из них рекурсивные типы с помощью конструкции \In{Fix}. Теперь методы класса с параметром это наши конструкторы исходных классов, а рекурсивный тип записан через \In{Fix}. Если мы сопоставим два способа, то мы сможем получить такой тип для функции свёртки:</p>

\begin{code}
fold :: (f b -> b) -> (Fix f -> b)
\end{code}

<p>Смотрите функция свёртки по-прежнему принимает методы воображаемого класса с параметром, но теперь класс перестал быть воображаемым, он стал типом с параметром. Результатом функции свёртки будет функция из рекурсивного типа \In{Fix f} в тип параметр.</p>
<p>Аналогично строится и функция \In{unfold}:</p>

\begin{code}
unfold :: (b -> f b) -> (b -> Fix f)
\end{code}

<p>В первой функции мы указываем один шаг разворачивания рекурсивного типа, а функция развёртки рекурсивно распространяет этот один шаг на потенциально бесконечную последовательность применений этого одного шага.</p>
<p>Теперь давайте определим эти функции. Но для этого нам понадобится от типа \In{f} одно свойство. Он должен быть функтором, опираясь на это свойство, мы будем рекурсивно обходить этот тип.</p>

\begin{code}
fold :: Functor f => (f a -> a) -> (Fix f -> a)
fold f = f . fmap (fold f) . unFix
\end{code}

<p>Проверим эту функцию по типам. Для этого нарисуем схему композиции:</p>

<p>Сначала мы разворачиваем обёртку \In{Fix} и получаем значение типа \In{f (Fix f)}, затем с помощью \In{fmap} мы внутри типа \In{f} рекурсивно вызываем функцию свёртки и в итоге получаем значение \In{f a}, на последнем шаге мы выполняем свёртку на текущем уровне вызовом функции \In{f}.</p>
<p>Аналогично определяется и функция \In{unfold}. Только теперь мы сначала развернём первый уровень, затем рекурсивно вызовем развёртку внутри типа \In{f} и только в самом конце завернём всё в тип \In{Fix}:</p>

\begin{code}
unfold :: Functor f => (a -> f a) -> (a -> Fix f)
unfold f = Fix . fmap (unfold f) . f
\end{code}

<p>Схема композиции:</p>

<p>Возможно вы уже догадались о том, что функция \In{fold} дуальна по отношению к функции \In{unfold}, это особенно наглядно отражается на схеме композиции. При переходе от \In{fold} к \In{unfold} мы просто перевернули все стрелки заменили разворачивание типа \In{Fix} на заворачивание в \In{Fix}.</p>
<p>Определим несколько функций для натуральных чисел и списков в стиле оригами. Для начала сделаем \In{L} и \In{N} экземпляром класса \In{Functor}:</p>

\begin{code}
instance Functor N where
    fmap f x = case x of
        Zero    -> Zero
        Succ a  -> Succ (f a)

instance Functor (L a) where
    fmap f x = case x of
        Nil         -> Nil
        Cons a b    -> Cons a (f b)
\end{code}

<p>Это всё что нам нужно для того чтобы начать пользоваться функциями свёртки и развёртки! Определим экземпляр \In{Num} для натуральных чисел:</p>

\begin{code}
instance Num Nat where
    (+) a = fold $ \x -> case x of
            Zero    -> a
            Succ x  -> succ x

    (*) a = fold $ \x -> case x of
            Zero    -> zero
            Succ x  -> a + x

    fromInteger = unfold $ \n -> case n of
            0   -> Zero
            n   -> Succ (n-1)

    abs = undefined
    signum = undefined
\end{code}

<p>Сложение и умножение определены через свёртку, а функция построения натурального числа из числа типа \In{Integer} определена через развёртку. Сравните с теми функциями, которые мы писали в главе про структурную рекурсию. Теперь мы не передаём отдельно две функции, на которые мы будем заменять конструкторы. Эти функции закодированы в типе с параметром. Для того чтобы этот код заработал нам придётся добавить ещё одно расширение \In{TypeSynonymInstances} наши рекурсивные типы являются синонимами, а не новыми типами. В рамках стандарта Haskell мы можем определять экземпляры только для новых типов, для того чтобы обойти это ограничение мы добавим ещё одно расширение.</p>

\begin{code}
*Fix> succ $ 1+2
(Succ (Succ (Succ (Succ (Zero)))))
*Fix> ((2 * 3) + 1) :: Nat
(Succ (Succ (Succ (Succ (Succ (Succ (Succ (Zero))))))))
*Fix> 2+2 == 2*(2::Nat)
True
\end{code}

<p>Определим функции на списках. Для начала определим две вспомогательные функции, которые извлекают голову и хвост списка:</p>

\begin{code}
headL :: List a -> a
headL x = case unFix x of
    Nil         -> error "empty list"
    Cons a _    -> a

tailL :: List a -> List a
tailL x = case unFix x of
    Nil         -> error "empty list"
    Cons a b    -> b
\end{code}

<p>Теперь определим несколько новых функций:</p>

\begin{code}
mapL :: (a -> b) -> List a -> List b
mapL f = fold $ \x -> case x of
    Nil         -> nil
    Cons a b    -> f a `cons` b

takeL :: Int -> List a -> List a
takeL = curry $ unfold $ \(n, xs) -> 
    if n == 0 then Nil
              else Cons (headL xs) (n-1, tailL xs)
\end{code}

<p>Сравните эти функции с теми, что мы определяли в главе о структурной рекурсии. Проверим работают ли эти функции:</p>

\begin{code}
*Fix> :r
[1 of 1] Compiling Fix              ( Fix.hs, interpreted )
Ok, modules loaded: Fix.
*Fix> takeL 3 $ iterateL (+1) zero
(Cons (Zero) (Cons (Succ (Zero)) (Cons (Succ (Succ (Zero))) (Nil))))
*Fix> let x = 1 `cons` 2 `cons` 3 `cons` nil
*Fix> mapL (+10) $ x `concatL` x
(Cons 11 (Cons 12 (Cons 13 (Cons 11 (Cons 12 (Cons 13 (Nil)))))))
\end{code}

<p>Обратите внимание, на то что с большими буквами мы пишем \In{Cons} и \In{Nil} когда хотим закодировать функции для свёртки-развёртки, а с маленькой буквы пишем значения рекурсивного типа. Надеюсь, что вы разобрались на примерах как устроены функции \In{fold} и \In{unfold}, потому что теперь мы перейдём к теории, которая за этим стоит.</p>
<h2 id="индуктивные-и-коиндуктивные-типы">Индуктивные и коиндуктивные типы</h2>
<p>С точки зрения теории категорий функция свёртки является катаморфизмом, а функция развёртки – анаморфизмом. Напомню, что катаморфизм – это функция которая ставит в соответствие объектам категории с начальным объектом стрелки, которые начинаются из начального объекта, а заканчиваются в данном объекте. Анаморфизм – это перевёрнутый наизнанку катаморфизм.</p>
<p>Начальным и конечным объектом будет рекурсивный тип. Вспомним тип свёртки:</p>

\begin{code}
fold :: Functor f => (f a -> a) -> (Fix f -> a)
\end{code}

<p>Функция свёртки строит функции, которые ведут из рекурсивного типа в произвольный тип, поэтому в данном случае рекурсивный тип будет начальным объектом. Функция развёртки строит из произвольного типа данный рекурсивный тип, на языке теории категорий она строит стрелку из произвольного объекта в рекурсивный, это означает что рекурсивный тип будет конечным объектом.</p>

\begin{code}
unfold :: Functor f => (a -> f a) -> (a -> Fix f)
\end{code}

<p>Категории, которые определяют рекурсивные типы таким образом называются (ко)алгебрами функторов. Видите в типе и той и другой функции стоит требование о том, что \In{f} является функтором. Катаморфизм и анаморфизм отображают объекты в стрелки. По типу функций \In{fold} и \In{unfold} мы можем сделать вывод, что объектами в нашей категории будут стрелки вида</p>

\begin{code}
f a -> a
\end{code}

<p>или для свёрток:</p>

\begin{code}
a -> f a
\end{code}

<p>А стрелками будут обычные функции одного аргумента. Теперь дадим более формальное определение.</p>
<p>Эндофунктор <span class="math">$F : \CatA \Ra \CatA$</span> определяет стрелки <span class="math">$\alpha : FA \Ra A$</span>, которые называется <span class="math"><em>F</em></span>-<em>алгебрами</em>. Стрелку <span class="math">$h : A \Ra B$</span> называют <span class="math"><em>F</em></span>-<em>гомоморфизмом</em>, если следующая диаграмма коммутирует:</p>

<p>Или можно сказать по другому, для <span class="math"><em>F</em></span>-алгебр <span class="math">$\alpha:FA \Ra A$</span> и <span class="math">$\beta : FB \Ra B$</span> выполняется:</p>
<p><br /><span class="math">$Fh \Co \beta = \alpha \Co h$</span><br /></p>
<p>Это свойство совпадает со свойством естественного преобразования только вместо одного из функторов мы подставили тождественный функтор <span class="math"><em>I</em></span>. Определим категорию <span class="math">$\Alg$</span>, для категории <span class="math">$\CatA$</span> и эндофунктора <span class="math">$F : \CatA \Ra \CatA$</span></p>
<ul>
<li><p>Объектами являются <span class="math"><em>F</em></span>-алгебры <span class="math">$FA \Ra A$</span>, где <span class="math"><em>A</em></span> – объект категории <span class="math">$\CatA$</span></p></li>
<li><p>Два объекта <span class="math">$\alpha : FA \Ra A$</span> и <span class="math">$\beta : FB \Ra B$</span> соединяет <span class="math"><em>F</em></span>-гомоморфизм <span class="math">$h : A \Ra B$</span>. Это такая стрелка из <span class="math">$\CatA$</span>, для которой выполняется:</p></li>
</ul>
<p><br /><span class="math">$Fh \Co \beta = \alpha \Co h$</span><br /></p>
<ul>
<li>Композиция и тождественная стрелка взяты из категории <span class="math">$\CatA$</span>.</li>
</ul>
<p>Если в этой категории есть начальный объект <span class="math">$in_F : FT \Ra T$</span>, то определён катаморфизм, который переводит объекты <span class="math">$FA \Ra A$</span> в стрелки <span class="math">$T \Ra A$</span>. Причём следующая диаграмма коммутирует:</p>

<p>Этот катаморфизм и будет функцией свёртки для рекурсивного типа <span class="math"><em>Т</em></span>. Понятие <span class="math">$\Alg$</span> можно перевернуть и получить категорию <span class="math">$\CoAlg$</span>.</p>
<ul>
<li><p>Объектами являются <span class="math"><em>F</em></span>-коалгебры <span class="math">$A \Ra FA$</span>, где <span class="math"><em>A</em></span> – объект категории <span class="math">$\CatA$</span></p></li>
<li><p>Два объекта <span class="math">$\alpha : FA \Ra A$</span> и <span class="math">$\beta : FB \Ra B$</span> соединяет <span class="math"><em>F</em></span>-когомоморфизм . Это такая стрелка из <span class="math">$\CatA$</span>, для которой выполняется:</p>
<p><br /><span class="math">$h \Co \alpha = \beta \Co Fh$</span><br /></p></li>
<li><p>Композиция и тождественная стрелка взяты из категории <span class="math">$\CatA$</span>.</p></li>
</ul>
<p>Если в этой категории есть конечный объект, его называют <span class="math">$out_F : T \Ra FT$</span>, то определён анаморфизм, который переводит объекты <span class="math">$A \Ra FA$</span> в стрелки <span class="math">$A \Ra T$</span>.<br />Причём следующая диаграмма коммутирует:</p>

<p>Если для категории <span class="math">$\CatA$</span> и функтора <span class="math"><em>F</em></span> определены стрелки <span class="math"><em>i</em><em>n</em><sub><em>F</em></sub></span> и <span class="math"><em>o</em><em>u</em><em>t</em><sub><em>F</em></sub></span>, то они являются взаимнообратными и определяют изоморфизм <span class="math"><em>T</em> ≅ <em>F</em><em>T</em></span>. Часто объект <span class="math"><em>T</em></span> в случае <span class="math">$\Alg$</span> обозначают <span class="math"><em>μ</em><sub><em>F</em></sub></span>, поскольку начальный объект определяется функтором <span class="math"><em>F</em></span>, а в случае <span class="math">$\CoAlg$</span> обозначают <span class="math"><em>ν</em><sub><em>F</em></sub></span>.</p>
<p>Типы, которые являются начальными объектами, принято называть индуктивными, а типы, которые являются конечными объектами – коиндуктивными.</p>
<h3 id="существование-начальных-и-конечных-объектов">Существование начальных и конечных объектов</h3>
<p>Мы говорили, что если начальный(конечный) объект существует, а когда он существует? Рассмотрим один важный случай. Если категория является категорией, в которой объектами являются полные частично упорядоченные множества, а стрелками являются монотонные функции, такие категории называют <span class="math"><strong>CPO</strong></span>, и функтор – полиномиальный, то начальный и конечный объекты существуют.</p>
<h4 id="полные-частично-упорядоченные-множества">Полные частично упорядоченные множества</h4>
<p>Оказывается на значениях можно ввести частичный порядок. Порядок называется частичным, если отношение <span class="math"> ≤ </span> определено не для всех элементов, а лишь для некоторых из них. Частичный порядок на значениях отражает степень неопределённости значения. Самый маленький объект это полностью неопределённое значение <span class="math">⊥</span>. Любое значение типа содержит больше определённости чем <span class="math">⊥</span>.</p>
<p>Для того чтобы не путать упорядочивание значений по степени определённости с обычным числовым порядком, пользуются специальным символом <span class="math"> ⊑ </span>. Запись</p>
<p><br /><span class="math"><em>a</em> ⊑ <em>b</em></span><br /></p>

<p>означает, что <span class="math"><em>b</em></span> более определено (или информативнее) чем <span class="math"><em>a</em></span>.</p>
<p>Так для логических значений определены два нетривиальных сравнения:</p>
<p><br /><span class="math">$data\ Bool\ =\ True \Or False$</span><br /></p>
<p><br /><span class="math">⊥ ⊑ <em>T</em><em>r</em><em>u</em><em>e</em></span><br /> <br /><span class="math">⊥ ⊑ <em>F</em><em>a</em><em>l</em><em>s</em><em>e</em></span><br /></p>
<p>Мы будем называть нетривиальными сравнения в которых, компоненты слева и справа от <span class="math"> ⊑ </span> не равны. Например ясно, что <span class="math"><em>T</em><em>r</em><em>u</em><em>e</em> ⊑ <em>T</em><em>r</em><em>u</em><em>e</em></span> или <span class="math">⊥ ⊑ ⊥</span>. Это тривиальные сравнения и мы их будем лишь подразумевать. Считается, что если два значения определены полностью, то мы не можем сказать какое из них информативнее. Так к примеру для логических значений мы не можем сказать какое значение более определено <span class="math"><em>T</em><em>r</em><em>u</em><em>e</em></span> или <span class="math"><em>F</em><em>a</em><em>l</em><em>s</em><em>e</em></span>.</p>
<p>Рассмотрим пример по-сложнее. Частично определённые значения:</p>
<p><br /><span class="math">$data\ Maybe\ a = Nothing \Or Just\ a$</span><br /></p>
<p><br /><span class="math">$\begin{array}{l@{\ \sqsubseteq \ }l}
    \bot &amp; Nothing \\
    \bot &amp; Just\ \bot \\
    \bot &amp; Just\ a \\
    Just\ a &amp; Just\ b,\qquad \text{если } a \sqsubseteq b    
\end{array}$</span><br /></p>
<p>Если вспомнить как происходит вычисление значения, то значение <span class="math"><em>a</em></span> менее определено чем <span class="math"><em>b</em></span>, если взрывное значение <span class="math">⊥</span> в <span class="math"><em>a</em></span> находится ближе к корню значения, чем в <span class="math"><em>b</em></span>. Итак получается, что в категории <span class="math"><strong>Hask</strong></span> объекты это множества с частичным порядком. Что означает требование монотонности функции?<br />Монотонность в контексте операции <span class="math"> ⊑ </span> говорит о том, что чем больше определён вход функции тем больше определён выход:</p>
<p><br /><span class="math">$a \sqsubseteq b \quad \RA \quad f\ a \sqsubseteq f\ b$</span><br /></p>
<p>Это требование накладывает запрет на возможность проведения сопоставления с образцом по значению <span class="math">⊥</span>. Иначе мы можем определять немонотонные функции вроде:</p>

\begin{code}
isBot :: Bool -> Bool
isBot undefined = True
isBot _         = undefined
\end{code}

<p>Полнота частично упорядоченного множества означает, что у любой последовательности <span class="math"><em>x</em><sub><em>n</em></sub></span></p>
<p><br /><span class="math"><em>x</em><sub>0</sub> ⊑ <em>x</em><sub>1</sub> ⊑ <em>x</em><sub>2</sub> ⊑ . . . </span><br /></p>

<p>есть значение <span class="math"><em>x</em></span>, к которому она сходится. Это значение называют супремумом множества. Что такое полные частично упорядоченные множества мы разобрались. А что такое полиномиальный функтор?</p>
<h4 id="полиномиальный-функтор">Полиномиальный функтор</h4>
<p>Полиномиальный функтор – это функтор который построен лишь с помощью операций суммы, произведения, постоянных функторов, тождественного фуктора и композиции функторов. Определим эти операции:</p>
<ul>
<li><p>Сумма функторов <span class="math"><em>F</em></span> и <span class="math"><em>G</em></span> определяется через операцию суммы объектов:</p>
<p><br /><span class="math">(<em>F</em> + <em>G</em>)<em>X</em> = <em>F</em><em>X</em> + <em>G</em><em>X</em></span><br /></p></li>
<li><p>Произведение функторов <span class="math"><em>F</em></span> и <span class="math"><em>G</em></span> определяется через операцию произведения объектов:</p>
<p><br /><span class="math">(<em>F</em> × <em>G</em>)<em>X</em> = <em>F</em><em>X</em> × <em>G</em><em>X</em></span><br /></p></li>
<li><p>Постоянный функтор отображает все объекты категории в один объект, а стрелки в тождественнубю стрелку этого объекта, мы будем обозначать постоянный функтор подчёркиванием:</p></li>
</ul>

<ul>
<li>Тождественный функтор оставляет объекты и стрелки неизменными:</li>
</ul>

<ul>
<li><p>Композиция функторов <span class="math"><em>F</em></span> и <span class="math"><em>G</em></span> это последовательное применение функторов</p>
<p><br /><span class="math"><em>F</em><em>G</em><em>X</em> = <em>F</em>(<em>G</em><em>X</em>)</span><br /></p></li>
</ul>
<p>По определению функции построенные с помощью этих операций называют полиномиальными. Определим несколько типов данных с помощью полиномиальных функторов. Определим логические значения:</p>
<p><br /><span class="math">$Bool = \mu(\underline{1} + \underline{1})$</span><br /></p>
<p>Объект <span class="math">1</span> обозначает любую константу, это конечный объект исходной категории. Нам не важны имена конструкторов, но важна структура типа. <span class="math"><em>μ</em></span> обозначает начальный объект в <span class="math"><em>F</em></span>-алгебре.</p>
<p>Определим натуральные числа:</p>
<p><br /><span class="math">$Nat = \mu(\underline{1} + I)$</span><br /></p>
<p>Эта запись обозначает начальный объект для <span class="math"><em>F</em></span>-алгебры с функтором <span class="math">$F=\underline{1}+I$</span>. Посмотрим на определение списка:</p>
<p><br /><span class="math">$List_A = \mu(\underline{1} + \underline{A} \times I)$</span><br /></p>
<p>Список это начальный объект <span class="math"><em>F</em></span>-алгебры <span class="math">$\underline{1}+\underline{A}\times I$</span>. Также можно определить бинарные деревья:</p>
<p><br /><span class="math">$BTree_A = \mu(\underline{A} + I \times I )$</span><br /></p>
<p>Определим потоки:</p>
<p><br /><span class="math">$Stream_A = \nu (\underline{A} \times I)$</span><br /></p>
<p>Потоки являются конечным объектом <span class="math"><em>F</em></span>-коалгебры, где <span class="math">$F= \underline{A} \times I$</span>.</p>
<h2 id="гиломорфизм">Гиломорфизм</h2>
<p>Оказывается, что с помощью катаморфизма и анаморфизма мы можем определить функцию \In{fix}, т.е.~мы можем выразить любую рекурсивную функцию с помощью структурной рекурсии.</p>
<p>Функция \In{fix} строит бесконечную последовательность применений некоторой функции \In{f}.</p>

\begin{code}
f (f (f ...)))
\end{code}

<p>Сначала с помощью анаморфизма мы построим бесконечный список, который содержит функцию \In{f} во всех элементах:</p>

\begin{code}
repeat f = f : f : f : ...
\end{code}

<p>А затем заменим конструктор \In{:} на применение. В итоге мы получим такую функцию:</p>

\begin{code}
fix :: (a -> a) -> a
fix = foldr ($) undefined . repeat 
\end{code}

<p>Убедимся, что эта функция работает:</p>

\begin{code}
Prelude> let fix = foldr ($) undefined . repeat
Prelude> take 3 $ y (1:)
[1,1,1]
Prelude> fix (\f n -> if n==0 then 0 else n + f (n-1)) 10
55
\end{code}

<p>Теперь давайте определим функцию \In{fix} через функции \In{cata} и \In{ana}:</p>

\begin{code}
fix :: (a -> a) -> a
fix = cata (\(Cons f a) -> f a) . ana (\a -> Cons a a)
\end{code}

<p>Эта связка анаморфизм с последующим катаморфизмом встречается так часто, что ей дали специальное имя. <em>Гиломорфизмом</em> называют функцию:</p>

\begin{code}
hylo :: Functor f => (f b -> b) -> (a -> f a) -> (a -> b) 
hylo phi psi = cata phi . ana psi
\end{code}

<p>Отметим, что эту функцию можно выразить и по-другому:</p>

\begin{code}
hylo :: Functor f => (f b -> b) -> (a -> f a) -> (a -> b) 
hylo phi psi = phi . (fmap $ hylo phi psi) . psi
\end{code}

<p>Этот вариант более эффективен по расходу памяти, мы не строим промежуточное значение \In{Fix f}, а сразу обрабатываем значения в функции \In{phi} по ходу их построения в функции \In{psi}. Давайте введём инфиксную операцию гиломорфизм для этого определения:</p>

\begin{code}
(>>) :: Functor f => (a -> f a) -> (f b -> b) -> (a -> b) 
psi >> phi = phi . (fmap $ hylo phi psi) . psi
\end{code}

<p>Теперь давайте скроем одноимённую функцию из \In{Prelude} и определим несколько рекурсивных функций с помощью гиломорфизма. Начнём с функции вычисления суммы чисел от нуля до данного числа:</p>

\begin{code}
sumInt :: Int -> Int
sumInt = range >> sum
    
sum x = case x of
    Nil      -> 0 
    Cons a b -> a + b

range n 
    | n == 0    = Nil 
    | otherwise = Cons n (n-1)
\end{code}

<p>Сначала мы создаём в функции \In{range} список всех чисел от данного числа до нуля. А затем в функции \In{sum} складываем значения. Теперь мы можем легко определить функцию вычисления факториала:</p>

\begin{code}
fact :: Int -> Int
fact = range >> prod
    
prod x = case x of
    Nil      -> 1 
    Cons a b -> a * b
\end{code}

<p>Напишем функцию, которая извлекает из потока n-тый элемент. Сначала определим тип для потока:</p>

\begin{code}
type Stream a = Fix (S a)

data S a b = a :& b
    deriving (Show, Eq)

instance Functor (S a) where
    fmap f (a :& b) = a :& f b  


headS :: Stream a -> a
headS x = case unFix x of
    (a :& _) -> a


tailS :: Stream a -> Stream a
tailS x = case unFix x of
    (_ :& b) -> b
\end{code}

<p>Теперь функцию извлечения элемента:</p>

\begin{code}
getElem :: Int -> Stream a -> a
getElem = curry (enum >> elem) 
    where elem ((n, a) :& next) 
                | n == 0    = a
                | otherwise = next
          enum (a, st) = (a, headS st) :& (a-1, tailS st)
\end{code}

<p>В функции \In{enum} мы добавляем к элементам потока убывающую последовательность чисел, она стартует из данного числа. Элемент, который нам нужен, будет содержать в этой последовательности число ноль. В функции \In{elem} мы как раз и извлекаем тот элемент рядом с которым хранится число ноль. Обратите внимание на то, что рекурсия встроена в этот алгоритм, если данное число не равно нулю, мы просто извлекаем следующий элемент.</p>
<p>С помощью этой функции мы можем вычислить n-тое число из ряда чисел Фибоначчи. Сначала создадим поток чисел Фибоначчи:</p>

\begin{code}
fibs :: Stream Int
fibs = ana (\(a, b) -> a :& (b, a+b)) (0, 1)
\end{code}

<p>Теперь просто извлечём n-тый элемент из потока чисел Фибоначчи:</p>

\begin{code}
fib :: Int -> Int
fib = flip getElem fibs
\end{code}

<p>Вычислим поток всех простых чисел. Мы будем вычислять его по алгоритму “решето Эратосфена”. В начале алгоритма у нас есть поток целых чисел и известно, что первое число является простым.</p>
<p>2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 …</p>
<p>В процессе этого алгоритма мы вычёркиваем все не простые числа. Сначала мы ищем первое не зачёркнутое число и помещаем его в результирующий поток, а на следующий шаг алгоритма мы передаём исходный, поток в котором зачёркнуты все числа кратные тому, что мы положили последним:</p>
<p>2</p>
<p>3, <del>4</del>, 5, <del>6</del>, 7, <del>8</del>, 9, <del>10</del>, 11, <del>12</del>, 13, <del>14</del>, 15, …</p>
<p>Теперь мы ищем первое незачёркнутое число и помещаем его в результат. А на следующий шаг рекусии передаём поток, в котором зачёркнуты все числа кратные новому простому числу:</p>
<p>2, 3</p>
<p><del>4</del>, 5, <del>6</del>, 7, <del>8</del>, <del>9</del>, <del>10</del>, <del>12</del>, 13, <del>14</del>, <del>15</del>, …</p>
<p>И так далее, на каждом шаге мы будем получать одно простое число. Зачёркивание мы будем имитировать с помощью типа \In{Maybe}. Всё начинается с потока целых чисел, в котором не зачёркнуто ни одно число:</p>

\begin{code}
nums :: Stream (Maybe Int)
nums = mapS Just $ iterateS (+1) 2 

mapS :: (a -> b) -> Stream a -> Stream b
mapS f = ana $ \xs -> (f $ headS xs) :& tailS xs

iterateS :: (a -> a) -> a -> Stream a
iterateS f = ana $ \x -> x :& f x
\end{code}

<p>В силу ограничений системы типов Haskell мы не можем определить экземпляр \In{Functor} для типа \In{Stream}, поскольку \In{Stream} является не самостоятельным типом а типом-синонимом. Поэтому нам приходится определить функцию \In{mapS}. Определим шаг рекурсии:</p>

\begin{code}
primes :: Stream Int
primes = ana erato nums

erato xs = n :& erase n ys
    where n  = fromJust $ headS xs  
          ys = dropWhileS isNothing xs
\end{code}

<p>Переменная \In{n} содержит первое не зачёркнутое число на данном шаге. Переменная \In{ys} указывает на список чисел, из начала которого удалены все зачёркнутые числа. Функции \In{isNothing} и \In{fromJust} взяты из стандартного модуля \In{Data.Maybe}. Нам осталось определить лишь две функции. Это аналог функции \In{dropWhile} на списках. Эта функция удаляет из начала списка все элементы, которые удовлетворяют некоторому предикату. Вторая функция \In{erase} вычёркивает все числа в потоке кратные данному.</p>

\begin{code}
dropWhileS :: (a -> Bool) -> Stream a -> Stream a
dropWhileS p = psi >> phi 
    where phi ((b, xs) :& next) = if b then next else xs
          psi xs = (p $ headS xs, xs) :& tailS xs
\end{code}

<p>В этой функции мы сначала генерируем список пар, который содержит значения предиката и остатки списка, а затем находим в этом списке первый такой элемент, значение которого равно \In{False}.</p>

\begin{code}
erase :: Int -> Stream (Maybe a) -> Stream (Maybe a)
erase n xs = ana phi (0, xs)
    where phi (a, xs) 
            | a == 0    = Nothing  :& (a', tailS xs)
            | otherwise = headS xs :& (a', tailS xs)
            where a' = if a == n-1 then 0 else (a+1)
\end{code}

<p>В функции \In{erase} мы заменяем на \In{Nothing} каждый элемент, порядок следования которого кратен аргументу \In{n}. Проверим, что у нас получилось:</p>

\begin{code}
*Fix> primes 
(2 :& (3 :& (5 :& (7 :& (11 :& (13 :& (17 :& (19 :& (23 :& 
(29 :& (31 :& (37 :& (41 :& (43 :& (47 :& (53 :& (59 :& 
(61 :& (67 :& (71 :& (73 :& (79 :& (83 :& (89 :& (97 :& 
(101 :& (103 :& (107 :& (109 :& (113 :& (127 :& (131 :&
...
\end{code}

<h2 id="краткое-содержание">Краткое содержание</h2>
<p>В этой главе мы узнали, что любая рекурсивная функция может быть выражена через структурную рекурсию. Мы узнали как в теории категорий определяются типы. Типы являются начальными и конечными объектами в специальных категориях, которые называются алгебрами функторов. Слоган теории категорий гласит:</p>
<blockquote>
<p>Управляющие структуры определяются структурой типов.</p>
</blockquote>
<p>Определив тип, мы получаем вместе с ним две функции структурной рекурсии, это катаморфизм (для начальных объектов) и анаморфизм (для конечных объектов). С помощью катаморфизма мы можем сворачивать значение данного типа в значения любого другого типа, а с помощью анаморфизма мы можем разворачивать значения данного типа из значений любого другого типа. Также мы узнали, что категория <span class="math"><strong>Hask</strong></span> является категорией <span class="math"><strong>CPO</strong></span>, категорией полных частично упорядоченных множеств.</p>
<h2 id="упражнения">Упражнения</h2>
<ul>
<li><p>Потренируйтесь в определении рекурсивных функций через гиломорфизм. Попробуйте переписать как можно больше определений из главы о структурной рекурсии в терминах типа \In{Fix} и функций \In{cata}, \In{ana} и \In{hylo}. Также потренируйтесь на стандартных функциях из модуля \In{Prelude}. Определите новые типы через \In{Fix} например деревья из модуля \In{Data.Tree}. Попробуйте свои силы на функциях по-сложнее например алгоритме эвристического поиска.</p></li>
<li><p>Определите монадные версии рекурсивных функций:</p>

\begin{code}
cataM :: (Monad m, Traversable t) => (t a -> m a) -> Fix t -> m a
anaM  :: (Monad m, Traversable t) => (a -> m (t a)) -> (a -> m (Fix t))

hyloM :: (Monad m, Traversable t) => (t b -> m b) -> (a -> m (t a)) -> (a -> m b)
\end{code}

<p>С помощью этих функций мы, например, можем преобразовывать дерево выражения и при этом обновлять какое-нибудь состояние или читать из общего окружения.</p>
<p>В этом определении стоит новый класс \In{Traversable}. Разберитесь с ним самостоятельно. Немного подскажу. Этот класс появился вместе с классом \In{Applicative}. Когда разработчики поняли о существовании полезной абстракции, которая ослабляет класс \In{Monad}, они также обратили внимание на функцию \In{sequence}:</p>

\begin{code}
sequence :: Monad m => [m a] -> m [a]
sequence = foldr (liftM2 (:)) (return [])  
\end{code}

<p>Эту функцию можно записать с помощью одних лишь методов класса \In{Applicative}. Поэтому ограничение в контексте функции избыточно. Класс \In{Traversable} предназначени для устранения этой неточности. Посмотрим на основной метод класса:</p>

\begin{code}
class (Functor t, Foldable t) => Traversable t where
    traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
\end{code}

<p>Тип очень похож на тип функции \In{mapM}. И не случайно, ведь \In{mapM} определяется через \In{sequence}. Только теперь вместо списка стоит более общий тип. Это тип \In{Foldable}, который определяет список как нечто, на чём можно проводить операции свёртки.</p></li>
</ul>
</body>
</html>
