<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<h1 id="средства-разработки">Средства разработки</h1>
<p>В этой главе мы познакомимся с основными средствами разработки больших программ. Мы научимся устанавливать и создавать библиотеки, писать документацию.</p>
<h2 id="пакеты">Пакеты</h2>
<p>В Haskell есть ещё один уровень организации данных, мы можем объединять модули в <em>пакеты</em> (package). Также как и модули пакеты могут зависеть от других пакетов, если они пользуются модулями их этих пакетов. Одним пакетом мы уже пользовались и довольно часто, это пакет \In{base}, который содержит все стандартные модули, например такие как \In{Prelude}, \In{Control.Applicative} или \In{Data.Function}. Для создания и установки пакетов существует приложение \In{cabal}. Оно определяет протокол организации и распространения модулей Haskell.</p>
<h3 id="создание-пакетов">Создание пакетов</h3>
<p>Предположим, что мы написали программу, которая состоит из нескольких модулей. Пусть все модули хранятся в директории с именем \In{src}. Для того чтобы превратить набор модулей в пакет, нам необходимо поместить в одну директорию с \In{src} два файла:</p>
<ul>
<li><p>\In{имяПакета.cabal} – файл с описанием пакета.</p></li>
<li><p>\In{Setup.hs} – файл с инструкциями по установке пакета</p></li>
</ul>
<h4 id="cabal">.cabal</h4>
<p>Посмотрим на простейший файл с описанием библиотеки, этот файл находится в одной директории с той директорией, в которой содержатся все модули приложения и имеет расширение \In{.cabal}:</p>

\begin{code}
Name        : Foo
Version     : 1.0

Library
  build-depends     : base
  exposed-modules   : Foo
\end{code}

<p>Сначала идут свойства пакета. Общий формат определения свойства:</p>

\begin{code}
ИмяСвойства : Значение
\end{code}

<p>В примере мы указали имя пакета \In{Foo}, и версию \In{1.0}. После того, как мы указали все свойства, мы определяем будет наш пакет библиотекой или исполняемой программой или возможно он будет и тем и другим. Если пакет будет библиотекой, то мы помещаем за набором атрибутов слово \In{Library}, а если это исполняемая программа, то мы помещаем слово \In{Executable}, после мы пишем описание модулей пакета, зависимости от других пакетов, какие модули будут видны пользователю. Формат составления описаний в этой части такой же как и в самом начале файла. Сначала идёт зарезервированное слово-атрибут, затем через двоеточие следует значение. Обратите внимание на отступы за словом \In{Library}, они обязательны и сделаны с помощью <em>пробелов</em>, \In{cabal} не воспринимает табуляцию.</p>
<p>Файл \In{.cabal} может содержать комментарии, они делаются также как и в Haskell, закомментированная строка начинается с двойного тире.</p>
<h4 id="setup.hs">Setup.hs</h4>
<p>Файл \In{Setup.hs} содержит информацию о том как устанавливается библиотека. При установке могут использоваться другие программы и библиотеки. Пока мы будем пользоваться простейшим случаем:</p>

\begin{code}
import Distribution.Simple
main = defaultMain
\end{code}

<p>Этот файл позволяет нам создавать библиотеки и приложения, которые созданы только с помощью Haskell. Это не так уж и мало!</p>
<h3 id="создаём-библиотеки">Создаём библиотеки</h3>
<p>Типичный файл \In{.cabal} для библиотеки выглядит так:</p>

\begin{code}
Name:           pinocchio
Version:        1.1.1
Cabal-Version:  >= 1.2
License:        BSD3
License-File:   LICENSE
Author:         Mister Geppetto
Homepage:       http://pinocchio.sourceforge.net/
Category:       AI
Synopsis:       Tools for creation of woodcrafted robots
Build-Type:     Simple


Library
  Build-Depends: base
  Hs-Source-Dirs: src/  
  Exposed-modules:
    Wood.Robot.Act, Wood.Robot.Percept, Wood.Robot.Think
  Other-Modules:
    Wood.Robot.Internals
\end{code}

<p>Этим файлом мы описали библиотеку с именем \In{pinocchio}, версия 1.1.1, она использует версию \In{cabal} не ниже \In{1.2}. Библиотека выпущена под лицензией BSD3. Файл с лицензией находится в текущей директории под именем \In{LICENSE}. Автор библиотеки \In{Mister Geppetto}. Подробнее узнать о библиотеке можно на её домашней странице \In{http://pinocchio.sourceforge.net/}. Атрибут \In{Category} указывает на широкую отрасль знаний, к которой принадлежит наша библиотека. В данном случае мы описываем библиотеку для построения роботов из дерева, об этом мы пишем в атрибуте \In{Synopsis} (краткое описание), поэтому наша библиотека принадлежит к категории искусственный интеллект или сокращённо \In{AI}. Последний атрибут \In{Build-Type} указывает на тип сборки пакета. Мы будем пользоваться значением \In{Simple}, который соответствует сборке с помощью простейшего файла \In{Setup.hs}, который мы рассмотрели в предыдущем разделе.</p>
<p>После описания пакета, идёт слово \In{Library}, ведь мы создаём библиотеку. Далее в атрибуте \In{Build-Depends}<br />мы указываем зависимости для нашего пакета. Здесь мы перечисляем все пакеты, которые мы используем в своей библиотеке. В данном случае мы пользовались лишь стандартной библиотекой \In{base}. В атрибуте \In{hs-source-dirs} мы указываем, где искать директорию с исходным кодом библиотеки. Затем мы указываем три внешних модуля, они будут доступны пользователю после установки библиотеки (атрибут \In{Exposed-Modules}), и внутренние скрытые модули (атрибут \In{Other-Modules}).</p>
<h3 id="создаём-исполняемые-программы">Создаём исполняемые программы</h3>
<p>Типичный файл \In{.cabal} для исполняемой программы:</p>

\begin{code}
Name:           micro
Version:        0.0
Cabal-Version:  >= 1.2
License:        BSD3
Author:         Tony Reeds
Synopsis:       Small programming language
Build-Type:     Simple

Executable micro
  Build-Depends:  base, parsec
  Main-Is:        Main.hs
  Hs-Source-Dirs: micro

Executable micro-repl
  Main-Is:        Main.hs
  Build-Depends:  base, parsec
  Hs-Source-Dirs: repl
  Other-Modules:  Utils
\end{code}

<p>В этом файле мы описываем две программы. Компилятор языка и интерпретатор языка \In{micro}. Если сравнить этот файл с файлом для библиотеки, то мы заметим лишь один новый атрибут. Это \In{Main-Is}. Он указывает в каком модуле содержится функция \In{main}. После установки этого пакета будут созданы два исполняемых файла. С именами \In{micro} и \In{micro-repl}.</p>
<h3 id="установка-пакета">Установка пакета</h3>
<p>Пакеты устанавливаются с помощью команды \In{install}. Необходимо перейти в директорию пакета, ту, в которой находятся два служебных файла (\In{.cabal} и \In{Setup.hs}) и директория с исходниками, и запустить команду:</p>

\begin{code}
cabal install
\end{code}

<p>Если мы нигде не ошиблись в описании пакета, не перепутали табуляцию с пробелами при отступах, или указали без ошибок все зависимости, то пакет успешно установится. Если это библиотека, то мы сможем подключать экспортируемые ей модули в любом другом модуле, просто указав их в директиве \In{import}. При этом нам уже не важно, где находятся модули библиотеки. Мы имеем возможность импортировать их из любого модуля. Если же пакет был исполняемой программой, будут созданы бинарные файлы программ. В конце \In{cabal} сообщит нам куда он их положил.</p>
<p>Иногда возникают проблемы с пакетами, которые генерируют исполняемые файлы, а затем с их помощью устанавливают другие пакеты. Проблема возникает из-за того, что \In{cabal} может положить бинарный файл в директорию, которая не видна следующим программам, которые хотят продолжить установку. В этом случае необходимо либо переложить созданные бинарные файлы в директорию, которая будет им видна, или добавить директорию с новыми бинарными файлами в \In{PATH} (под UNIX, Linux). Переменная операционной системы PATH содержит список всех путей, в которых система ищет исполняемые программы, если путь не указан явно. Посмотреть содержание \In{PATH} можно, вызвав:</p>

\begin{verbatim}
$ echo $PATH
\end{verbatim}

<p>Появится строка директорий, которые записаны через двоеточие. Для того чтобы добавить директорию \In{/data/dir} в \In{PATH} необходимо написать:</p>

\begin{verbatim}
$ PATH=$PATH:/data/dir
\end{verbatim}

<p>Эта команда добавит директорию в \In{PATH} для текущей сессии в терминале, если мы хотим записать её насовсем, мы добавим эту команду в специальный скрытый файл \In{.bashrc}, он находится в домашней директории пользователя. Под Windows добавить директорию в \In{PATH} можно с помощью графического интерфейса. Кликните правой кнопкой мыши на иконку \In{My Computer} (Мой Компьютер), в появившемся меню выберите вкладку \In{Properties} (Свойства). Появится окно \In{System Properties} (Свойства системы), в нём выберите вкладку \In{Advanced} и там нажмите на кнопку \In{Environment variables} (Переменные среды). И в этом окне будет строка \In{Path}, её мы и хотим отредактировать, добавив необходимые нам пути.</p>
<p>Давайте потренируемся и создадим библиотеку и исполняемую программу. Создадим библиотеку, которая выводит на экран \In{Hello World}. Создадим директорию \In{hello}, и в ней создадим директорию \In{src}. Эта директория будет содержать исходный код. Главный модуль библиотеки экспортирует функцию приветствия:</p>

\begin{code}
module Hello where

import Utility.Hello(hello)
import Utility.World(world)

helloWorld = hello ++ ", " ++ world ++ "!"
\end{code}

<p>Главный модуль программы \In{Main.hs} определяет функцию \In{main}, которая выводит текст приветствия на экран:</p>

\begin{code}
module Main where

import Hello 

main = print helloWorld
\end{code}

<p>У нас будет два внутренних модуля, каждый из которых определяет синоним для одного слова. Мы поместим их в папку \In{Utility}. Это модуль \In{Utility.Hello}</p>

\begin{code}
module Utility.Hello where
hello = "Hello"
\end{code}

<p>И модуль \In{Utility.World}:</p>

\begin{code}
module Utility.World where
world = "World"
\end{code}

<p>Исходники готовы, теперь приступим к описанию пакета. Создадим в корневой директории пакета файл \In{hello.cabal}.</p>

\begin{code}
Name:           hello
Version:        1.0
Cabal-Version:  >= 1.2
License:        BSD3
Author:         Anton
Synopsis:       Little example of cabal usage
Category:       Example
Build-Type:     Simple

Library
  Build-Depends: base == 4.*
  Hs-Source-Dirs: src/
  Exposed-modules:
    Hello
  Other-Modules:
    Utility.Hello
    Utility.World

Executable hello
  Build-Depends: base == 4.*
  Main-Is: Main.hs
  Hs-Source-Dirs: src/
\end{code}

<p>В этом файле мы описали библиотеку и программу. В строке \In{base == 4.*} мы указали версию пакета \In{base}. Запись \In{4.*} означает любая версия, которая начинается с четвёрки. Осталось только поместить в корневую директорию пакета файл \In{Setup.hs}.</p>

\begin{code}
import Distribution.Simple
main = defaultMain
\end{code}

<p>Теперь мы можем переключиться на корневую директорию пакета и установить пакет:</p>

\begin{code}
anton@anton-desktop:~/haskell-notes/code/ch-17/hello$ cabal install
Resolving dependencies...
Configuring hello-1.0...
Preprocessing library hello-1.0...
Preprocessing executables for hello-1.0...
Building hello-1.0...
[1 of 3] Compiling Utility.World    ( src/Utility/World.hs, dist/build/Utility/World.o )
[2 of 3] Compiling Utility.Hello    ( src/Utility/Hello.hs, dist/build/Utility/Hello.o )
[3 of 3] Compiling Hello            ( src/Hello.hs, dist/build/Hello.o )
Registering hello-1.0...
[1 of 4] Compiling Utility.World    ( src/Utility/World.hs, dist/build/hello/hello-tmp/Utility/World.o )
[2 of 4] Compiling Utility.Hello    ( src/Utility/Hello.hs, dist/build/hello/hello-tmp/Utility/Hello.o )
[3 of 4] Compiling Hello            ( src/Hello.hs, dist/build/hello/hello-tmp/Hello.o )
[4 of 4] Compiling Main             ( src/Main.hs, dist/build/hello/hello-tmp/Main.o )
Linking dist/build/hello/hello ...
Installing library in /home/anton/.cabal/lib/hello-1.0/ghc-7.4.1
Installing executable(s) in /home/anton/.cabal/bin
Registering hello-1.0...
\end{code}

<p>Мы видим сообщения о процессе установки. После установки в текущей директории пакета появилась директория \In{dist}, в которую были помещены скомпилированные файлы библиотеки. В последних строках \In{cabal} сообщил нам о том, что он установил библиотеку в директорию:</p>

\begin{code}
Installing library in /home/anton/.cabal/lib/hello-1.0/ghc-7.4.1
\end{code}


<p>и исполняемый файл в директорию:</p>

\begin{code}
Installing executable(s) in /home/anton/.cabal/bin
\end{code}

<p>С помощью различных флагов мы можем контролировать процесс установки пакета. Назначать дополнительные директории, указывать куда поместить скомпилированные файлы. Подробно об этом можно почитать в справке, выполнив в командной строке одну из команд:</p>

\begin{code}
cabal --help
cabal install --help
\end{code}

<p>Если у вас не получилось сразу установить пакет не отчаивайтесь и почитайте сообщения об ошибках из \In{cabal}, он информативно жалуется о забытых зависимостях и неспособности правильно прочитать файл с описанием пакета.</p>
<h3 id="удаление-библиотеки">Удаление библиотеки</h3>
<p>Установленные с помощью \In{cabal} файлы видны из любого модуля. Имена модулей регистрируются глобально. Если нам захочется установить библиотеку с уже зарегистрированным именем, произойдёт хаос. Возможно прежняя библиотека нам уже не нужна. Как нам удалить её? Посмотрим на решение для компилятора ghc. Мы можем посмотреть список всех зарегистрированных в ghc библиотек с помощью команды:</p>

\begin{verbatim}
$ ghc-pkg list
   Cabal-1.8.0.6
   array-0.3.0.1
   base-4.2.0.2
   ...
   ...
\end{verbatim}

<p>Появится длинный список с именами библиотек. Для удаления одной из них мы можем выполнить команду:</p>

\begin{code}
ghc-pkg unregister имя-библиотеки
\end{code}

<p>Например так мы можем удалить только что установленную библиотеку \In{hello}:</p>

\begin{verbatim}
$ ghc-pkg unregister hello
\end{verbatim}

<h3 id="репозиторий-пакетов-hackage">Репозиторий пакетов Hackage</h3>
<p>Если у нас подключен интернет, то мы можем воспользоваться наследием сообщества Haskell и установить пакет с \In{Hackage}. Там расположено много-много-много пакетов. Любой разработчик Haskell может добавить свой пакет на \In{Hackage}. Посмотреть на пакеты можно на сайте этого репозитория:</p>
<blockquote>
<p><a href="http://hackage.haskell.org"><code class="url">http://hackage.haskell.org</code></a></p>
</blockquote>
<p>Если для вашей задачи необходимо выполнить какую-нибудь довольно общую задачу, например написать тип красно-чёрных деревьев или построить парсер или возможно вам нужен веб-сервер, поищите этот пакет на \In{Hackage}, он там наверняка окажется, ещё и в нескольких вариантах.</p>
<p>Для установки пакета с \In{Hackage} нужно просто написать</p>

\begin{code}
cabal install имя-пакета
\end{code}

<p>Возможно нам нужен очень новый пакет, который был только что залит автором на \In{Hackage}. Тогда выполняем:</p>

\begin{code}
cabal update
\end{code}

<p>Происходит обновление данных о загруженных на \In{Hackage}. Что хорошо, вы можете загрузить исходники из \In{Hackage}, например у вас никак не получается написать пакет, который устанавливался бы без ошибок. Просто загрузим исходники какого-нибудь пакета из \In{Hackage} и посмотрим на пример рабочего пакета.</p>
<h3 id="дополнительные-атрибуты-пакета">Дополнительные атрибуты пакета</h3>
<p>В файле \In{.cabal} также часто указывают такие атрибуты как:</p>
<dl>
<dt>\In{Maintainer}</dt>
<dd><p>Поле содержит адрес электронной почты тех.~поддержки</p>
</dd>
<dt>\In{Stability}</dt>
<dd><p>Статус версии библиотеки (стабильная, экспериментальная, нестабильная).</p>
</dd>
<dt>\In{Description}</dt>
<dd><p>Подробное описание назначения пакета. Оно помещается на главную страницу пакета в документации.</p>
</dd>
<dt>\In{Extra-Source-Files}</dt>
<dd><p>В этом поле можно через пробел указать дополнительные файлы, включаемые в пакет. Это могут быть примеры использования, описание в формате PDF или хроника изменений и другие служебные файлы.</p>
</dd>
<dt>\In{License-file}</dt>
<dd><p>Путь к файлу с лицензией.</p>
</dd>
<dt>\In{ghc-options}</dt>
<dd><p>Флаги компиляции для GHC. Если в нашей библиотеке мы активно пользуемся продвинутыми прагмами оптимизации, необходимо сообщить об этом компилятору пользователя. Например, мы можем написать в этом атрибуте \In{-O} или \In{-O2}.</p>
</dd>
</dl>
<h3 id="установка-библиотек-для-профилирования">Установка библиотек для профилирования</h3>
<p>Помните когда-то мы занимались профилированием? Это было в главе, посвящённой устройству GHC. Мы включали флаг \In{-prof} и всё шло гладко. Там мы профилировали код, в котором участвовали лишь стандартные библиотеки из пакета \In{base}, такие как \In{Prelude}. Но если мы попробуем профилировать код с какими-нибудь другими библиотеками, установленными с помощью \In{cabal}, GHC возмутится и скажет, что для профилирования не хватает специальной версии библиотеки \In{имярек}. Для того чтобы иметь возможность профилировать код, в котором участвуют другие библиотеки необходимо установить их с возможностью профилирования. Это делается при установке с помощью специального флага \In{--``enable-library-profiling} или \In{--``enable-executable-profiling} (если мы устанавливаем исполняемое приложение):</p>

\begin{verbatim}
$ cabal install имярек --reinstall --enable-library-profiling
\end{verbatim}

<p>Библиотека будет установлена в двух экземплярах: для исполнения и профилирования. Возможно библиотека \In{имярек} потребует переустановки некоторых библиотек, от которых она зависит. Повторяем эту процедуру для этих библиотек и возвращаемся к исходной библиотеке. К сожалению, избежать переустановки библиотек нельзя. Но мы можем сделать так, чтобы все будущие библиотеки устанавливались с возможностью профилирования. Для этого необходимо отредактировать файл настроек программы \In{cabal}. Ищем директори, в которой \In{cabal} хранит свои служебные файлы. Если вы пользуетесь Linux, то скорее всего это скрытая директория \In{.cabal} в вашей домашней директории. Если вы пользуетесь Windows, положение директории зависит от версии системы. Но ничего, узнать её положение можно, выполнив в \In{ghci}</p>

\begin{code}
Prelude> :m System.Directory
Prelude System.Directory> getAppUserDataDirectory "cabal"
\end{code}

<p>Присмотритесь к этой директории в ней вы найдёте много полезных данных. В ней находятся исполняемые программы, скомпилированные библиотеки, а также исходный код библиотек. В этой директории находится и файл \In{config} с настройками для \In{cabal}. Ищем строчку с полем \In{library-profiling: False}. Меняем значение на \In{True} и раскомментируем эту строчку, если она закомментирована. После этого \In{cabal install} будет устанавливать библиотеки для профилирования. На первых порах это вызовет массу неудобств из-за необходимости переустановки многих библиотек.</p>
<h2 id="создание-документации-с-помощью-haddock">Создание документации с помощью Haddock</h2>
<p>Если мы зайдём на Hackage, то там мы увидим длинный список пакетов, отсортированных по категориям. К какой категории какой пакет относится мы указываем в \In{.cabal}-файле в атрибуте \In{Category}. Далее рядом с именем пакета мы видим краткое описание, оно берётся из атрибута \In{Synopsis}. Если мы зайдём на страницу одного из пакетов, то там мы увидим страницу в таком же формате, что и документация к стандартным библиотекам. Мы видим описание пакета и ниже иерархию модулей. Мы можем зайти в заинтересовавший нас модуль и посмотреть на объявленные функции, типы и классы. В самом низу страницы находится ссылка к исходникам пакета.</p>
<p>“Домашняя страница” пакета была создана с помощью приложения \In{Haddock}. Оно генерирует документацию в формате \In{html} по специальным комментариям. \In{Haddock} встроен в \In{cabal}, например мы можем сделать документацию к нашему пакету \In{hello}. Для этого нужно переключиться на корневую директорию пакета и вызвать:</p>

\begin{code}
cabal haddock
\end{code}

<p>После этого в директории \In{dist} появится директория \In{doc}, в которой внутри директории \In{html} находится созданная документация. Мы можем открыть файл \In{index.html} и там мы увидим “иерархию нашего” модуля. В модуле пока нет ни одной функции, так получилось потому, что \In{Haddock} помещает в документацию лишь те функции, у которых есть объявление типа. Если мы добавим в модуле \In{Hello.hs}: к единственной функции объявление типа:</p>

\begin{code}
helloWorld :: String
helloWorld = hello ++ ", " ++ world ++ "!"
\end{code}

<p>И теперь перезапустим \In{haddock}. То мы увидим, что в модуле \In{Hello} появилась одна запись.</p>
<h3 id="комментарии-к-определениям">Комментарии к определениям</h3>
<p>Прокомментировать любое определение можно с помощью комментария следующего вида:</p>

\begin{code}
-- | Here is the comment
helloWorld :: String
helloWorld = hello ++ ", " ++ world ++ "!"
\end{code}

<p>Обратите внимание на значок “или”, сразу после комментариев. Этот комментарий будет включен в документацию. Также можно писать комментарии после определения для этого к комментарию добавляется значок степени:</p>

\begin{code}
helloWorld :: String
helloWorld = hello ++ ", " ++ world ++ "!"
-- ^ Here is the comment
\end{code}

<p>К сожалению на момент написания этих строк \In{Haddock} может включать в документацию лишь латинские символы. Комментарии могут простираться несколько строк:</p>

\begin{code}
-- | Here is the type.
-- It contains three elements.
-- That's it.
data T = A | B | C
\end{code}

<p>Также они могут быть блочными:</p>

\begin{code}
{-|
   Here is the type.
   It contains three elements.
   That's it.
 -}
data T = A | B | C
\end{code}

<p>Мы можем комментировать не только определение целиком, но и отдельные части. Например так мы можем пояснить отдельные аргументы у функции:</p>

\begin{code}
add :: Num a => a   -- ^ The first argument
             -> a   -- ^ The second argument   
             -> a   -- ^ The return value   
\end{code}

<p>Методы класса и отдельные конструкторы типа можно комментировать как обычные функции:</p>

\begin{code}
data T
        -- | constructor A    
       = A      
        -- | constructor B
       | B      
        -- | constructor C
       | C     
\end{code}

<p>Или так:</p>

\begin{code}
data T = A      -- ^ constructor A
       | B      -- ^ constructor B
       | C      -- ^ and so on
\end{code}

<p>Комментарии к классу:</p>

\begin{code}
-- | С-class
class С a where
    -- | f-function
    f :: a -> a
    -- | g-function
    g :: a -> a
\end{code}

<h3 id="комментарии-к-модулю">Комментарии к модулю</h3>
<p>Комментарии к модулю помещаются перед объявлением имени модуля. Эта информация попадёт в самое начало страницы документации:</p>

\begin{code}
-- | Little example
module Hello where
\end{code}

<h3 id="структура-страницы-документации">Структура страницы документации</h3>
<p>Если модуль большой, то его бывает удобно разделить на части, словно разделы в главе книги. Определения группируются по функциональности и помещаются в разные разделы или даже подразделы. Структура документации определяется с помощью специальных комментариев в экспорте модуля. Посмотрим на пример:</p>

\begin{code}
-- | Little example
module Hello(
    -- * Introduction
    -- | Here is the little example to show you
    -- how to make docs with Haddock
    
    -- * Types
    -- | The types.
    T(..),
    -- * Classes
    -- | The classes.
    C(..),
    -- * Functions
    helloWorld
    -- ** Subfunctions1
    -- ** Subfunctions2    
) where

...
\end{code}

<p>Комментарии со звёздочкой создают раздел, а с двумя звёздочками – подраздел. Те определения, которые экспортируются за комментариями со звёздочкой попадут в один раздел или подраздел. Если сразу за комментарием со звёздочкой идёт комментарий со знаком “или”, то он будет помещён в самое начало раздела. В нём мы можем пояснить по какому принципу группируются определения в данном разделе.</p>
<h3 id="разметка">Разметка</h3>
<p>С помощью специальных символов можно выделять различные элементы текста, например, ссылки, куски кода, названия определений или модулей. \In{Haddock} установит необходимые ссылки и выделит элемент в документации.</p>
<p>При этом символы \verb!\!, \In{'}, \In{`}, \verb!"!, \In{@}, \In{<} являются специальными, если вы хотите воспользоваться одним из специальных символов в тексте необходимо написать перед ним обратный слэш \verb!\!. Также символы для обозначения комментариев \In{*}, \In{|}, \In{^} и \In{>} являются специальными, если они расположены в самом начале строки.</p>
<h4 id="параграфы">Параграфы</h4>
<p>Параграфы определяются по пустой сроке в комментарии. Так например мы можем разбить текст на два параграфа:</p>

\begin{code}
-- | The first paragraph goes here.
--
-- The second paragraph goes here.
fun :: a -> b
\end{code}

<h4 id="блоки-кода">Блоки кода</h4>
<p>Существует два способа обозначения блоков кода:</p>

\begin{code}
-- | This documentation includes two blocks of code:
--
-- @
--     f x = x + x
--     g x = x
-- @
--
-- >  g x = x * 42
\end{code}

<p>В первом варианте мы заключаем блок кода в окружение \In{@...@}. Так мы можем выделить целый кусок кода. Для выделения одной строки мы можем воспользоваться знаком \In{>}.</p>
<h4 id="примеры-вычисления-в-интерпретаторе">Примеры вычисления в интерпретаторе</h4>
<p>В \In{Haddock} мы можем привести пример вычисления выражения в интерпретаторе. Это делается с помощью тройного символа \In{>}:</p>

\begin{code}
-- | Two examples are given bellow:
--
-- >>> 2+3
-- 5
--
-- >>> print 1 >> print 2
-- 1
-- 2
\end{code}

<p>Строки, которые идут сразу за строкой с символом \In{>>>} помечаются как результат выполнения выражения в интерпретаторе.</p>
<h4 id="имена-определений">Имена определений</h4>
<p>Для того чтобы выделить имя любого определения, будь то функция, тип или класс, необходимо заключить его в ординарные кавычки, как в \In{'T'}. При этом \In{Haddock} установит ссылку к определению и подсветит имя в тексте. Для того чтобы сослаться на определение из другого модуля необходимо написать его полное имя, т.е.~с приставкой имени модуля, например функция \In{fun}, определённая в модуле \In{M}, имеет полное имя \In{M.fun}, тогда в комментариях мы обозначаем её \In{'M.fun'}.</p>
<p>Ординарные кавычки часто используются в английском языке как апострофы, в таких сочетаниях как don’t, isn’t. Перед такими вхождениями ординарных кавычек можно не писать обратный слэш. \In{Haddock} сумеет отличить их от идентификатора.</p>
<h4 id="курсив-и-моноширинный-шрифт">Курсив и моноширинный шрифт</h4>
<p>Для выделения текста курсивом, он заключается в окружение \In{...}. Для написания текста моноширинным шрифтом, он заключается в окружение \In{@...@}.</p>
<h4 id="модули">Модули</h4>
<p>Для обозначения модулей используются двойные кавычки, как в</p>

\begin{code}
-- | This is a reference to the "Foo" module.
\end{code}

<h4 id="списки">Списки</h4>
<p>Список без нумерации обозначается с помощью звёздочек:</p>

\begin{code}
-- | This is a bulleted list:
--
--     * first item
--
--     * second item
\end{code}

<p>Пронумерованный список, обозначается символами \In{(n)} или \In{n.} (\In{n} с точкой), где \In{n} – некоторое целое число:</p>

\begin{code}
-- | This is an enumerated list:
--
--     (1) first item
--
--     2. second item
\end{code}

<h4 id="список-определений">Список определений</h4>
<p>Определения обозначаются квадратными скобками, например комментарий:</p>

\begin{code}
-- | This is a definition list:
--
--   [@foo@] The description of @foo@.
--
--   [@bar@] The description of @bar@.
\end{code}


<p>в документации будет выглядеть так:</p>
<dl>
<dt>\In{foo}</dt>
<dd><p>The description of \In{foo}.</p>
</dd>
<dt>\In{bar}</dt>
<dd><p>The description of \In{bar}.</p>
</dd>
</dl>
<p></p>
<p>Для выделения текста моноширинным шрифтом мы воспользовались окружением \In{@...@}.</p>
<h4 id="url">URL</h4>
<p>Ссылки на сайты включаются с помощью окружения \In{<...>}.</p>
<h4 id="ссылки-внутри-модуля">Ссылки внутри модуля</h4>
<p>Для того чтобы сослаться на какой-нибудь текст внутри модуля, его необходимо отметить ссылкой. Для этого мы помещаем в том месте, на которое мы хотим сослаться, запись \In{#label#}, где \In{label} – это идентификатор ссылки. Теперь мы можем сослаться на это место из другого модуля с помощью записи \verb!"!module#label\verb!"!, где \In{module} – имя модуля, в котором находится ссылка \In{label}.</p>
<h2 id="краткое-содержание">Краткое содержание</h2>
<p>В этой главе мы познакомились с основными элементами арсенала разработчика программ. Мы научились создавать библиотеки и документировать их.</p>
<h2 id="упражнения">Упражнения</h2>
<p>Вспомните один из примеров и превратите его в библиотеку. Например, напишите библиотеку для натуральных чисел Пеано.</p>
</body>
</html>
