<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<h1 id="первая-программа">Первая программа</h1>
<p>Я вот говорю-говорю, а вдруг я вас обманываю, и ничего этого нет. В этой главе мы перейдём к программированию и запустим нашу первую программу в Haskell. Будет много примеров, на которых мы закрепим наши знания.</p>
<h2 id="интерпретатор">Интерпретатор</h2>
<p>Для запуска кода мы будем пользоваться приложением GHC (Glorious Glasgow Haskell Compiler) наиболее развитой системой интерпретации Haskell программ. В GHC есть компилятор \In{ghc} и интерпретатор \In{ghci}. Пока мы будем пользоваться лишь интерпретатором. Если вы не знаете как установить \In{ghc} загляните в приложение. Также нам понадобится текстовый редактор с подсветкой синтаксиса. Подсветка синтаксиса для Haskell по умолчанию есть в редакторах Vim, Emacs, gedit, geany, yi. Есть IDE для Haskell Leksah. Мы будем писать модули в файлах и загружать их в интерпретатор. Если вы не знаете продвинутых текстовых редакторов вроде Vim или Emacs, лучше всего будет начать с gedit.</p>
<p>Интерпретатор позволяет загружать модуль с определениями и набирать значения в командной строке. Мы набираем значение, а интерпретатор редуцирует его и показывает нам ответ. Интерпретатор запускается командой \In{ghci} в терминале. Определения из модуля могут быть загружены в интерпретатор двумя способами, либо при запуске интерпретатора командой \In{ghci ИмяМодуля.hs} либо в самом интерпретаторе командой \In{:l ИмяМодуля.hs}.</p>
<p>Рассмотрим некоторые полезные команды интерпретатора:</p>
<dl>
<dt>\In{:?}</dt>
<dd><p>Выводит на экран список доступных команд</p>
</dd>
<dt>\In{:t Expression}</dt>
<dd><p>Возвращает тип выражения.</p>
</dd>
<dt>\In{:set +t}</dt>
<dd><p>После выполнения команды интерпретатор будет выводить на экран не только результат вычисления выражения, но и его тип.</p>
</dd>
<dt>\In{:set +s}</dt>
<dd><p>После выполнения команды интерпретатор будет выводить на экран не только результат вычисления выражения, но и статистику вычислений.</p>
</dd>
<dt>\In{:l ИмяМодуля}</dt>
<dd><p>Загружает модуль в интерпретатор.</p>
</dd>
<dt>\In{:cd Директория}</dt>
<dd><p>Перейти в данную директорию.</p>
</dd>
<dt>\In{:r}</dt>
<dd><p>Перезагружает, последний загруженный модуль. Этой командой можно пользоваться после внесения в модуль изменений.</p>
</dd>
<dt>\In{:q}</dt>
<dd><p>Выход из интерпретатора.</p>
</dd>
</dl>
<h2 id="у-вей">У-вей</h2>
<p>Согласно даосам основной принцип жизни заключается в недеянии (у-вей). Всё происходит естественно и словно само собой. Давайте создадим модуль который ничего не делает. Создадим пустой модуль и загрузим его в интерпретатор.</p>

\begin{code}
module Empty where

import Prelude()
\end{code}

<p>Зачем мы написали \In{import Prelude()}? Этой фразой мы говорим, что не хотим ничего импортировать из модуля \In{Prelude}. По умолчанию в любой модуль загружается модуль \In{Prelude}, который содержит много полезных определений. К примеру там определяется тип \In{Bool}, списки и функции для них, символы, классы типов для сравнения на равенство и печати значений и много, много других определений. В первых главах я хочу сделать акцент на самом языке Haskell, а не на производных выражениях, поэтому пока мы будем в явном виде загружать из модуля \In{Prelude} лишь самые необходимые определения.</p>
<p>Сохраним модуль в файле \In{Empty.hs}, сделаем директорию модуля текущей и запустим интерпретатор командой \In{ghci Empty} (имя расширения можно не писать). Также можно просто запустить интерпретатор командой \In{ghci}, переключиться на директорию командой \In{:cd} и загрузить модуль командой \In{:l Empty}.</p>

\begin{verbatim}
$ ghci
GHCi, version 7.4.1: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude> :cd ~/haskell-notes/code/ch-2/
Prelude> :l Empty.hs 
[1 of 1] Compiling Empty            ( Empty.hs, interpreted )
Ok, modules loaded: Empty.
*Empty> 
\end{verbatim}

<p>Слева от знака приглашения к вводу \In{>} отображаются загруженные в интерпретатор модули. По умолчанию загружается модуль \In{Prelude}. После выполнения команды \In{:l} мы видим, что \In{Prelude} сменилось на \In{Empty}.</p>
<p>Теперь давайте потренируемся перезагружать модули. Давайте изменим наш модуль, сделаем его не таким пустым, убрав последние две скобки от модуля \In{Prelude} в директиве \In{import}. Теперь сохраним изменения и выполним команду \In{:r}.</p>

\begin{code}
*Empty> :r
[1 of 1] Compiling Empty            ( Empty.hs, interpreted )
Ok, modules loaded: Empty.
*Empty>
\end{code}

<p>Завершим сессию интерпретатора командой \In{:q}.</p>

\begin{code}
*Empty> :q
Leaving GHCi.
\end{code}

<p>Внешние модули должны находится в текущей директории. Давайте потренируемся с подключением определений из внешних модулей. Создадим модуль близнец модуля \In{Empty.hs}:</p>

\begin{code}
module EmptyEmpty where

import Prelude()
\end{code}

<p>И сохраним его в той же директории, что и модуль \In{Empty}, теперь мы можем включить все определения из модуля \In{EmptyEmpty}:</p>

\begin{code}
module Empty where

import EmptyEmpty
\end{code}

<p>Когда у нас будет много модулей мы можем разместить их по директориям. Создадим в одной директории с модулем \In{Empty} директорию \In{Sub}, а в неё поместим копию модуля \In{Empty}. Существует одна тонкость: поскольку модуль находится в поддиректории, для того чтобы он стал виден из текущей директории, необходимо дописать через точку имя директории в которой он находится:</p>

\begin{code}
module Sub.Empty where
\end{code}

<p>Теперь мы можем загрузить этот модуль из исходного:</p>

\begin{code}
module Empty where

import EmptyEmpty
import Sub.Empty
\end{code}

<p>Обратите внимание на то, что мы приписываем к модулю в поддиректории \In{Sub} имя поддиректории. Если бы он был заложен в ещё одной директории, то мы написали бы через точку имя и этой поддиректории:</p>

\begin{code}
module Empty where

import Sub1.Sub2.Sub3.Sub4.Empty
\end{code}

<h2 id="логические-значения">Логические значения</h2>
<p>Пустой модуль это хорошо, но слишком скучно. Давайте перепишем объявленные в этой главе определения в модуль, загрузим его в интерпретатор и понабираем значения.</p>
<p>Начнём с логических операций. Давайте не будем переопределять \In{Bool}, \In{Show} и \In{Eq}, а просто возьмём их из \In{Prelude}:</p>

\begin{code}
module Logic where

import Prelude(Bool(..), Show(..), Eq(..))
\end{code}

<p>Две точки в скобках означают “все конструкторы” (в случае типа) и “все методы” (в случае класса типа). Строчку</p>

\begin{code}
import Prelude(Bool(..), Show(..), Eq(..))
\end{code}

<p>Следует читать так: Импортируй из модуля \In{Prelude} тип \In{Bool} и все его конструкторы и классы \In{Show} и \In{Eq} со всеми их методами. Если бы мы захотели импортировать только конструктор \In{True}, мы бы написали \In{Bool(True)}, а если бы мы захотели импортировать лишь имя типа, мы бы написали просто \In{Bool} без скобок.</p>
<p>Сначала выпишем в модуль наши синонимы:</p>

\begin{code}
module Logic where

import Prelude(Bool(..), Show(..), Eq(..))
  
true :: Bool 
true = True

false :: Bool
false = False

not :: Bool -> Bool
not True  = False
not False = True

and :: Bool -> Bool -> Bool
and False  _  = False
and True   x  = x

or  :: Bool -> Bool -> Bool
or True   _ = True
or False  x = x

xor :: Bool -> Bool -> Bool
xor a b = or (and (not a) b) (and a (not b))

ifThenElse :: Bool -> a -> a -> a
ifThenElse True   t  _ = t
ifThenElse False  _  e = e
\end{code}

<p>Теперь сохраним модуль и загрузим его в интерпретатор. Для наглядности мы установим флаг \In{+t}, при этом будет возвращено не только значение, но и его тип. Понабираем разные комбинации значений:</p>

\begin{code}
*Logic> :l Logic
[1 of 1] Compiling Logic            ( Logic.hs, interpreted )
Ok, modules loaded: Logic.
*Logic> :set +t
*Logic> not (and true False)
True
it :: Bool
*Logic> or (and true true) (or False False)
True
it :: Bool
*Logic> xor (not True) (False)
False
it :: Bool
*Logic> ifThenElse (or true false) True False
True
it :: Bool
\end{code}

<p>Разумеется в Haskell уже определены логические операции, здесь мы просто тренировались. Они называются \In{not}, \In{(&&)}, \In{||}. Операция \In{xor} это то же самое, что и \In{(/=)}. Для \In{Bool} определён экземпляр класса \In{Eq}. Также в Haskell есть конструкция ветвления она пишется так:</p>

\begin{code}
x = if cond then t else e
\end{code}

<p>Слова \In{if}, \In{then} и \In{else} – ключевые. \In{cond} имеет тип \In{Bool}, а \In{t} и \In{e} одинаковый тип.</p>
<p>В коде программы обычно пишут так:</p>

\begin{code}
x = if a > 3 
    then "Hello"
    else (if a < 0
          then "Hello"
          else "Bye")
\end{code}

<p>Отступы обязательны.</p>
<p>Давайте загрузим в интерпретатор модуль \In{Prelude} и наберём те же выражения стандартными функциями:</p>

\begin{code}
*Logic> :m Prelude
Prelude> not (True && False)
True
it :: Bool
Prelude> (True && True) || (False || False)
True
it :: Bool
Prelude> not True /= False
False
it :: Bool
Prelude> if (True || False) then True else False
True
it :: Bool
\end{code}

<p>Бинарные операции с символьными именами пишутся в инфиксной форме, т.е.~между аргументами как в \In{a && b} или \In{a + b}. Значение с буквенным именем также можно писать в инфиксной форме, для этого оно заключается в апострофы, например \In{a `and` b} или \In{a `plus` b}. Апострофы обычно находятся на одной кнопке с буквой “ё”. Также символьные функции можно применять в префиксной форме, заключив их в скобки, например \In{(&&) a b} и \In{(+) a b}. Попробуем в интерпретаторе:</p>

\begin{code}
Prelude> True && False
False
it :: Integer
Prelude> (&&) True False
False
it :: Bool
Prelude> let and a b = a && b
and :: Bool -> Bool -> Bool
Prelude> and True False
False
it :: Bool
Prelude> True `and` False
False
it :: Bool
\end{code}

<p>Обратите внимание на строчку \In{let and a b = a && b}. В ней мы определили синоним в интерпретаторе. Сначала мы пишем ключевое слово \In{let} затем обычное определение синонима, как в программе. Но не совсем обычное синоним должен быть однострочным. У нас не получится например определить такой синоним как \In{not}. Потому что в нём два уравнения.</p>
<h2 id="класс-show.-строки-и-символы">Класс Show. Строки и символы</h2>
<p>Мы набираем в интерпретаторе какое-нибудь сложное выражение, или составной синоним, интерпретатор проводит редукцию и выводит ответ на экран. Откуда интерпретатор знает как отображать значения типа \In{Bool}? Внутри интерпретатора вызывается метод класса \In{Show}, который переводит значение в строку. И затем мы видим на экране ответ.<br />Для типа \In{Bool} экземпляр класса \In{Show} уже определён, поэтому интерпретатор знает как его отображать.</p>
<p>Обратите внимание на эту особенность языка, вид значения определяется пользователем, в экземпляре класса \In{Show}. Из соображений наглядности вид значения может сильно отличаться от его внутреннего представления.</p>
<p>В этом разделе мы рассмотрим несколько примеров с классом \In{Show}, но перед этим мы поговорим о строках и символах в языке Haskell.</p>
<h3 id="строки-и-символы">Строки и символы</h3>
<p>Посмотрим в интерпретаторе что из себя представляют строки (тип \In{String}), для этого мы воспользуемся командой \In{:i} (сокращение от \In{:info}):</p>

\begin{code}
Prelude> :i String
type String = [Char] 	-- Defined in `GHC.Base'
\end{code}

<p>Интерпретатор показал определение типа и в комментариях указал в каком модуле тип определён. В этом определении мы видим новое ключевое слово \In{type}. До этого для определения типов нам встречалось лишь слово \In{data}. Ключевое слово \In{type} определяет синоним типа. При этом мы не вводим новый тип, мы лишь определяем для него псевдоним. \In{String} является синонимом для списка значений типа \In{Char}. Тип \In{Char} представляет символы. Итак строка – это список символов. В Haskell символы пишутся в ординарных кавычках, а строки в двойных:</p>

\begin{code}
Prelude> ['H','e','l','l','o']
"Hello"
it :: [Char]
Prelude> "Hello"
"Hello"
it :: [Char]
Prelude> '+'
'+'
it :: Char
\end{code}

<p>Для обозначения перехода на новую строку используется специальный символ \verb!\!n. Если строка слишком длинная и не помещается на одной строке, то её можно перенести так:</p>

\begin{code}
str = "My long long long long \
        \long long string"
\end{code}

<p>Перенос осуществляется с помощью комбинации следующих друг за другом обратных слэшей.</p>
<p>Нам понадобится функция конкатенации списков \In{(++)}, она определена в \In{Prelude}, с её помощью мы будем объединять строки:</p>

\begin{code}
Prelude> :t (++)
(++) :: [a] -> [a] -> [a]
Prelude> "Hello" ++ [' '] ++ "World"
"Hello World"
it :: [Char]
\end{code}

<h3 id="пример-отображение-дат-и-времени">Пример: Отображение дат и времени</h3>
<p>Приведём, пример в котором отображаемое значение не совпадает с видом значения в коде. Мы отобразим значения из мира календаря. Для начала давайте сохраним определения в отдельном модуле:</p>

\begin{code}
module Calendar where

import Prelude (Int, Char, String, Show(..), (++))

-- Дата
data Date = Date Year Month Day

-- Год
data Year  = Year Int       -- Int это целые числа

-- Месяц
data Month  = January    | February   | March    | April          
            | May        | June       | July     | August   
            | September  | October    | November | December

data Day = Day Int

-- Неделя
data Week  = Monday     | Tuesday   | Wednesday 
           | Thursday   | Friday    | Saturday     
           | Sunday   

-- Время
data Time = Time Hour Minute Second

data Hour   = Hour   Int    -- Час
data Minute = Minute Int    -- Минута
data Second = Second Int    -- Секунда
\end{code}

<p>Теперь сохраним наш модуль под именем \In{Calendar.hs} и загрузим в интерпретатор:</p>

\begin{code}
Prelude> :l Calendar
[1 of 1] Compiling Calendar         ( Calendar.hs, interpreted )
Ok, modules loaded: Calendar.
*Calendar> Monday

<interactive>:3:1:
    No instance for (Show Week)
      arising from a use of `System.IO.print'
    Possible fix: add an instance declaration for (Show Week)
    In a stmt of an interactive GHCi command: System.IO.print it
\end{code}

<p>Смотрите мы попытались распечатать значение \In{Monday}, но в ответ получили ошибку. В ней интерпретатор сообщает нам о том, что для типа \In{Week} не определён экземпляр класса \In{Show} и он не знает как его распечатывать. Давайте подскажем ему. Обычно дни недели в календарях печатают не полностью, в имя попадают лишь три первых буквы:</p>

\begin{code}
instance Show Week where
    show Monday     = "Mon"
    show Tuesday    = "Tue"
    show Wednesday  = "Wed"
    show Thursday   = "Thu"  
    show Friday     = "Fri" 
    show Saturday   = "Sat"
    show Sunday     = "Sun"
\end{code}

<p>Отступы перед \In{show} обязательны, но выравнивание по знаку равно не обязательно, мне просто нравится так писать. По отступам компилятор понимает, что все определения относятся к определению \In{instance}. Теперь запишем экземпляр в модуль, сохраним, и перезагрузим в интерпретатор:</p>

\begin{code}
*Calendar> :r
[1 of 1] Compiling Calendar         ( Calendar.hs, interpreted )
Ok, modules loaded: Calendar.
*Calendar> Monday
Mon
it :: Week
*Calendar> Sunday
Sun
it :: Week
\end{code}

<p>Теперь наши дни отображаются. Я выпишу ещё один пример экземпляра для \In{Time}, а остальные достанутся вам в качестве упражнения.</p>

\begin{code}
instance Show Time where
    show (Time h m s) = show h ++ ":" ++ show m ++ ":" ++ show s

instance Show Hour where
    show (Hour h) = addZero (show h)

instance Show Minute where
    show (Minute m) = addZero (show m)

instance Show Second where
    show (Second s) = addZero (show s)

addZero :: String -> String
addZero (a:[]) = '0' : a : []
addZero as     = as
\end{code}

<p>Функцией \In{addZero} мы добавляем ноль в начало строки, в том случае если число однозначное, также в этом определении мы воспользовались тем, что для типа целых чисел \In{Int} экземпляр \In{Show} уже определён. Проверим в интерпретаторе:</p>

\begin{code}
*Calendar> Time (Hour 13) (Minute 25) (Second 2)
13:25:02
it :: Time
\end{code}

<h2 id="автоматический-вывод-экземпляров-классов-типов">Автоматический вывод экземпляров классов типов</h2>
<p>Для некоторых стандартных классов экземпляры классов типов могут быть выведены автоматически. Это делается с помощью директивы \In{deriving}. Она пишется сразу после объявления типа. Например так мы можем определить тип и экземпляры для классов \In{Show} и \In{Eq}:</p>

\begin{code}
data T = A | B | C
    deriving (Show, Eq)
\end{code}

<p>Отступ за \In{deriving} обязателен, после ключевого слова в скобках указываются классы, которые мы хотим вывести.</p>
<h2 id="арифметика">Арифметика</h2>
<p>В этом разделе мы обсудим основные арифметические операции. В Haskell много стандартных классов, которые группируют различные типы операций, есть класс для сравнения на равенство, отдельный класс для сравнения на больше/меньше, класс для умножения, класс для деления, класс для упорядоченных чисел, и много других. Зачем такое изобилие классов?</p>
<p>Каждый из классов отвечает независимой группе операций. Есть много объектов, которые можно только складывать, но нельзя умножать или делить. Есть объекты, для которых сравнение на равенство имеет смысл, а сравнение на больше/меньше – нет.</p>
<p>Для иллюстрации мы воспользуемся числами Пеано, у них компактное определение, всего два конструктора, которых тем не менее достаточно для описания множества натуральных чисел:</p>

\begin{code}
module Nat where

data Nat = Zero | Succ Nat
    deriving (Show, Eq, Ord)
\end{code}

<p>Конструктор \In{Zero} указывает на число ноль, а \In{(Succ n)} на число следующее за данным числом \In{n}. В последней строчке мы видим новый класс \In{Ord}, этот класс содержит операции сравнения на больше/меньше:</p>

\begin{code}
Prelude> :i Ord
class (Eq a) => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
\end{code}

<p>Тип \In{Ordering} кодирует результаты сравнения:</p>

\begin{code}
Prelude> :i Ordering
data Ordering = LT | EQ | GT 	-- Defined in GHC.Ordering
\end{code}

<p>Он содержит конструкторы, соответствующие таким понятиям как меньше, равно и больше.</p>
<h3 id="класс-eq.-сравнение-на-равенство">Класс Eq. Сравнение на равенство</h3>
<p>Вспомним определение класса \In{Eq}:</p>

\begin{code}
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool

    a == b = not (a /= b)
    a /= b = not (a == b)
\end{code}

<p>Появились две детали, о которых я умолчал в предыдущей главе. Это две последние строчки. В них мы видим определение \In{==} через \In{/=} и наоборот. Это определения методов по умолчанию. Такие определения дают нам возможность определять не все методы класса, а лишь часть основных, а все остальные мы получим автоматически из определений по умолчанию.</p>
<p>Казалось бы почему не оставить в классе \In{Eq} один метод а другой метод определить в виде отдельной функции:</p>

\begin{code}
class Eq a where
    (==) :: a -> a -> Bool

(/=) :: Eq a => a -> a -> Bool
a /= b = not (a == b)
\end{code}

<p>Так не делают по соображениям эффективности. Есть типы для которых проще вычислить \In{/=} чем \In{==}. Тогда мы определим тот метод, который нам проще вычислять и второй получим автоматически.</p>
<p>Набор основных методов, через которые определены все остальные называют <em>минимальным полным определением</em> (minimal complete definition) класса. В случае класса \In{Eq} это метод \In{==} или метод \In{/=}.</p>
<p>Мы уже вывели экземпляр для \In{Eq}, поэтому мы можем пользоваться методами \In{==} и \In{/=} для значений типа \In{Nat}:</p>

\begin{code}
*Calendar> :l Nat
[1 of 1] Compiling Nat              ( Nat.hs, interpreted )
Ok, modules loaded: Nat.
*Nat> Zero == Succ (Succ Zero)
False
it :: Bool
*Nat> Zero /= Succ (Succ Zero)
True
it :: Bool
\end{code}

<h3 id="класс-num.-сложение-и-умножение">Класс Num. Сложение и умножение</h3>
<p>Сложение и умножение определены в классе \In{Num}. Посмотрим на его определение:</p>

\begin{code}
*Nat> :i Num
class (Eq a, Show a) => Num a where
  (+) :: a -> a -> a
  (*) :: a -> a -> a
  (-) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  	-- Defined in GHC.Num
\end{code}

<p>Методы \In{(+)}, \In{(*)}, \In{(-)} в представлении не нуждаются, метод \In{negate} является унарным минусом, его можно определить через \In{(-)} так:</p>

\begin{code}
negate x = 0 - x
\end{code}

<p>Метод \In{abs} является модулем числа, а метод \In{signum} возвращает знак числа, метод \In{fromInteger} позволяет создавать значения данного типа из стандартных целых чисел \In{Integer}.</p>
<p>Этот класс устарел, было бы лучше сделать отельный класс для сложения и вычитания и отдельный класс для умножения. Также контекст класса, часто становится помехой. Есть объекты, которые нет смысла печатать но, есть смысл определить на них сложение и умножение. Но пока в целях совместимости с уже написанным кодом, класс \In{Num} остаётся прежним.</p>
<p>Определим экземпляр для чисел Пеано, но давайте сначала разберём функции по частям.</p>
<h4 id="сложение">Сложение</h4>
<p>Начнём со сложения:</p>

\begin{code}
instance Num Nat where
    (+) a Zero     = a
    (+) a (Succ b) = Succ (a + b)
\end{code}

<p>Первое уравнение говорит о том, что если второй аргумент равен нулю, то мы вернём первый аргумент в качестве результата. Во втором уравнении мы “перекидываем” конструктор \In{Succ} из второго аргумента за пределы суммы. Схематически вычисление суммы можно представить так:</p>
<p><br /><span class="math"><strong>3+2</strong> → 1 + <strong>(3+1)</strong> → 1 + (1 + <strong>(3+0)</strong>)</span><br /></p>
<p><br /><span class="math">1 + (1 + <strong>3</strong>) → 1 + (1 + (1 + (1 + (1 + 0)))) → 5</span><br /></p>
<p>Все наши числа имеют вид <span class="math">0</span> или <span class="math">1 + <em>n</em></span>, мы принимаем на вход два числа в таком виде и хотим в результате составить число в этом же виде, для этого мы последовательно перекидываем $<span class="math">(1 + )</span> в начало выражения из второго аргумента.</p>
<h4 id="вычитание">Вычитание</h4>
<p>Операция отрицания не имеет смысла, поэтому мы воспользуемся специальной функцией \In{error :: String -> a}, она принимает строку с сообщением об ошибке, при её вычислении программа остановится с ошибкой и сообщение будет выведено на экран.</p>

\begin{code}
    negate _ = error "negate is undefined for Nat"
\end{code}

<h4 id="умножение">Умножение</h4>
<p>Теперь посмотрим на умножение:</p>

\begin{code}
    (*) a Zero     = Zero
    (*) a (Succ b) = a + (a * b)     
\end{code}

<p>В первом уравнении мы вернём ноль, если второй аргумент окажется нулём, а во втором мы за каждый конструктор \In{Succ} во втором аргументе прибавляем к результату первый аргумент. В итоге, после вычисления \In{a * b} мы получим аргумент \In{a} сложенный \In{b} раз. Это и есть умножение. При этом мы воспользовались операцией сложения, которую только что определили. Посмотрим на схему вычисления:</p>
<p><br /><span class="math"><strong>3*2</strong> → 3 + <strong>(3*1)</strong> → 3 + (3 + <strong>(3*0)</strong>) → 3 + <strong>(3+0)</strong> → <strong>3+3</strong> → </span><br /></p>
<p><br /><span class="math">1 + <strong>(3+2)</strong> → 1 + (1 + <strong>(3+1)</strong>) → 1 + (1 + (1 + <strong>(3+0)</strong>)) → </span><br /></p>
<p><br /><span class="math">1 + (1 + 1 + <strong>3</strong>) → 1 + (1 + (1 + (1 + (1 + (1 + 0))))) → 6</span><br /></p>
<h4 id="операции-abs-и-signum">Операции abs и signum</h4>
<p>Поскольку числа у нас положительные, то методы \In{abs} и \In{signum} почти ничего не делают:</p>

\begin{code}
    abs    x    = x 
    signum Zero = Zero
    signum _    = Succ Zero
\end{code}

<h4 id="перегрузка-чисел">Перегрузка чисел</h4>
<p>Остался последний метод \In{fromInteger}. Он конструирует значение нашего типа из стандартного:</p>

\begin{code}
    fromInteger 0 = Zero
    fromInteger n = Succ (fromInteger (n-1))
\end{code}

<p>Зачем он нужен? Попробуйте узнать тип числа \In{1} в интерпретаторе:</p>

\begin{code}
*Nat> :t 1
1 :: (Num t) => t
\end{code}

<p>Интерпретатор говорит о том, тип значения \In{1} является некоторым типом из класса \In{Num}. В Haskell обозначения для чисел перегружены. Когда мы пишем \In{1} на самом деле мы пишем \In{(fromInteger (1::Integer))}. Поэтому теперь мы можем не писать цепочку \In{Succ}-ов, а воспользоваться методом \In{fromInteger}, для этого сохраним определение экземпляра для \In{Num} и загрузим обновлённый модуль в интерпретатор:</p>

\begin{code}
[1 of 1] Compiling Nat              ( Nat.hs, interpreted )
Ok, modules loaded: Nat.
*Nat> 7 :: Nat
Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero))))))
*Nat> (2 + 2) :: Nat
Succ (Succ (Succ (Succ Zero)))
*Nat> 2 * 3 :: Nat
Succ (Succ (Succ (Succ (Succ (Succ Zero)))))
\end{code}

<p>Вы можете убедиться насколько гибкими являются числа в Haskell:</p>

\begin{code}
*Nat> (1 + 1) :: Nat
Succ (Succ Zero)
*Nat> (1 + 1) :: Double
2.0
*Nat> 1 + 1
2
\end{code}

<p>Мы выписали три одинаковых выражения и получили три разных результата, меняя объявление типов. В последнем выражении тип был приведён к \In{Integer}. Это поведение интерпретатора по умолчанию. Если мы напишем:</p>

\begin{code}
*Nat> let q = 1 + 1
*Nat> :t q
q :: Integer
\end{code}

<p>Мы видим, что значение \In{q} было переведено в \In{Integer}, это происходит лишь в интерпретаторе, если такая переменная встретится в программе и компилятор не сможет определить её тип из контекста, произойдёт ошибка проверки типов, компилятор скажет, что он не смог определить тип. Помочь компилятору можно, добавив объявление типа с помощью конструкции \In{(v :: T)}.</p>
<p>Посмотрим ещё раз на определение экземпляра \In{Num} для \In{Nat} целиком:</p>

\begin{code}
instance Num Nat where
    (+) a Zero     = a
    (+) a (Succ b) = Succ (a + b)

    (*) a Zero     = Zero
    (*) a (Succ b) = a + (a * b)   

    fromInteger 0 = Zero
    fromInteger n = Succ (fromInteger (n-1))

    abs    x    = x 
    signum Zero = Zero
    signum _    = Succ Zero

    negate _ = error "negate is undefined for Nat"
\end{code}

<h3 id="класс-fractional.-деление">Класс Fractional. Деление</h3>
<p>Деление определено в классе \In{Fractional}:</p>

\begin{code}
*Nat>:m Prelude
Prelude> :i Fractional
class Num a => Fractional a where
  (/) :: a -> a -> a
  recip :: a -> a
  fromRational :: Rational -> a
  	-- Defined in `GHC.Real'
instance Fractional Float -- Defined in `GHC.Float'
instance Fractional Double -- Defined in `GHC.Float'
\end{code}

<p>Функция \In{recip}, это аналог \In{negate} для \In{Num}. Она делит единицу на данное число. Функция \In{fromRational} строит число данного типа из дробного числа. Если мы пишем \In{2}, то к нему подспудно будет применена функция \In{fromInteger}, а если \In{2.0}, то будет применена функция \In{fromRational}.</p>
<h3 id="стандартные-числа">Стандартные числа</h3>
<p>В этом подразделе мы рассмотрим несколько стандартных типов для чисел в Haskell. Все эти числа являются экземплярами основных численных классов. Тех которые мы рассмотрели, и многих-многих других.</p>
<h4 id="целые-числа">Целые числа</h4>
<p>В Haskell предусмотрено два типа для целых чисел. Это \In{Integer} и \In{Int}. Чем они отличаются? Значения типа \In{Integer} не ограничены, мы можем проводить вычисления с очень-очень-очень большими числами, если памяти на нашем компьютере хватит. Числа из типа \In{Int} ограничены. Каждое число занимает определённый размер в памяти компьютера. Диапазон значений для \In{Int} составляет от <span class="math"> − 2<sup>29</sup></span> до <span class="math">2<sup>29</sup> − 1</span>. Вычисления с \In{Int} более эффективны.</p>
<h4 id="действительные-числа">Действительные числа</h4>
<p> Действительные числа бывают дробными (тип \In{Rational}), с ординарной точностью \In{Float} и с двойной точностью \In{Double}. Числа из типа \In{Float} занимают меньше места, но они не такие точные как \In{Double}. Если вы сомневаетесь чем пользоваться, выбирайте \In{Double}, обычно \In{Float} используется только там, где необходимо хранить огромные массивы чисел. В этом случае мы экономим много памяти.</p>
<h4 id="преобразование-численных-типов">Преобразование численных типов</h4>
<p>Во многих языках программирования при сложении или умножении чисел разных типов проводится автоматическое приведение типов. Обычно целые числа становятся действительными, \In{Float} превращается в \In{Double} и так далее. Это противоречит строгой типизации, поэтому в Haskell этого нет:</p>

\begin{code}
Prelude> (1::Int) + (1::Double)

<interactive>:2:13:
    Couldn't match expected type `Int' with actual type `Double'
    In the second argument of `(+)', namely `(1 :: Double)'
    In the expression: (1 :: Int) + (1 :: Double)
    In an equation for `it': it = (1 :: Int) + (1 :: Double)
\end{code}

<p>Любое преобразование типов контролируется пользователем. Мы должны вызвать специальную функцию.</p>
<p><strong>От целых к действительным:</strong> Часто возникает необходимость приведения целых чисел к действительным при делении. Для этого можно воспользоваться функцией: \In{fromIntegral}</p>

\begin{code}
Prelude> :i fromIntegral
fromIntegral :: (Integral a, Num b) => a -> b
  	-- Defined in `GHC.Real'
\end{code}

<p>Определим функцию поиска среднего между двумя целыми числами:</p>

\begin{code}
meanInt :: Int -> Int -> Double
meanInt a b = fromIntegral (a + b) / 2
\end{code}

<p>В этой функции двойка имеет тип \In{Double}. Обратите внимание на скобки: составной синоним всегда притягивает аргументы сильнее чем бинарная операция.</p>
<p><strong>От действительных к целым:</strong> В этом нам поможет класс \In{RealFrac}. Методы говорят сами за себя:</p>

\begin{code}
Prelude GHC.Float> :i RealFrac
class (Real a, Fractional a) => RealFrac a where
  properFraction :: Integral b => a -> (b, a)
  truncate :: Integral b => a -> b
  round :: Integral b => a -> b
  ceiling :: Integral b => a -> b
  floor :: Integral b => a -> b
  	-- Defined in `GHC.Real'
instance RealFrac Float -- Defined in `GHC.Float'
instance RealFrac Double -- Defined in `GHC.Float'
\end{code}

<p>Метод \In{properFraction} отделяет целую часть числа от дробной:</p>

\begin{code}
properFraction :: Integral b => a -> (b, a)
\end{code}

<p>Для того, чтобы вернуть сразу два значения используется кортеж (кортежи пишутся в обычных скобках значения следуют через запятую):</p>

\begin{code}
Prelude> properFraction 2.5
(2,0.5)
\end{code}

<p> Для пар (кортеж, состоящий из двух элементов) определены две удобные функции извлечения элементов, их смысл можно понять по одним лишь типам:</p>

\begin{code}
fst :: (a, b) -> a
snd :: (a, b) -> b
\end{code}

<p>Проверим:</p>

\begin{code}
Prelude> let x = properFraction 2.5
Prelude> (fst x, snd x)
(2, 0.5)
\end{code}

<p>Мы бы и сами могли определить такие функции:</p>

\begin{code}
fst :: (a, b) -> a
fst (a, _) = a 

snd :: (a, b) -> b
snd (_, b) = b
\end{code}

<p><strong>Между действительными числами:</strong> Кто-то написал очень хорошую функцию, но она определена на \In{Double}, а вам приходится использовать \In{Float}. Как быть? Нам поможет функция \In{realToFrac}:</p>

\begin{code}
Prelude> :i realToFrac
realToFrac :: (Real a, Fractional b) => a -> b
  	-- Defined in `GHC.Real'
\end{code}

<p>Она принимает значение из класса \In{Real} и приводит его к значению, которое можно делить. Что это за класс \In{Real}? Математики наверное смекнут, что это противоположность комплексным числам (где-то должен быть определён тип или класс \In{Complex}, и он правда есть, но об этом в следующем разделе). При переходе к комплексным числам мы теряем способность сравнения на больше/меньше, но сохраняем возможность вычисления арифметических операций, поэтому класс \In{Real} это пересечение классов \In{Num} и \In{Ord}:</p>

\begin{code}
Prelude> :i Real
class (Num a, Ord a) => Real a where
  toRational :: a -> Rational
\end{code}

<p>Здесь “пересечение” означает “и тот и другой”. Пересечение классов кодируется с помощью контекста. Вернёмся к нашему первому примеру:</p>

\begin{code}
Prelude> realToFrac (1::Float) + (1::Double)
2.0
\end{code}

<p>Отметим, что этой функцией можно пользоваться не только для типов \In{Float} и \In{Double}, в Haskell возможны самые экзотические числа.</p>
<p>Если преобразования между \In{Float} и \In{Double} происходят очень-очень часто, возможно имеет смысл воспользоваться специальными для \In{GHC} функциями: Они определены в модуле \In{GHC.Float}:</p>

\begin{code}
Prelude> :m +GHC.Float
Prelude GHC.Float> :t float2Double
float2Double :: Float -> Double
Prelude GHC.Float> :t double2float
double2Float :: Double -> Float
\end{code}

<h2 id="документация">Документация</h2>
<p>К этой главе мы уже рассмотрели основные конструкции языка и базовые типы. Если у вас есть какая-то задача, вы уже можете начать её решать. Для этого сначала нужно будет описать в типах проблему, затем выразить с помощью функций её решение.</p>
<p>Но не стоит писать все функции самостоятельно, если функция достаточно общая её наверняка кто-нибудь уже написал. Самые полезные функции и классы определены в модуле \In{Prelude} и основных стандартных библиотечных модулях. Было бы излишним описывать каждую функцию, книга превратилась бы в справочник. Вместо этого давайте научимся искать функции в документации. Нам понадобится умение составлять типы функций и небольшое знание английского языка.</p>
<p>Для начала о том, где находится документация к стандартным модулям. Если вы установили \In{ghc} вместе с \In{Haskell Platform} под Windows скорее всего во вкладке \In{Пуск}, там где иконка \In{ghc} там же находится и документация. В Linux необходимо найти директорию с документацией, скорее всего она в директории \In{/usr/local/share/doc/ghc/libraries}. Также документацию можно найти в интернете, наберите в поисковике Haskell Hierarchical Libraries. На главной странице документации вы найдёте огромное количество модулей. Нас пока интересуют разделы \In{Data} и \In{Prelude}. Разделы расположены по алфавиту. То что вы видите это стандартный вид документации в Haskell. Документация делается с помощью специального приложения \In{Haddock}, мы тоже научимся такие делать, но позже, пока мы попробуем разобраться с тем как искать в документации функции.</p>
<p>Предположим нам нужно вычислить длину списка. Нам нужна функция, которая принимает список и возвращает целое число, скорее всего её тип \In{[a] -> Int}, обычно во всех библиотечных функциях для целых чисел используется тип \In{Int}, также на месте параметра используются буквы \In{a}, \In{b}, \In{c}. Мы можем открыть документацию к \In{Prelude} набрать в строке поиска тип \In{[a] -> Int}. Или поискать такую функцию в разделе функций для списков \In{List Operations}. Тогда мы увидим единственную функцию с таким типом, под говорящим именем \In{length}. Так мы нашли то, что искали.</p>
<p>Или мы ищем функцию, которая переворачивает список, нам нужна функция с типом \In{[a] -> [a]}. Таких функций в \In{Prelude} несколько, но имя \In{reverse} одной из них может намекнуть на её смысл.</p>
<p>Но одной \In{Prelude} мир стандартных функций Haskell не ограничивается, если вы не нашли необходимую вам функцию в \In{Prelude} её стоит поискать в других библиотечных модулях. Обычно функции разделяются по тому на каких типах они определены. Так например функция \In{sort :: Ord a => [a] -> [a]} определена не в \In{Prelude}, а в отдельном библиотечном модуле для списков он называется \In{Data.List}. Так же есть много других модулей для разных типов, таких как \In{Data.Bool}, \In{Data.Char}, \In{Data.Function}, \In{Data.Maybe} и многие другие. Не пугайтесь изобилия модулей постепенно они станут вашей опорой.</p>
<p>Для поиска в стандартных библиотеках есть замечательный интернет-сервис Hoogle (<a href="http://www.haskell.org/hoogle/"><code class="url">http://www.haskell.org/hoogle/</code></a>). Hoogle может искать значения не только по имени, но и по типам. Например мы хотим узнать целочисленный код символа. Поиск по типу \In{Char -> Int} выдаёт искомую функцию \In{digitToInt}.</p>
<h2 id="краткое-содержание">Краткое содержание</h2>
<p>В этой главе мы познакомились с интерпретатором \In{ghci} и основными типами. Рассмотрели много примеров.</p>
<h4 id="типы">Типы</h4>
<table>
<tbody>
<tr class="odd">
<td align="left">\In{Bool}</td>
<td align="left"></td>
<td align="left">Основные операции: \In{&&}, \In{||}, \In{not}, \In{if c then t else e}</td>
</tr>
<tr class="even">
<td align="left">\In{Char}</td>
<td align="left"></td>
<td align="left">Значения пишутся в ординарных кавычках, как в \In{'H'}, \In{'+'}</td>
</tr>
<tr class="odd">
<td align="left">\In{String}</td>
<td align="left"></td>
<td align="left">Значения пишутся в двойных кавычках, как в \verb!"!Hello World\verb!"!</td>
</tr>
<tr class="even">
<td align="left">\In{Int}</td>
<td align="left"></td>
<td align="left">Эффективные целые числа, но ограниченные</td>
</tr>
<tr class="odd">
<td align="left">\In{Integer}</td>
<td align="left"></td>
<td align="left">Не ограниченные целые числа, но не эффективные</td>
</tr>
<tr class="even">
<td align="left">\In{Double}</td>
<td align="left"></td>
<td align="left">Числа с двойной точностью</td>
</tr>
<tr class="odd">
<td align="left">\In{Float}</td>
<td align="left"></td>
<td align="left">Числа с ординарной точностью</td>
</tr>
<tr class="even">
<td align="left">\In{Rational}</td>
<td align="left"></td>
<td align="left">Дробные числа</td>
</tr>
</tbody>
</table>
<p>Нам впервые встретились кортежи (на функции \In{properFraction}). Кортежи используются для возвращения из функции нескольких значений. Элементы кортежа могут иметь разные типы. Для извлечения элементов из кортежей-пар используются функции \In{fst} и \In{snd}. Кортежи пишутся в скобках, и элементы разделены запятыми:</p>

\begin{code}
(a, b)
(a, b, c)
(a, b, c, d)
...
\end{code}

<h4 id="классы">Классы</h4>
<table>
<tbody>
<tr class="odd">
<td align="left">\In{Show}</td>
<td align="left">Печать</td>
</tr>
<tr class="even">
<td align="left">\In{Eq}</td>
<td align="left">Сравнение на равенство</td>
</tr>
<tr class="odd">
<td align="left">\In{Num}</td>
<td align="left">Сложение и умножение</td>
</tr>
<tr class="even">
<td align="left">\In{Fractional}</td>
<td align="left">Деление</td>
</tr>
</tbody>
</table>
<h4 id="особенности-синтаксиса">Особенности синтаксиса</h4>
<p>Запись применения функции:</p>
<table>
<col width="21%" />
<col width="23%" />
<thead>
<tr class="header">
<th align="left">Префиксная</th>
<th align="left">Инфиксная</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">\In{add a b}</td>
<td align="left">\In{a `add` b}</td>
</tr>
<tr class="even">
<td align="left">\In{(+) a b}</td>
<td align="left">\In{a + b}</td>
</tr>
</tbody>
</table>
<p>Также мы научились приводить одни численные типы к другим и пользоваться документацией.</p>
<h2 id="упражнения">Упражнения</h2>
<ul>
<li><p>Напишите функцию \In{beside :: Nat -> Nat -> Bool}, которая будет возвращать \In{True} только в том случае, если два аргумента находятся рядом, т.е.~один из них можно получить через другой операцией \In{Succ}.</p></li>
<li><p>Напишите функцию \In{beside2 :: Nat -> Nat -> Bool}, которая будет возвращать \In{True} только если аргументы являются соседями через некоторое другое число.</p></li>
<li><p>Мы написали очень неэффективную функцию сложения натуральных чисел. Проблема в том, что число рекурсивных вызовов функции зависит от величины второго аргумента. Если мы захотим прибавить единицу к сотне, то порядок следования аргументов существенно повлияет на скорость вычисления. Напишите функцию, которая лишена этого недостатка.</p></li>
<li><p>Напишите функцию возведения в степень \In{pow :: Nat -> Nat -> Nat}.</p></li>
<li><p>Напишите тип, описывающий бинарные деревья \In{BinTree a}. Бинарное дерево может быть либо листом со значением типа \In{a}, либо хранить два поддерева.</p></li>
<li><p>Напишите функцию \In{reverse :: BinTree a -> BinTree a}, которая переворачивает дерево. Она меняет местами два элемента в узле дерева.</p></li>
<li><p>Напишите функцию \In{depth :: BinTree a -> Nat}, которая вычисляет глубину дерева, т.е.~самый длинный путь от корня дерева к листу.</p></li>
<li><p>Напишите функцию \In{leaves :: BinTree a -> [a]}, которая переводит бинарное дерево в список, возвращая все элементы в листьях дерева.</p></li>
<li><p>Обратите внимание на раздел \In{List Operations} в \In{Prelude}. Посмотрите на функции и их типы. Попробуйте догадаться по типу функции и названию что она делает.</p></li>
<li><p>Попробуйте разобраться по документации с классами \In{Ord} (сравнение на больше/меньше), \In{Enum} (перечисления) и \In{Integral} (целые числа). Также стоит отметить класс \In{Floating}. Если у вас не получится, не беда, они обязательно встретятся нам вновь. Там и разберёмся.</p></li>
<li><p>Найдите функцию, которая переставляет элементы пары местами (элементы могут быть разных типов).<br /> Потренируйтесь с кортежами. Определите аналоги функций \In{fst} и \In{snd} для не пар. Обратите внимание на то, что сочетание символов \In{(,)} это функция-конструктор пары:</p>

\begin{code}
Prelude> (,) "Hi" 101
("Hi",101)
Prelude> :t (,)
(,) :: a -> b -> (a, b)
\end{code}

<p>Также определены \In{(,,)}, \In{(,,,)} и другие.</p></li>
</ul>
</body>
</html>
