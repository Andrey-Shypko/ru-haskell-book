<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<h1 id="функции-высшего-порядка">Функции высшего порядка</h1>
<p> <em>Функцией высшего порядка</em> называют функцию, которая может принимать на вход функции или возвращать функции в качестве результата. За счёт частичного применения в Haskell все функции, которые принимают более одного аргумента, являются функциями высшего порядка.</p>
<p>В этой главе мы подробно обсудим способы составления функций, недаром Haskell – функциональный язык. В Haskell функции являются очень гибким объектом, они позволяют выделять сложные способы комбинирования значений. Часто за счёт развитых средств составления новых функций в Haskell пользователь определяет лишь базовые функции, получая остальные “на лету” применением двух-трёх операций, это выглядит примерно как \In{(2+3)*5}, где вместо чисел стоят базовые функции, а операции \In{+} и \In{*} составляют новые функции из простейших.</p>
<h2 id="обобщённые-функции">Обобщённые функции</h2>
<p>В этом разделе мы познакомимся с несколькими функциями, которые принимают одни функции и составляют по ним другие. Эти функции используются в Haskell очень часто. Все они живут в модуле \In{Data.Function}. Модуль \In{Prelude} экспортирует их из этого модуля.</p>
<h3 id="функция-тождества">Функция тождества</h3>
<p>Начнём с самой простой функции. Это функция \In{id}. Она ничего не делает с аргументом, просто возвращает его:</p>

\begin{code}
id :: a -> a
id x = x
\end{code}

<p>Зачем нам может понадобиться такая функция? Сама по себе она бесполезна. Она приобретает ценность при совместном использовании с другими функциями, поэтому пока мы не будем приводить примеров.</p>
<h3 id="константная-функция">Константная функция</h3>
<p>Следующая функция \In{const} принимает значение и возвращает постоянную функцию. Эта функция будет возвращать константу для любого переданного в неё значения:</p>

\begin{code}
const :: a -> b -> a
const a _ = a
\end{code}

<p>Функция \In{const} является конструктором постоянных функций, так например мы получаем пятёрки на любой аргумент:</p>

\begin{code}
Prelude> let onlyFive = const 5
Prelude> :t onlyFive 
onlyFive :: b -> Integer
Prelude> onlyFive "Hi"
5
Prelude> onlyFive (1,2,3)
5
Prelude> map onlyFive "abracadabra"
[5,5,5,5,5,5,5,5,5,5,5]
\end{code}

<p>С её помощью мы можем легко построить и постоянную функцию двух аргументов:</p>

\begin{code}
const2 a = const (const a)
\end{code}

<p>Вспомним определение для \In{&&}:</p>

\begin{code}
(&&) :: Bool -> Bool -> Bool
(&&) True   x  = x
(&&) False  _  = False  
\end{code}

<p>С помощью функций \In{id} и \In{const} мы можем сократить число аргументов и уравнений:</p>

\begin{code}
(&&) :: Bool -> Bool -> Bool
(&&) a = if a then id else (const False)
\end{code}

<p>Также мы можем определить и логическое “или”:</p>

\begin{code}
(||) :: Bool -> Bool -> Bool
(||) a = if a then (const True) else id
\end{code}

<h3 id="функция-композиции">Функция композиции</h3>
<p>Функция композиции принимает две функции и составляет из них последовательное применение функций:</p>

\begin{code}
(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g = \x -> f (g x)
\end{code}

<p>Это очень полезная функция. Она позволяет нанизывать функции друг на друга. Мы перехватываем выход второй функции, сразу подставляем его в первую и возвращаем её выход в качестве результата. Например перевернём список символов и затем сделаем все буквы заглавными:</p>

\begin{code}
Prelude> :m +Data.Char
Prelude Data.Char> (map toUpper . reverse) "abracadabra"
"ARBADACARBA"
\end{code}

<p>Приведём пример посложнее:</p>

\begin{code}
add :: Nat -> Nat -> Nat
add  a  Zero     = a
add  a  (Succ b) = Succ (add a b)
\end{code}

<p>Если мы определим функцию свёртки для \In{Nat}, которая будет заменять в значении типа \In{Nat} конструкторы на соответствующие по типу функции:</p>

\begin{code}
foldNat :: a -> (a -> a) -> Nat -> a
foldNat zero succ Zero     = zero
foldNat zero succ (Succ b) = succ (foldNat zero succ b)
\end{code}

<p>То мы можем переписать с помощью функции композиции эту функцию так:</p>

\begin{code}
add :: Nat -> Nat -> Nat
add = foldNat  id  (Succ . )
\end{code}

<p>Куда делись аргументы? Они выражаются через функции \In{id} и \In{(.)}. Поведение этой функции лучше проиллюстрировать на примере. Пусть у нас есть два числа типа \In{Nat}:</p>

\begin{code}
two     = Succ (Succ Zero)
three   = Succ (Succ (Succ Zero))
\end{code}

<p>Вычислим</p>

\begin{code}
add two three
\end{code}

<p>Вспомним о частичном применении:</p>

\begin{code}
    add two three 
=>  (add two) three
=>  (foldNat id (Succ . ) (Succ (Succ Zero))) three
\end{code}

<p>Теперь функция свёртки заменит все конструкторы \In{Succ} на \In{(Succ . )}, а конструкторы \In{Zero} на \In{id}:</p>

\begin{code}
=>  ((Succ . ) ((Succ . ) id)) three
\end{code}

<p>Что это за монстр?</p>

\begin{code}
((Succ . ) ((Succ . ) id))
\end{code}

<p>Функция \In{(Succ . )} это левое сечение операции \In{(.)}. Эта функция, которая принимает функции и возвращает функции. Она принимает функцию и навешивает на её выход конструктор \In{Succ}. Давайте упростим это большое выражение с помощью определений функций \In{(.)} и \In{id}:</p>

\begin{code}
    ((Succ . ) ((Succ . ) id))
=>   (Succ . ) (\x -> Succ (id x))
=>   (Succ . ) (\x -> Succ x)
=>   \x -> Succ (Succ x)
\end{code}

<p>Теперь нам осталось применить к этой функции наше второе значение:</p>

\begin{code}
    (\x -> Succ (Succ x)) three
=>  Succ (Succ three)
=>  Succ (Succ (Succ (Succ (Succ x))))
\end{code}

<p>Так мы получили, что и ожидалось от сложения. За каждый конструктор \In{Succ} в первом аргументе мы добавляем применение \In{Succ} к результату, а вместо \In{Zero} протаскиваем через \In{id} второй аргумент.</p>
<h3 id="аналогия-с-числами">Аналогия с числами</h3>
<p>С помощью функции композиции мы можем нанизывать друг на друга списки функций. Попробуем в интерпретаторе:</p>

\begin{code}
Prelude> let f = foldr (.) id [sin, cos, sin, cos, exp, (+1), tan]
Prelude> f 2
0.6330525927559899
Prelude> f 15
0.7978497904127007
\end{code}

<p>Функция \In{foldr} заменит в списке каждый конструктор \In{(:)} на функцию композиции, а пустой список на функцию \In{id}. В результате получается композиция из всех функций в списке.</p>
<p>Это очень похоже на сложение или умножение чисел в списке. При этом в качестве нуля (для сложения) или единицы (для умножения) мы используем функцию \In{id}. Мы пользуемся тем, что по определению для любой функции \In{f} выполнены тождества:</p>

\begin{code}
f  . id  ==  f
id . f   ==  f
\end{code}

<p>Поэтому мы можем использовать \In{id} в качестве накопителя результата композиции, как в случае:</p>

\begin{code}
Prelude> foldr (*) 1 [1,2,3,4]
24
\end{code}

<p>Если сравнить \In{(.)} с умножением, то \In{id} похоже на единицу, а \In{(const a)} на ноль. В самом деле для любой функции \In{f} и любого значения \In{a} выполнено тождество:</p>

\begin{code}
const a  .  f  == const a
\end{code}

<p>Мы словно умножаем функцию на ноль, делая её вычисление бессмысленным.</p>
<h3 id="функция-перестановки">Функция перестановки</h3>
<p>Функция перестановки \In{flip} принимает функцию двух аргументов и меняет аргументы местами:</p>

\begin{code}
flip  :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x
\end{code}

<p>К примеру:</p>

\begin{code}
Prelude> foldr (-) 0 [1,2,3,4]
-2
Prelude> foldr (flip (-)) 0 [1,2,3,4]
-10
\end{code}

<p>Иногда это бывает полезно.</p>
<h3 id="функция-on">Функция on</h3>
<p>Функция \In{on} (от англ.~на) перед применением бинарной функции пропускает аргументы через унарную функцию:</p>

\begin{code}
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
(.*.) `on` f = \x y -> f x .*. f y
\end{code}

<p>Она часто используется в сочетании с функцией \In{sortBy} из модуля \In{Data.List}. Эта функция имеет тип:</p>

\begin{code}
sortBy :: (a -> a -> Ordering) -> [a] -> [a]
\end{code}

<p>Она сортирует элементы списка согласно некоторой функции упорядочивания \In{f ::  (a -> a -> Ordering)}. С помощью функции \In{on} мы можем легко составить такую функцию на лету:</p>

\begin{code}
let xs = [(3, "John"), (2, "Jack"), (34, "Jim"), (100, "Jenny"), (-3, "Josh")]  
Prelude> :m +Data.List Data.Function
Prelude Data.List Data.Function> 
Prelude Data.List Data.Function> sortBy (compare `on` fst) xs
[(-3,"Josh"),(2,"Jack"),(3,"John"),(34,"Jim"),(100,"Jenny")]
Prelude Data.List Data.Function> map fst (sortBy (compare `on` fst) xs)
[-3,2,3,34,100]
Prelude Data.List Data.Function> map snd (sortBy (compare `on` fst) xs)
["Josh","Jack","John","Jim","Jenny"]
\end{code}

<p>Мы импортировали в интерпретатор модуль \In{Data.List} для функции \In{sortBy} а также модуль \In{Data.Function} для функции \In{on}. Они не импортируются модулем \In{Prelude}.</p>
<p>Выражением \In{(compare `on` fst)} мы составили функцию</p>

\begin{code}
\a b -> compare (fst a) (fst b)

fst = \(a, b) -> a
\end{code}

<p>Тем самым ввели функцию упорядочивания на парах, которая будет сравнивать пары по первому элементу. Отметим, что аналогичного эффекта можно добиться с помощью функции \In{comparing} из модуля \In{Data.Ord}.</p>
<h3 id="функция-применения">Функция применения</h3>
<p>Ещё одной очень полезной функцией является функция применения \In{($)}. Посмотрим на её определение:</p>

\begin{code}
($) :: (a -> b) -> a -> b
f $ x  =  f x
\end{code}

<p>На первый взгляд её определение может показаться бессмысленным. Зачем нам специальный знак для применения, если у нас уже есть пробел? Для ответа на этот вопрос нам придётся познакомиться с приоритетом инфиксных операций.</p>
<h2 id="приоритет-инфиксных-операций">Приоритет инфиксных операций</h2>
<p>В Haskell очень часто используются бинарные операции для составления функций “на лету”. В этом помогает и частичное применение, мы можем в одном выражении применить к функции часть аргументов, построить из неё новую функцию с помощью какой-нибудь такой бинарной операции и всё это передать в другую функцию!</p>
<p>Для сокращения числа скобок нам понадобится разобраться в понятии приоритета операции. Так например в выражении</p>

\begin{code}
> 2 + 3 * 10
32
\end{code}

<p>Мы полагаем, что умножение имеет больший приоритет чем сложение и со скобками это выражение будет выглядеть так:</p>

\begin{code}
> 2 + (3 * 10)
32
\end{code}

<p>Фраза “больший приоритет” означает: сначала умножение потом сложение. Мы всегда можем изменить поведение по умолчанию с помощью скобок:</p>

\begin{code}
> (2 + 3) * 10
50
\end{code}

<p>В Haskell приоритет функций складывается из двух понятий: старшинство и ассоциативность. Старшинство определяется числами, они могут быть от 0 до 9. Чем больше это число, тем выше приоритет функций.</p>
<p>Старшинство используется вычислителем для группировки разных операций, например \In{(+)} имеет старшинство 6, а \In{(*)} имеет старшинство 7. Поэтому интерпретатор сначала ставит скобки вокруг выражения с \In{(*)}, а затем вокруг \In{(+)}. Считается, что обычное префиксное применение имеет высший приоритет 10. Нельзя задать приоритет выше применения, это значит, что операция “пробел” будет всегда выполняться первой.</p>
<p>Ассоциативность используется для группировки одинаковых операций, например мы видим:</p>

\begin{code}
1+2+3+4
\end{code}

<p>Как нам быть? Мы можем группировать скобки слева направо:</p>

\begin{code}
((1+2)+3)+4
\end{code}

<p>Или справа налево:</p>

\begin{code}
1+(2+(3+4))
\end{code}

<p>Ответ на этот вопрос даёт ассоциативность, она бывает левая и правая. Например операции \In{(+)} \In{(-)} и (*) являются лево-ассоциативными, а операция возведения в степень \In{(^)} является право-ассоциативной.</p>

\begin{code}
1 + 2 + 3 == (1 + 2) + 3
1 ^ 2 ^ 3 ==  1 ^ (2 ^ 3)
\end{code}

<p>Приоритет функции можно узнать в интерпретаторе с помощью команды \In{:i}:</p>

\begin{code}
*FunNat> :m Prelude
Prelude> :i (+)
class (Eq a, Show a) => Num a where
  (+) :: a -> a -> a
  ...
  	-- Defined in GHC.Num
infixl 6 +
Prelude> :i (*)
class (Eq a, Show a) => Num a where
  ...
  (*) :: a -> a -> a
  ...
  	-- Defined in GHC.Num
infixl 7 *
Prelude> :i (^)
(^) :: (Num a, Integral b) => a -> b -> a 	-- Defined in GHC.Real
infixr 8 ^
\end{code}

<p>Приоритет указывается в строчках \In{infixl 6 +} и \In{infixl 7 *}. Цифра указывает на старшинство операции, а суффикс \In{l} (от англ.~left – левая) или \In{r} (от англ.~right – правая) на ассоциативность.</p>
<p>Если мы создали свою функцию, мы можем определить для неё ассоциативность. Для этого мы пишем в коде:</p>

\begin{code}
module Fixity where

import Prelude(Num(..))

infixl 4 *** 
infixl 5 +++
infixr 5 `neg`

(***) = (*)
(+++) = (+)
neg   = (-)
\end{code}

<p>Мы ввели новые операции и поменяли старшинство операций сложения и умножения местами и изменили ассоциативность у вычитания. Проверим в интерпретаторе:</p>

\begin{code}
Prelude> :l Fixity
[1 of 1] Compiling Fixity           ( Fixity.hs, interpreted )
Ok, modules loaded: Fixity.
*Fixity> 1 + 2 * 3
7
*Fixity> 1 +++ 2 *** 3
9
*Fixity> 1 - 2 - 3
-4
*Fixity> 1 `neg` 2 `neg` 3
2
\end{code}

<p>Посмотрим как это вычислялось:</p>

\begin{code}
1   +   2   *  3  ==   1   +   (2    *   3)
1  +++  2  *** 3  ==  (1  +++   2)  ***  3

1   -   2   -  3  ==  (1   -    2)   -   3
1 `neg` 2 `neg 3` ==   1 `neg` (2  `neg` 3)
\end{code}

<p>Также в Haskell есть директива \In{infix} это тоже самое, что и \In{infixl}.</p>
<h3 id="приоритет-функции-композиции">Приоритет функции композиции</h3>
<p>Посмотрим на приоритет функции композиции:</p>

\begin{code}
Prelude> :i (.)
(.) :: (b -> c) -> (a -> b) -> a -> c 	-- Defined in GHC.Base
infixr 9 .
\end{code}

<p>Она имеет высший приоритет. Она очень часто используется при определении функции в бесточечном стиле. Такая функция похожа на конвейер функций:</p>

\begin{code}
fun a = fun1 a . fun2 (x1 + x2) . fun3 . (+x1) 
\end{code}

<h3 id="приоритет-функции-применения">Приоритет функции применения</h3>
<p>Теперь посмотрим на полное определение функции применения:</p>

\begin{code}
infixr 0 $

($) :: (a -> b) -> a -> b
f $ x  =  f x
\end{code}

<p>Ответ на вопрос о полезности этой функции кроется в её приоритете. Ей назначен самый низкий приоритет. Она будет исполняться в последнюю очередь. Очень часто возникают ситуации вроде:</p>

\begin{code}
foldNat zero succ (Succ b) = succ (foldNat zero succ b)
\end{code}

<p>С помощью функции применения мы можем переписать это определение так:</p>

\begin{code}
foldNat zero succ (Succ b) = succ $ foldNat zero succ b
\end{code}

<p>Если бы мы написали без скобок:</p>

\begin{code}
... = succ foldNat zero succ b
\end{code}

<p>То выражение было бы сгруппировано так:</p>

\begin{code}
... = (((succ foldNat) zero) succ) b
\end{code}

<p>Но поскольку мы поставили барьер в виде операции \In{($)} с низким приоритетом, группировка скобок произойдёт так:</p>

\begin{code}
... = (succ $ ((foldNat zero) succ) b)
\end{code}

<p>Это как раз то, что нам нужно. Преимущество этого подхода проявляется особенно ярко если у нас несколько вложенных функций на конце выражения:</p>

\begin{code}
xs :: [Int]
xs = reverse $ map ((+1) . (*10)) $ filter even $ ns 40

ns :: Int -> [Int]
ns 0  = []
ns n  = n : ns (n - 1)
\end{code}

<p>В списке \In{xs} мы сначала создаём в функции \In{ns} убывающий список чисел, затем оставляем лишь чётные, потом применяем два арифметических действия ко всем элементам списка, затем переворачиваем список.</p>
<p>Проверим работает ли это в интерпретаторе, заодно поупражняемся в композиционном стиле:</p>

\begin{code}
Prelude> let ns n = if (n == 0) then [] else n : ns (n - 1)
Prelude> let even x = 0 == mod x 2
Prelude> let xs = reverse $ map ((+1) . (*10)) $ filter even $ ns 20
Prelude> xs 
[21,41,61,81,101,121,141,161,181,201]
\end{code}

<p>Если бы не функция применения нам пришлось бы написать это выражение так:</p>

\begin{code}
xs = reverse (map ((+1) . (*10)) (filter even (ns 40)))
\end{code}

<h2 id="функциональный-калькулятор">Функциональный калькулятор</h2>
<p>Мне бы хотелось сделать акцент на одном из вступительных предложений этой главы:</p>
<blockquote>
<p>За счёт развитых средств составления новых функций в Haskell пользователь определяет лишь базовые функции, получая остальные “на лету” применением двух-трёх операций, это выглядит примерно как \In{(2+3)*5}, где вместо чисел стоят базовые функции, а операции \In{+} и \In{*} составляют новые функции из простейших.</p>
</blockquote>
<p>Такие обобщённые функции как \In{id}, \In{const}, \In{(.)}, \In{map} \In{filter} позволяют очень легко комбинировать различные функции. Бесточечный стиль записи функций превращает функции в простые значения или значения-константы, которые можно подставлять в другие функции. В этом разделе мы немного потренируемся в перегрузке численных значений и превратим числа в функции, функции и в самом деле станут константами. Мы определим экземпляр \In{Num} для функций, которые возвращают числа. Смысл этих операций заключается в том, что теперь мы применяем обычные операции сложения умножения к функциям, аргумент которых совпадает по типу. Например для того чтобы умножить функции \verb!\!t -> t+2 и \verb!\!t -> t+3 мы составляем новую функцию \verb!\!t -> (t+2) * (t+3), которая получает на вход значение \In{t} применяет его к каждой из функций и затем умножает результаты:</p>

\begin{code}
module FunNat where

import Prelude(Show(..), Eq(..), Num(..), error)

instance Show (t -> a) where
    show _ = error "Sorry, no show. It's just for Num"
instance Eq (t -> a) where
    (==) _ _ = error "Sorry, no Eq. It's just for Num"

instance Num a => Num (t -> a) where
    (+) = fun2 (+)
    (*) = fun2 (*)
    (-) = fun2 (-)

    abs      = fun1 abs
    signum   = fun1 signum

    fromInteger = const . fromInteger

fun1 :: (a -> b) -> ((t -> a) -> (t -> b))
fun1 = (.)

fun2 :: (a -> b -> c) -> ((t -> a) -> (t -> b) -> (t -> c))
fun2 op a b = \t -> a t `op` b t
\end{code}

<p>Функции \In{fun1} и \In{fun2} превращают функции, которые принимают значения, в функции, которые принимают другие функции.</p>
<p>Из-за контекста класса \In{Num} нам пришлось объявить два фиктивных экземпляра для классов \In{Show} и \In{Eq}. Загрузим модуль \In{FunNat} в интерпретатор и посмотрим что же у нас получилось:</p>

\begin{code}
Prelude> :l FunNat.hs
[1 of 1] Compiling FunNat           ( FunNat.hs, interpreted )
Ok, modules loaded: FunNat.
*FunNat> 2 2
2
*FunNat> 2 5
2
*FunNat> (2 + (+1)) 0 
3
*FunNat> ((+2) * (+3)) 1
12
\end{code}

<p>На первый взгляд кажется что выражение \In{2 2} не должно пройти проверку типов, ведь мы применяем значение к константе. Но на самом деле \In{2} это не константа, а значение \In{2 :: Num a => a} и подспудно к двойке применяется функция \In{fromInteger}. Поскольку в нашем модуле мы определили экземпляр \In{Num} для функций, второе число \In{2} было конкретизировано по умолчанию до \In{Integer}, а первое число \In{2} было конкретизировано до \In{Integer -> Integer}. Компилятор вывел из контекста, что под \In{2} мы понимаем функцию. Функция была создана с помощью метода \In{fromInteger}. Эта функция принимает любое значение и возвращает двойку.</p>
<p>Далее мы складываем и перемножаем функции словно это обычные значения. Что интересно мы можем составлять и такие выражения:</p>

\begin{code}
*FunNat> let f = ((+) - (*))
*FunNat> f 1 2
1
\end{code}

<p>Как была вычислена эта функция? Мы определили экземпляр функций для значений типа \In{Num a => t -> a}. Если мы вспомним, что функция двух аргументов на самом деле является функцией одного аргумента: \In{Num a => t1 -> (t2 -> a)}, мы заметим, что тип \In{Num a => (t2 -> a)} принадлежит \In{Num}, теперь если мы обозначим его за \In{a'}, то мы получим тип \In{Num a' => t1 -> a'}, это совпадает с нашим исходным экземпляром.</p>
<p>Получается, что за счёт механизма частичного применения мы одним махом определили экземпляры \In{Num} для функций <em>любого</em> числа аргументов, которые возвращают значение типа \In{Num}.</p>
<p>Итак функция \In{f} имеет вид:</p>

\begin{code}
\t1 t2 -> (t1 + t2) - (t1 * t2)
\end{code}

<p>Подставим значения:</p>

\begin{code}
(\t1 t2 -> (t1 + t2) - (t1 * t2)) 1 2
(\t2 -> (1 + t2) - (1 * t2) 2
(1 + 2) - (1 * 2)
3 - 2
1
\end{code}

<p>Теперь давайте составим несколько выражений с обобщёнными функциями. Для этого добавим в модуль \In{FunNat} директиву импорта функций из модуля \In{Data.Function}. Также добавим несколько основных функций для списков и класс \In{Ord}:</p>

\begin{code}
module FunNat where

import Prelude(Show(..), Eq(..), Ord(..), Num(..), error)

import Data.Function(id, const, (.), ($), flip, on)
import Prelude(map, foldr, filter, zip, zipWith)

...
\end{code}

<p>и загрузим модуль в интерпретатор:</p>

\begin{code}
Prelude> :load FunNat
[1 of 1] Compiling FunNat           ( FunNat.hs, interpreted )
Ok, modules loaded: FunNat.
\end{code}

<p>Составим функцию, которая принимает один аргумент, умножает его на два, вычитает 10 и берёт модуль числа.</p>

\begin{code}
*FunNat> let f = abs $ id * 2 - 10 
*FunNat> f 2
6
*FunNat> f 10
10
\end{code}

<p>Давайте посмотрим как была составлена эта функция:</p>

\begin{code}
    abs $ id * 2 - 10                   

=>  abs $ (id * 2) - 10                 -- приоритет умножения
=>  abs $ (\x -> x * \x -> 2) - 10      -- развернём id и 2
=>  abs $ (\x -> x * 2) - 10            -- по определению (*) для функций
=>  abs $ (\x -> x * 2) - \x -> 10      -- развернём 10
=>  abs $ \x -> (x * 2) - 10            -- по определению (-) для функций
=>  \x -> abs x . \x -> (x * 2) - 10    -- по определению abs для функций
=>  \x -> abs ((x * 2) - 10)            -- по определению (.)

=>  \x -> abs ((x * 2) - 10)
\end{code}

<p>Функция возведения в квадрат:</p>

\begin{code}
*FunNat> let f = id * id
*FunNat> map f [1,2,3,4,5]
[1,4,9,16,25]
*FunNat> map (id * id - 1) [1,2,3,4,5]
[0,3,8,15,24]
\end{code}

<p>Обратите внимание на краткость записи. В этом выражении \In{(id * id - 1)} проявляется основное преимущество бесточечного стиля, избавившись от аргументов, мы можем пользоваться функциями так, словно это простые значения. Этот приём используется в Haskell очень активно. Пока нам встретились лишь две инфиксных операции для функций (это композиция и применение с низким приоритетом), но в будущем вы столкнётесь с целым морем подобных операций. Все они служат одной цели, они прячут аргументы функции, позволяя быстро составлять функции на лету из примитивов. Чтобы не захлебнуться в этом море помните, что скорее всего новый символ означает либо композицию либо применение для функций специального вида.</p>
<p>Возведём в четвёртую степень:</p>

\begin{code}
*FunNat> map (f . f) [1,2,3,4,5]
[1,16,81,256,625]
\end{code}

<p>Составим функцию двух аргументов, которая будет вычислять сумму квадратов двух аргументов:</p>

\begin{code}
*FunNat> let x = const id
*FunNat> let y = flip $ const id
*FunNat> let d = x * x + y * y
*FunNat> d 1 2
5
*FunNat> d 3 2
13
\end{code}

<p>Так мы составили функцию, ни прибегая к помощи аргументов. Эти выражения могут стать частью других выражений:</p>

\begin{code}
*FunNat> filter  ((<10) . d 1) [1,2,3,4,5]
[1,2]
*FunNat> zipWith d [1,2,3] [3,2,1]
[10,8,10]
*FunNat> foldr (x*x - y*y) 0 [1,2,3,4]
3721610024
*FunNat> zipWith ((-) * (-) + const id) [1,2,3] [3,2,1]
[7,2,5]
\end{code}

<p>В последнем выражении трудно предугадать результат. В таких выражениях всё-таки лучше пользоваться синонимами. В бесточечном стиле мы можем несколькими операциями собрать из базовых функций сложную функцию и передать её аргументом в другую функцию, которая также может поучаствовать в комбинации других функций!</p>
<h2 id="функции-возвращающие-несколько-значений">Функции, возвращающие несколько значений</h2>
<p> Как было сказано ранее функции, которые возвращают несколько значений, реализованы в Haskell с помощью кортежей. Например функция, которая расщепляет поток на голову и хвост выглядит так:</p>

\begin{code}
decons :: Stream a -> (a, Stream a)
decons (a :& as) = (a, as)
\end{code}

<p>Здесь функция возвращает сразу два значения. Но всегда ли уместно пользоваться кортежами? Для композиции функций, которые возвращают несколько значений нам придётся разбирать возвращаемые значения с помощью сопоставления с образцом и затем использовать эти значения в других функциях. Посудите сами если у нас есть функции:</p>

\begin{code}
f :: a  -> (b1, b2)
g :: b1 -> (c1, c2)
h :: b2 -> (c3, c4)
\end{code}

<p>Мы уже не сможем комбинировать их так просто как если бы это были обычные функции без кортежей.</p>

\begin{code}
q x = (\(a, b) -> (g a, h b)) (f x)
\end{code}

<p>В случае пар нам могут прийти на помощь функции \In{first} и \In{second}:</p>

\begin{code}
q = first g . second h . f
\end{code}

<p>Если мы захотим составить какую-нибудь другую функцию из \In{q}, то ситуация заметно усложнится. Функции, возвращающие кортежи, сложнее комбинировать в бесточечном стиле. Здесь стоит вспомнить правило Unix.</p>
<blockquote>
<p>Пишите функции, которые делают одну вещь, но делают её хорошо.</p>
</blockquote>
<p>Функция, которая возвращает кортеж пытается сделать сразу несколько дел. И теряет в гибкости, ей трудно взаимодействовать с другими функциями. Старайтесь чтобы таких функций было как можно меньше.</p>
<p>Если функция возвращает несколько значений, попытайтесь разбить её на несколько, которые возвращают лишь одно значение. Часто бывает так, что эти значения тесно связаны между собой и такую функцию не удаётся разбить на несколько составляющих. Если у вас появляется много таких функций, то это повод задуматься о создании нового типа данных.</p>
<p>Например в качестве точки на плоскости можно использовать пару \In{(Float, Float)}. В этом случае, если вы начнёте писать модуль на геометрическую тему у вас появится много функций, которые принимают и возвращают точки:</p>

\begin{code}
rotate      :: Float -> (Float, Float) -> (Float, Float)
norm        :: (Float, Float) -> (Float, Float)
translate   :: (Float, Float) -> (Float, Float) -> (Float, Float)
...    
\end{code}

<p>Все они стараются делать несколько дел одновременно, возвращая кортежи. Но мы можем изменить ситуацию определением новых типов:</p>

\begin{code}
data Point  = Point  Float Float
data Vector = Vector Float Float
data Angle  = Angle  Float
\end{code}

<p>Объявления функций станут более краткими и наглядными.</p>

\begin{code}
rotate      :: Angle  -> Point -> Point
norm        :: Point  -> Point
translate   :: Vector -> Point -> Point
...    
\end{code}

<h2 id="комбинатор-неподвижной-точки">Комбинатор неподвижной точки</h2>
<p>Познакомимся с функцией \In{fix} или комбинатором неподвижной точки. По хорошему об этой функции следовало бы рассказать в разделе обобщённые функции. Но я пропустил её нарошно, для простоты изложения. В этом разделе градус сложности резко подскакивает, если вы ранее не встречались с этой функцией она может показаться вам очень необычной. Для начала посмотрим на её тип:</p>

\begin{code}
Prelude> :m +Data.Function
Prelude Data.Function> :t fix
fix :: (a -> a) -> a
\end{code}

<p>Странно \In{fix} принимает функцию и возвращает значение, обычно всё происходит наоборот. Теперь посмотрим на определение:</p>

\begin{code}
fix f = let x = f x
        in  x
\end{code}

<p>Если вы запутались, то посмыслу это определение равносильно такому:</p>

\begin{code}
fix f = f (fix f)
\end{code}

<p>Функция \In{fix} берёт функцию и начинает бесконечно нанизывать её саму на себя. Так мы получаем, что-то вроде:</p>

\begin{code}
f (f (f (f (...))))
\end{code}

<p>Зачем нам такая функция? Помните в самом конце четвёртой главы в упражнениях мы составляли бесконечные потоки. Мы делали это так:</p>

\begin{code}
data Stream a = a :& Stream a

constStream :: a -> Stream a
constStream a = a :& constStream a
\end{code}

<p>Если смотреть на функцию \In{constStream} очень долго, то рано или поздно в ней проглянет функция \In{fix}. Я нарошно не буду выписывать, а вы мысленно обозначьте \In{(a :&)} за \In{f} и \In{constStream a} за \In{fix f}. Получилось?</p>
<p>Через \In{fix} можно очень просто определить бесконечность для \In{Nat}, бесконечность это цепочка \In{Succ}, которая никогда не заканчивается \In{Zero}. Оказывается, что в Haskell мы можем составлять выражения с такими значениями (как это получается мы обудим попозже):</p>

\begin{code}
ghci Nat
*Nat>m + Data.Function
*Nat Data.Function> let infinity = fix Succ
*Nat Data.Function> infinity < Succ Zero
False
\end{code}

<p>С помощью функции \In{fix} можно выразить любую рекурсивную функцию. Посмотрим как на примере функции \In{foldNat}, у нас есть рекурсивное определение:</p>

\begin{code}
foldNat :: a -> (a -> a) -> Nat -> a
foldNat z  s  Zero      = z
foldNat z  s  (Succ n)  = s (foldNat z s n)
\end{code}

<p>Необходимо привести его к виду:</p>

\begin{code}
x = f x
\end{code}

<p>Слева и справа мы видим повторяются выражения \In{foldNat z s}, обозначим их за \In{x}:</p>

\begin{code}
x :: Nat -> a
x Zero      = z
x (Succ n)  = s (x n)
\end{code}

<p>Теперь перенесём первый аргумент в правую часть, сопоставление с образцом превратится в \In{case}-выражение:</p>

\begin{code}
x :: Nat -> a
x = \nat -> case nat of
                Zero    -> z
                Succ n  -> s (x n)
\end{code}

<p>В правой части вынесем \In{x} из выражения с помощью лямбда функции:</p>

\begin{code}
x :: Nat -> a
x = (\t -> \nat -> case nat of
                        Zero    -> z
                        Succ n  -> s (t n)) x 
\end{code}

<p>Смотрите мы обозначили вхождение \In{x} в выражении справа за \In{t} и создали лямбда-функцию с таким аргументом. Так мы вынесли \In{x} из выражения.</p>
<p>Получилось, мы пришли к виду комбинатора неподвижной точки:</p>

\begin{code}
x :: Nat -> a
x = f x
    where f = \t -> \nat -> case nat of
                        Zero    -> z
                        Succ n  -> s (t n)
\end{code}

<p>Приведём в более человеческий вид:</p>

\begin{code}
foldNat :: a -> (a -> a) -> (Nat -> a)
foldNat z s = fix f
    where f t = \nat -> case nat of
                            Zero    -> z
                            Succ n  -> s (t n)
\end{code}

<h2 id="краткое-содержание">Краткое содержание</h2>
<h3 id="основные-функции-высшего-порядка">Основные функции высшего порядка</h3>
<p>Мы познакомились с функциями из модуля \In{Data.Function}. Их можно разбить на несколько типов:</p>
<ul>
<li>Примитивные функции (генераторы функций).</li>
</ul>

\begin{code}
id      = \x -> x
const a = \_ -> a
\end{code}

<ul>
<li>Функции, которые комбинируют функции или функции и значения:</li>
</ul>

\begin{code}
f . g  = \x -> f (g x)
f $ x  = f x

(.*.) `on` f = \x y -> f x .*. f y
\end{code}

<ul>
<li>Преобразователи функций, принимают функцию и возвращают функцию:</li>
</ul>

\begin{code}
flip f = \x y -> f y x
\end{code}

<ul>
<li>Комбинатор неподвижной точки:</li>
</ul>

\begin{code}
fix f = let x = f x
        in  x
\end{code}

<h3 id="приоритет-инфиксных-операций-1">Приоритет инфиксных операций</h3>
<p>Мы узнали о специальном синтаксисе для задания приоритета применения функций в инфиксной форме:</p>

\begin{code}
infixl 3 #
infixr 6 `op`
\end{code}

<p>Приоритет складывается из двух частей: старшинства (от 1 до 9) и ассоциативности (бывает левая и правая). Старшинство определяет распределение скобок между разными функциями:</p>

\begin{code}
infixl 6 +
infixl 7 *

1 + 2 * 3 == 1 + (2 * 3)
\end{code}

<p>А ассоциативность – между одинаковыми:</p>

\begin{code}
infixl 6 +
infixr 8 ^

1 + 2 + 3 == (1 + 2) + 3    
1 ^ 2 ^ 3 ==  1 ^ (2 ^ 3)  
\end{code}

<p>Мы узнали, что функции \In{($)} и \In{(.)} стоят на разных концах шкалы приоритетов функций и как этим пользоваться.</p>
<h2 id="упражнения">Упражнения</h2>
<ul>
<li><p>Просмотрите написанные вами функции, или функции из примеров. Можно ли их переписать с помощью основных функций высшего порядка? Если да, то перепишите. Попробуйте определить их в бесточечном стиле.</p></li>
<li><p>В прошлой главе у нас было упражнение о потоках. Сделайте поток экземпляром класса \In{Num}. Для этого поток должен содержать значения из класса \In{Num}. Методы из класса \In{Num} применяются поэлементно. Так сложение двух потоков будет выглядеть так:</p>

\begin{code}
(a1 :& a2 :& a3 :& ...) + (b1 :& b2 :& b3) ==
==  (a1 + b1 :& a2 + b2 :& a3 + b3 :& ...)
\end{code}
</li>
<li><p>Определите приоритет инфиксной операции \In{(:&)}<br /> так чтобы вам было удобно использовать её в сочетании с арифметическими операциями.</p></li>
<li><p>Рассмотрим такой тип:</p>

\begin{code}
data St a b = St (a -> (b, St a b))
\end{code}

<p>Этот тип хранит функцию, которая позволяет преобразовывать потоки значений. Определите функцию применения:</p>

\begin{code}
ap :: St a b -> [a] -> [b]
\end{code}

<p>Она принимает ленту входящих значений и возвращает ленту выходов. Определите для этого типа несоколько основных функций высшего порядка. Чтобы не возникало конфликта имён с модулем \In{Data.Function} мы не будем его импортировать. Вместо него мы импортируем модуль \In{Control.Category}. Он содержит класс:</p>

\begin{code}
class Category cat where
        id  :: cat a a
        (.) :: cat b c -> cat a b -> cat a c
\end{code}

<p>Если присмотреться к типам функций, можно понять, что тип-экземпляр \In{cat} принимает два параметра. Совсем как тип функции \In{(a -> b)}. Формально его можно записать в префиксной форме так \In{(->) a b}. Получается, что тип \In{cat} это что-то вроде функции. Это некоторые сущности, у которых есть понятия тождества и композиции.</p>
<p>Для обычных функций экземпляр класса \In{Category} уже определён. Но в этом модуле у нас есть ещё и необычные функции, функции которые преобразуют ленты значений. Функции \In{id} и \In{(.)} мы определим, сделав наш тип \In{St} экземпляром класса \In{Category}. Также определите постоянный преобразователь. Он на любой вход возвращает одно и то же число, и преобразователь, который будет накапливать сумму поступающих на вход значений, по-другому такой преобразователь называют интегратором:</p>

\begin{code}
const    :: a -> St b a
integral :: Num a => St a a
\end{code}
</li>
<li><p>Перепишите с помощью \In{fix} несколько стандартных функций для списков. Например \In{map}, \In{foldr}, \In{foldl}, \In{zip}, \In{repeat}, \In{cycle}, \In{iterate}.</p>
<p>Старайтесь найти наиболее краткое выражение, пользуйтесь функциями высшего порядка и частичным применением. Например рассмотрим функцию \In{repeat}:</p>

\begin{code}
repeat :: a -> [a]
repeat a = a : repeat a
\end{code}

<p>Запишем с \In{fix}:</p>

\begin{code}
repeat a = fix $ \xs -> a : xs
\end{code}

<p>Заметим, что мы можем избавиться от аргумента \In{xs} с помощью сечения:</p>

\begin{code}
repeat a = fix (a:)
\end{code}

<p>Но мы можем пойти ещё дальше, если вспомним, что функция двух аргументов \In{(:)} является функцией от одного аргумента \In{(:) :: a -> ([a] -> [a])}, которая возвращает функцию одного аргумента:</p>

\begin{code}
repeat = fix . (:)
\end{code}

<p>Смотрите в этом выражении мы составили композицию двух функций. Функция \In{(:)} примет первый аргумент и вернёт функцию, как раз то, что и нужно для \In{fix}.</p></li>
</ul>
</body>
</html>
