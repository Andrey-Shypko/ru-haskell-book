\setcounter{chapter}{2}
\chapter{Типы}

С помощью типов мы определяем все возможные значения 
в нашей программе. Мы определяем основные примитивы 
и способы их комбинирования.
Например в типе \In{Nat}:

\begin{code}
data Nat = Zero | Succ Nat
\end{code}

Один конструктор-примитив \In{Zero}, и один конструктор
\In{Succ}, с помощью которого мы можем делать составные значения.
Определив тип \In{Nat} таким образом, мы говорим, что 
значения типа \In{Nat} могут быть только такими:

\begin{code}
    Zero,  Succ Zero,  Succ (Succ Zero), Succ (Succ (Succ Zero)), ...
\end{code}

Все значения являются цепочками \In{Succ} 
с \In{Zero} на конце. Если где-нибудь мы
попытаемся построить значение, которое не соответствует
нашему типу, мы получим ошибку компиляции, т.е.~программа
не пройдёт проверку типов. Так типы описывают множество
допустимых значений.

Значения, которые проходят проверку 
типов мы будем называть \emph{допустимыми}, а те, 
которые не проходят соответственно \emph{недопустимыми}.
Так например следующие значения недопустимы для \In{Nat}

\begin{code}
    Succ Zero Zero,  Succ Succ, True, Zero (Zero Succ), ...
\end{code}

Недопустимых значений конечно гораздо больше.
Такое проявляется и в естественном языке, бессмысленных
комбинаций слов гораздо больше, чем осмысленных предложений.
Обратите внимание на то, что мы говорим о значениях
(не)допустимых для некоторого типа, например значение
\In{True} допустимо для \In{Bool}, но недопустимо для
\In{Nat}.

Сами типы строятся не произвольным образом. Мы узнали,
что при их построении используются две основные
операции, это сумма и произведение типов.
Это говорит о том, что в типах должны быть
какие-то закономерности, которые распространяются на
все значения. В этой главе мы посмотрим на эти закономерности.

\section{Структура алгебраических типов данных}

Итак у нас лишь две операции: сумма и произведение. 
Давайте для начала рассмотрим два крайних случая.

\begin{itemize}
\item Только произведение типов

\begin{code}
data T = Name T1 T2 ... TN
\end{code}

Мы говорим, что значение нашего нового типа \In{T} состоит из
значений типов \In{T1}, \In{T2}, \dots , \In{TN} и у нас есть
лишь один способ составить значение этого типа, 
единственное, что мы можем сделать это применить к 
значениям типов \In{Ti} конструктор \In{Name}.

Пример:

\begin{code}
data Time = Time Hour Second Minute
\end{code}


\item Только сумма типов

\begin{code}
data T = Name1 | Name2 | ... | NameN
\end{code}

Мы говорим, что у нашего нового типа \In{T} может быть
лишь несколько значений, и перечисляем их в альтернативах
через знак \In{|}. 

Пример:

\begin{code}
data Bool = True | False
\end{code}


\end{itemize}

Сделаем первое наблюдение: каждое произведение типов 
определяет новый конструктор. Число конструкторов в типе 
равно числу альтернатив. Так в первом случае у нас была одна
альтернатива и следовательно у нас был лишь один конструктор
\In{Name}. 

Имена конструкторов должны быть уникальными в пределах модуля.
У нас нет таких двух типов, у которых совпадают конструкторы.
Это говорит о том, что по имени конструктора компилятор
знает значение какого типа он может построить. 

Произведение типов состоит из конструктора, за которым
через пробел идут подтипы. Такая структура не случайна,
она копирует структуру функции. В качестве имени функции
выступает конструктор, а в качестве аргументов -- значения
заданных в произведении подтипов. Функция-конструктор 
после применения \Quote{оборачивает} значения аргументов
и создаёт новое значение. За счёт этого мы могли бы 
определить типы по-другому. Мы могли бы определить их в стиле
классов типов:

\begin{code}
data Bool where
    True  :: Bool
    False :: Bool
\end{code}

Мы видим \Quote{класс} \In{Bool}, у которого два метода.
Или определим в таком стиле \In{Nat}:

\begin{code}
data Nat where
    Zero  :: Nat
    Succ  :: Nat -> Nat
\end{code}

Мы переписываем подтипы по порядку в аргументы метода.
Или определим в таком стиле списки:

\begin{code}
data [a] where
    []   :: [a]
    (:)  :: a -> [a] -> [a] 
\end{code}

Конструктор пустого списка \In{[]} является константой,
а конструктор объединения элемента со списком \In{(:)}, является
функцией. Когда я говорил, что типы определяют примитивы
и методы составления из примитивов, я имел ввиду, что
некоторые конструкторы по сути являются константами, а 
другие функциями.

Эти \Quote{методы} определяют базовые значения типа, 
все другие значения будут комбинациями базовых. 
При этом сумма типов, определяет число методов \Quote{классе}
типа, т.е.~число базовых значений, а произведение типов
в каждой альтернативе определяет имя метода (именем конструктора) 
и состав аргументов (перечислением подтипов).

\section{Структура констант}

Мы уже знаем, что значения могут быть функциями и константами.
Объявляя константу, мы даём имя-синоним некоторой комбинации 
базовых конструкторов. В функции мы говорим как по одним 
значениям получить другие. В этом и следующем разделе мы
посмотрим на то, как типы определяют структуру констант и  функций.

Давайте присмотримся к константам:

\begin{code}
Succ (Succ Zero)
Neg (Add One (Mul Six Ten))
Not (Follows A (And A B))
Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))
\end{code}

Заменим все функциональные конструкторы на букву \In{f}
(от слова \emph{function}), а все примитивные конструкторы на
букву \In{c} (от слова \emph{constant}). 

\begin{code}
f (f c)
f (f c (f c c))
f (f c (f c c))
f c (f c (f c (f c c)))
\end{code}

Те кто знаком с теорией графов, возможно уже узнали в 
этой записи строчную запись дерева. Все значения в Haskell
являются деревьями. Узел дерева содержит составной конструктор, 
а лист дерева содержит примитивный конструктор. 
Далее будет небольшой подраздел посвящённый терминологии теории
графов, которая нам понадобится, будет много картинок, 
если вам это известно, то вы можете спокойно его пропустить.

\subsection{Несколько слов о теории графов}

Если вы не знакомы с теорией графов, то сейчас как раз 
самое время с ней познакомится, хотя бы на  уровне основных 
терминов. Теория графов изучает дискретные объекты в терминах
зависимостей между объектами или связей. При этом объекты и 
связи можно изобразить графически. 

Граф состоит из \emph{узлов} и \emph{рёбер}, которые соединяют
узлы. Приведём пример графа:

\Fig{Граф}{../pic/3/graph.ps}{Graph}{0.65}

В этом графе восемь узлов, они пронумерованы, и восемь рёбер, они обозначены
буквами. Теорию графов придумал Леонард Эйлер, когда решал задачу
о кёнингсбергских мостах. Он решал задачу о том, можно ли обойти 
все семь кёнингсбергских мостов так, чтобы пройти по каждому лишь 
один раз. Эйлер представил мосты в виде рёбер а участки суши в виде
узлов графа и показал, что это сделать нельзя. Но мы отвлеклись. 

А что такое дерево? 
\emph{Дерево} это такой связанный граф, у которого нет циклов. 
Несвязанный граф образует несколько островков, или множеств 
узлов, которые не соединены рёбрами. Циклы -- это
замкнутые последовательности рёбер. Например граф на рисунке
выше не является деревом, но если мы сотрём ребро \emph{e}, то у
нас получится дерево.

Ориентированный граф -- это такой граф, у которого все рёбра 
являются стрелками, они ориентированы, отсюда и название. 
При этом теперь каждое ребро не просто связывает узлы, но
имеет начало и конец. В ориентированных деревьях обычно выделяют
один узел, который называют \emph{корнем}. Его особенность заключается
в том, что все стрелки в ориентированном дереве как бы \Quote{разбегаются}
от корня или сбегаются к корню. Корень определяет 
все стрелки в дереве. Ориентированное дерево похоже на иерархию.
У нас есть корневой элемент и набор его дочерних поддеревьев,
каждое из поддеревьев в свою очередь является ориентированным
деревом и так далее. Проиллюстрируем на картинке, давайте 
сотрём ребро \emph{e} и назначим первый узел корнем. 
Все наши стрелки будут идти от корня. Сначала мы
проведём стрелки к узлам связанным с корнем:

\Fig{Превращаем в дерево \dots}{../pic/3/tree1.ps}{Tree1}{0.65}

Затем представим, что каждый из этих узлов сам является 
корнем в своём дереве и повторим эту процедуру.
На этом шаге мы дорисовываем стрелки в поддеревьях, которые 
находятся в узлах 3 и 6. Узел 5 является вырожденным деревом,
в нём всего лишь одна вершина. Мы будем называть такие поддеревья
\emph{листьями}. А невырожденные поддеревья мы будем называть узлами.
Корневой узел в данном поддереве называют родительским. А его
соседние узлы, в которые направлены исходящие из него стрелки
называют дочерними узлами. На предыдущем шаге у нас появился
один родительский узел 1, у которого три дочерних узла: 3, 6, и 5. 
А на этом шаге у нас появились ещё два родительских узла 3 и 6.
У узла 3 один дочерний узел (4), а у узла 6 -- три дочерних узла (2, 8, 7).


\Fig{Превращаем в дерево \dots}{../pic/3/tree2.ps}{Tree2}{0.65}

Отметим, что положение узлов и рёбер на картинке не важно,
главное это то, какие рёбра какие узлы соединяют. Мы можем
перерисовать это дерево в более привычном виде (\RefFig{Tree3}).

Теперь если вы посмотрите на константы в Haskell вы заметите,
что очень похожи на деревья. Листья содержат примитивные
конструкторы, а узлы -- составные. Это происходит из-за того,
что каждый конструктор содержит метку и набор подтипов. 
В этой аналогии  метки становятся узлами, а подтипы-аргументы 
становятся поддеревьями. 

Но есть одна тонкость, в которой 
заключается отличие констант Haskell от деревьев из теории графов. 
В теории графов порядок поддеревьев не важен, на \RefFig{Tree3} мы 
могли бы нарисовать поддеревья в любом порядке, главное сохранить 
связи. А в Haskell порядок следования аргументов в конструкторе 
важен. На \RefFig{Tree4} в виде деревьев изображены две константы.


\Fig{Ориентированное дерево}{../pic/3/tree3.ps}{Tree3}{0.5}

На \RefFig{Tree4} изображены две константы, это 
\In{Succ (Succ Zero) :: Nat }
и \In{Neg (Add One (Mul Six Ten)) :: Expr}. Но они изображены
немного по-другому. Я перевернул стрелки и добавил корнем ещё один 
узел, это тип константы. 

\Fig{Константы}{../pic/3/tree4.ps}{Tree4}{0.55}

Стрелки перевёрнуты так, чтобы стрелки
на картинке соответствовали стрелкам в типе конструктора.
Например по виду узла \In{Succ :: Nat -> Nat}, можно понять, что это
функция от одного аргумента, в неё впадает одна стрелка-аргумент
и вытекает одна стрелка-значение. В конструктор \In{Mul} впадает
две стрелки, значит это конструктор-функция от двух аргументов.

Константы похожи на деревья за счёт структуры операции
произведения типов. В произведении типов мы пишем:

\begin{code}
data Tnew = Name T1 T2 ... Tn
\end{code}

Так и получается, что у нашего узла \In{New} одна вытекающая
стрелка, которая символизирует значение типа \In{Tnew} и несколько
впадающих стрелок \In{T1}, \In{T2}, \dots, \In{Tn}, они символизируют 
аргументы конструктора.

Потренируйтесь изображать константы в виде деревьев, 
вспомните константы из предыдущей главы, или придумайте 
какие-нибудь новые. 

\subsection{Строчная запись деревьев}

Итак все константы в Haskell за счёт особой структуры построения
типов являются деревьями, но мы программируем в текстовом редакторе,
а не в редакторе векторной графики, поэтому нам нужен удобный способ
строчной записи дерева. Мы им уже активно пользуемся, но
сейчас давайте опишем его по-подробнее. 

Мы сидим на корне дерева и спускаемся по его вершинам. Нам
могут встретиться вершины двух типов узлы и листья. Сначала
мы пишем имя в текущем узле, затем через пробел имена в дочерних
узлах, если нам встречается невырожденный узел мы заключаем его в
скобки. Давайте последовательно запишем в строчной записи дерево
из первого примера:

\Fig{Ориентированное дерево}{../pic/3/tree5.ps}{Tree5}{0.5}

Начнём с корня и будем последовательно дописывать поддеревья,
точками обозначаются дочерние узлы, которые нам ещё предстоит дописать:

\begin{code}
(1     .       .      .       )
(1    (3 .)    5     (6 . . .))
(1    (3 4)    5     (6 2 7 8))
\end{code}

Мы можем ставить любое число пробелов между дочерними узлами,
здесь для наглядности точки выровнены. Так мы можем закодировать
исходное дерево строкой. Часто самые внешние скобки опускаются.
В итоге получилась такая запись:

\begin{code}
tree = 1 (3 4) 5 (6 2 7 8)
\end{code}

По этой записи мы можем понять, что у нас есть два 
конструктора трёх аргументов \In{1} и \In{6}, один конструктор
одного аргумента \In{3} и пять примитивных конструкторов. 
Точно так же мы строим и все другие константы в Haskell:

\begin{code}
Succ (Succ (Succ Zero))
Time (Hour 13) (Minute 10) (Second 0)
Mul (Add One Ten) (Neg (Mul Six Zero))
\end{code}

За одним исключением, если конструктор бинарный, символьный
(начинается с двоеточия), мы помещаем его между аргументов:

\begin{code}
(One :+ Ten) :* (Neg (Six :* Zero))
\end{code}


\section{Структура функций}

Функции описывают одни значения в терминах других. 
При этом важно понимать, что функция это лишь новое имя,
пусть и составное. Мы можем написать \In{5}, или \In{2+3},
это лишь два разных имени для одной константы. 
Теперь мы разобрались с тем, что константы это деревья.
Значит функции строят одни деревья из других. Как они это делают?
Для этого этого в Haskell есть две операции: это композиция
и декомпозиция деревьев. С помощью \emph{композиции} мы строим из
простых деревьев сложные, а с помощью \emph{декомпозиции} 
разбиваем составные деревья на простейшие.

Композиция и декомпозиция объединены в одной операции,
с которой мы уже встречались, это операция определения синонима.
Давайте вспомним какое-нибудь объявление функции:

\begin{code}
(+) a  Zero      = a
(+) a  (Succ b)  = Succ (a + b)
\end{code}

Смотрите в этой функции слева от знака равно мы проводим 
декомпозицию второго аргумента, а в правой части мы составляем
новое дерево из тех значений, что были нами получены слева
от знака равно. Или посмотрим на другой пример:

\begin{code}
show (Time h m s) = show h ++ ":" ++ show m ++ ":" ++ show s
\end{code}

Слева от знака равно мы также выделили из составного
дерева \In{(Time h m s)} три его дочерних для корня узла
и связали их с переменными \In{h}, \In{m} и \In{s}. А справа
от знака равно мы составили из этих переменных новое выражение. 

Итак операцию объявления синонима можно представить в таком виде:

\begin{code}
name    декомпозиция    =  композиция 
\end{code}

В каждом уравнении у нас три части: новое имя, декомпозиция,
поступающих на вход аргументов, и композиция нового значения.
Теперь давайте остановимся поподробнее на каждой из этих операций.

\subsection{Композиция и частичное применение}

Композиция строится по очень простому правилу, если у нас
есть значение \In{f} типа \In{a -> b} и значение \In{x} типа
\In{a}, мы можем получить новое значение \mbox{\In{(f x)}} типа
\In{b}. Это основное правило построения новых значений, поэтому
давайте запишем его отдельно: 

\begin{code}
                    f :: a -> b,       x :: a
                    --------------------------
                            (f x) :: b
\end{code}

Сверху от черты, то что у нас есть, а снизу от черты то, что
мы можем получить. Это операция называется \emph{применением}
или аппликацией. 

Выражения, полученные таким образом, напоминают строчную запись дерева,
но есть одна тонкость, которую мы обошли стороной. В случае деревьев 
мы строили только константы, и конструктор получал столько аргументов,
сколько у него было дочерних узлов (или подтипов). Так мы строили константы. 
Но в Haskell мы можем с помощью применения строить функции на лету, 
передавая меньшее число аргументов, этот процесс называется
\emph{частичным применением} или каррированием (currying). 
Поясним на примере, предположим у нас есть функция двух аргументов:

\begin{code}
add :: Nat -> Nat -> Nat
add a b = ...
\end{code}

На самом деле компилятор воспринимает эту запись так:

\begin{code}
add :: Nat -> (Nat -> Nat)
add a b = ...
\end{code}

Функция \In{add} является функцией одного 
аргумента, которая в свою очередь возвращает функцию
одного аргумента \In{(Nat -> Nat)}. Когда мы пишем в 
где-нибудь в правой части функции:

\begin{code}
... =  ... (add Zero (Succ Zero)) ...
\end{code}

Компилятор воспринимает эту запись так:


\begin{code}
... =  ... ((add Zero) (Succ Zero)) ...
\end{code}

Присмотримся к этому выражению, что изменилось? У нас
появились новые скобки, вокруг выражения \In{(add Zero)}.
Давайте посмотрим как происходит применение:

\begin{code}
              add :: Nat -> (Nat -> Nat),       Zero :: Nat
              ----------------------------------------------
                        (add Zero) :: Nat -> Nat
\end{code}

Итак применение функции \In{add} к \In{Zero} возвращает
новую функцию \mbox{\In{(add Zero)}}, которая зависит от одного аргумента.
Теперь применим к этой функции второе значение:

\begin{code}
              (add Zero) :: Nat -> Nat,   (Succ Zero) :: Nat
              ----------------------------------------------
                     ((add Zero) (Succ Zero)) :: Nat
\end{code}

И только теперь мы получили константу. Обратите внимание
на то, что получившаяся константа не может принять ещё один аргумент.
Поскольку в правиле для применения функция \In{f} \emph{должна содержать
стрелку}, а у нас есть лишь \In{Nat}, это значение может участвовать
в других выражениях лишь на месте аргумента. 

Тоже самое работает и для функций от большего числа аргументов,
если мы пишем

\begin{code}
fun :: a1 -> a2 -> a3 -> a4 -> res

... = fun a b c d
\end{code}

На самом деле мы пишем
\begin{code}
fun :: a1 -> (a2 -> (a3 -> (a4 -> res)))

... = (((fun a) b) c) d
\end{code}

Это очень удобно. Так, определив лишь одну функцию \In{fun},
мы получили в подарок ещё три функции \In{(fun a)}, 
\In{(fun a b)} и \In{(fun a b c)}. С ростом числа аргументов растёт
и число подарков. Если смотреть
на функцию \In{fun}, как на функцию одного аргумента, то 
она представляется таким генератором функций типа \In{a2 -> a3 -> a4 -> res},
который зависит от параметра. Применение функций через пробел
значительно упрощает процесс комбинирования функций.

Поэтому в Haskell аргументы функций, которые играют роль 
параметров или специфических флагов, т.е.~аргументы, которые
меняются редко обычно пишутся в начале функции.  Например

\begin{code}
process :: Param1 -> Param2 -> Arg1 -> Arg2 -> Result
\end{code}

Два первых аргумента функции \In{process} выступают в роли параметров
для генерации функций с типом \In{Arg1 -> Arg2 -> Result}.

Давайте потренируемся с частичным применением в интерпретаторе.
Для этого загрузим модуль \In{Nat} из предыдущей главы:

\begin{code}
Prelude> :l Nat
[1 of 1] Compiling Nat              ( Nat.hs, interpreted )
Ok, modules loaded: Nat.
*Nat> let add = (+) :: Nat -> Nat -> Nat
*Nat> let addTwo = add (Succ (Succ Zero))
*Nat> :t addTwo
addTwo :: Nat -> Nat
*Nat> addTwo (Succ Zero)
Succ (Succ (Succ Zero))
*Nat> addTwo (addTwo Zero)
Succ (Succ (Succ (Succ Zero)))
\end{code}

Сначала мы ввели локальную переменную \In{add}, и
присвоили ей метод \In{(+)} из класса \In{Num} для \In{Nat}.
Нам пришлось выписать тип функции, поскольку \In{ghci} 
не знает для какого экземпляра мы хотим определить этот синоним.
В данном случае мы подсказали ему, что это \In{Nat}. 
Затем с помощью частичного применения мы объявили новый
синоним \In{addTwo}, как мы видим из следующей строки
это функция оного аргумента. Она принимает любое значение
типа \In{Nat} и прибавляет к нему двойку. Мы видим, что
этой функцией можно пользоваться также как и обычной функцией.

Попробуем выполнить тоже самое для функции с символьной записью имени:

\begin{code}
*Nat> let add2 = (+) (Succ (Succ Zero))
*Nat> add2 Zero
Succ (Succ Zero)
\end{code}

Мы рассмотрели частичное применение для функций 
в префиксной форме записи. В префиксной форме записи функция пишется первой,
затем следуют аргументы. Для функций в инфиксной форме записи
существует два правила применения. 

Это применение слева:

\begin{code}
                    (*) :: a -> (b -> c),   x :: a
                    -----------------------------
                            (x *) :: b -> c
\end{code}

И применение справа:

\begin{code}
                    (*) :: a -> (b -> c),   x :: b
                    -----------------------------
                            (* x) :: a -> c
\end{code}

Обратите внимание на типы аргумента и возвращаемого значения. 
Скобки в выражениях \In{(x*)} и \In{(*x)} обязательны. Применением
слева мы фиксируем в бинарной операции первый аргумент, а применением
справа -- второй.

Поясним на примере, для этого давайте возьмём функцию минус \In{(-)}.
Если мы напишем \In{(2-) 1} то мы получим \In{1}, а если мы напишем
\In{(-2) 1}, то мы получим \In{-1}. Проверим в интерпретаторе:

\begin{code}
*Nat> (2-) 1
1
*Nat> (-2) 1

<interactive>:4:2:
    No instance for (Num (a0 -> t0))
      arising from a use of syntactic negation
    Possible fix: add an instance declaration for (Num (a0 -> t0))
    In the expression: - 2
    In the expression: (- 2) 1
    In an equation for `it': it = (- 2) 1

\end{code}

Ох уж этот минус. Незадача. Ошибка произошла из-за того,
что минус является хамелеоном. Если мы пишем \In{-2}, компилятор
воспринимает минус как унарную операцию, и думает, что мы написали
константу минус два. Это сделано для удобства, но иногда это мешает.
Это единственное такое исключение в Haskell. Давайте введём новый
синоним для операции минус:

\begin{code}
*Nat> let (#) = (-)
*Nat> (2#) 1
1
*Nat> (#2) 1
-1
\end{code}


Эти правила левого и правого применения работают и для
буквенных имён в инфиксной форме записи:

\begin{code}
*Nat> let minus = (-)
*Nat> (2 `minus` ) 1
1
*Nat> ( `minus` 2) 1
-1
\end{code}

Так если мы хотим на лету получить новую функцию,
связав в функции второй аргумент мы можем написать:

\begin{code}
... = ... ( `fun` x) ...
\end{code}

Частичное применение для функций в инфиксной форме записи 
называют \emph{сечением} (section), они бывают соответственно
левыми и правыми.

\subsubsection{Связь с логикой}

Отметим связь основного правила применения с Modus Ponens,
известным правилом вывода в логике:

\begin{code}
                    a -> b,    a
                    -------------
                          b
\end{code}

Оно говорит о том, что если у нас есть выражение
из \In{a} следует \In{b} и мы знаем, что \In{a} истинно,
мы смело можем утверждать, что \In{b} тоже истинно.
Если перевести это правило на Haskell, то мы получим:
Если у нас определена функция типа \In{a -> b} и 
у нас есть значение типа \In{a}, то мы можем получить
значение типа \In{b}.

\subsection{Декомпозиция и сопоставление с образцом}

Декомпозиция применяется слева от знака равно, при этом
наша задача состоит в том, чтобы опознать дерево определённого
вида и выделить из него некоторые поддеревья. Мы уже пользовались
декомпозицией много раз в предыдущих главах, давайте выпишем 
примеры декомпозиции:

\begin{code}
not :: Bool -> Bool
not True   = ...
not False  = ...

xor :: Bool -> Bool -> Bool
xor a b = ...

show :: Show a => a -> String

show (Time h m s) = ...

addZero :: String -> String
addZero (a:[])  = ...
addZero as      = ...

(*)  a   Zero      = ...
(*)  a   (Succ b)  = ...
\end{code}

Декомпозицию можно проводить в аргументах функции. Там мы
видим строчную запись дерева, в узлах стоят конструкторы
(начинаются с большой буквы), переменные (с маленькой буквы)
или символ безразличной переменой (подчёркивание).

С помощью конструкторов, мы указываем те части, которые
обязательно должны быть в дереве для данного уравнения. Так уравнение

\begin{code}
not True   = ...
\end{code}

\noindent сработает, только если на вход функции
поступит значение \In{True}.
Мы можем углубляться в дерево значения настолько насколько 
нам позволят типы, так мы можем определить функцию:

\begin{code}
is7 :: Nat -> Bool
is7  (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))  = True
is7  _                                                      = False
\end{code}

С помощью переменных мы даём синонимы поддеревьям. Этими синонимами
мы можем пользоваться в правой части функции. Так в уравнении 

\begin{code}
addZero (a:[])
\end{code}

\noindent мы извлекаем первый элемент из списка, и одновременно говорим
о том, что список может содержать только один элемент. 
Отметим, что если мы хотим дать синоним всему дереву а не какой-то части,
мы просто пишем на месте аргумента переменную, как в случае функции
\In{xor}:

\begin{code}
xor a b = ...
\end{code}

    
С помощью  безразличной переменной говорим, что нам не важно, что 
находится у дерева в этом узле. Уравнения в определении синонима
обходятся сверху вниз, поэтому часто безразличной переменной
пользуются в смысле \Quote{а во всех остальных случаях}, как в:

\begin{code}
instance Eq Nat where
    (==) Zero     Zero     = True
    (==) (Succ a) (Succ b) = a == b
    (==) _        _        = False
\end{code}

Переменные и безразличные переменные также могут уходить
вглубь дерева сколь угодно далеко (или ввысь дерева, поскольку
первый уровень в строчной записи это корень):

\begin{code}
lessThan7 :: Nat -> Bool
lessThan7  (Succ (Succ (Succ (Succ (Succ (Succ (Succ _)))))))  = False
lessThan7  _                                                   = True
\end{code}

Декомпозицию можно применять
только к значениям константам. Проявляется интересная закономерность,
если для композиции необходимым элементом было значение со
стрелочным типом (функция), то в случае декомпозиции нам
нужно значение с типом без стрелок (константа). 
Это говорит о том, что все функции будут полностью применены,
т.е.~константы будут записаны в виде строчной записи дерева.
Если мы ожидаем на входе функцию, то мы можем только дать ей
синоним с помощью с помощью переменной или проигнорировать её безразличной
переменной.

Как в

\begin{code}
name  (Succ (Succ Zero))       = ...
name  (Zero : Succ Zero : [])  = ...
\end{code}

Но не

\begin{code}
name  Succ      = ...
name  (Zero :)  = ...
\end{code}

Отметим, что для композиции это допустимые значения, в первом случае
это функция \In{Nat -> Nat}, а во втором это функция типа
\mbox{\In{[Nat] -> [Nat]}}.


Ещё одна особенность декомпозиции заключается в том,
что при декомпозиции мы можем пользоваться только \Quote{настоящими}
значениями, т.е.~конструкторами, объявленными в типах. 
В случае композиции мы могли 
пользоваться как конструкторами, так и синонимами.

Например мы не можем написать в декомпозиции:

\begin{code}
name  (add Zero Zero)      = ...
name  (or (xor a b) True)  = ...
\end{code}

В Haskell декомпозицию принято называть \emph{сопоставлением
с образцом} (pattern matching). Термин намекает на то, что
в аргументе мы выписываем шаблон (или заготовку) для целого
набора значений. Наборы значений могут получиться, если мы пользуемся
переменными. Конструкторы дают нам возможность зафиксировать
вид ожидаемого на вход дерева.

\section{Проверка типов}

В этом разделе мы поговорим об ошибках проверки типов. 
Почти все ошибки, которые происходят в Haskell связаны с 
проверкой типов. Проверка типов происходит согласно правилам
применения, которые встретились нам в разделе о композиции 
значений. 
Мы остановимся лишь на случае для префиксной формы записи, 
правила для сечений работают аналогично. 
Давайте вспомним основное правило:

\begin{code}
                    f :: a -> b,       x :: a
                    --------------------------
                            (f x) :: b
\end{code}

Что может привести к ошибке? В этом правиле есть
два источника ошибки. 

\begin{itemize}
\item Тип \In{f} не содержит стрелок, или \In{f} не является функцией. 
\item Типы \In{x} и аргумента для \In{f} не совпадают.
\end{itemize}

Вот и все ошибки. Универсальное представление всех функций 
в виде функций одного аргумента, значительно сокращает число
различных видов ошибок. Итак мы можем ошибиться применяя
значение к константе и передав в функцию не то, что она
ожидает.

Потренируемся в интерпретаторе, сначала попытаемся
создать ошибку первого типа:

\begin{code}
*Nat> Zero Zero

<interactive>:1:1:

\Fig{Синоним-константа}{../pic/3/vis2.ps}{Vis2}{0.3}
    The function `Zero' is applied to one argument,
    but its type `Nat' has none
    In the expression: Zero Zero
    In an equation for `it': it = Zero Zero
\end{code}

Если перевести на русский интерпретатор говорит: 

\begin{code}
*Nat> Zero Zero

<interactive>:1:1:
    Функция 'Zero' применяется к одному аргументу,
    но её тип 'Nat' не имеет аргументов
    В выражении: Zero Zero
    В уравнении для `it': it = Zero Zero
\end{code}

Компилятор увидел применение функции \In{f x}, далее он 
посмотрел, что \In{x = Zero}, из этого на основе правила применения
он сделал вывод о том, что \In{f} имеет тип \In{Nat -> t},
тогда он заглянул в \In{f} и нашёл там \In{Zero :: Nat}, что
и привело к несовпадению типов. 

Составим ещё одно выражение с такой же ошибкой:

\begin{code}
*Nat> True Succ

<interactive>:6:1:
    The function `True' is applied to one argument,
    but its type `Bool' has none
    In the expression: True Succ
    In an equation for `it': it = True Succ
\end{code}

В этом выражении аргумент \In{Succ} имеет тип \In{Nat -> Nat},
значит по правилу вывода тип \In{True} равен \In{(Nat -> Nat) -> t},
где \In{t} некоторый произвольный тип, но мы знаем, что
\In{True} имеет тип \In{Bool}. 

Теперь перейдём к ошибкам второго типа. Попробуем вызывать
функции с неправильными аргументами:

\begin{code}
*Nat> :m +Prelude
*Nat Prelude> not (Succ Zero)

<interactive>:9:6:
    Couldn't match expected type `Bool' with actual type `Nat'
    In the return type of a call of `Succ'
    In the first argument of `not', namely `(Succ Zero)'
    In the expression: not (Succ Zero)
\end{code}

Опишем действия компилятора в терминах правила применения.
В этом выражении у нас есть три значения \In{not}, \In{Succ} и
\In{Zero}. Нам нужно узнать тип выражения и проверить правильно
ли оно построено.  

\begin{code}
not (Succ Zero) - ? 

     not :: Bool -> Bool,    Succ :: Nat -> Nat,    Zero :: Nat
     ----------------------------------------------------------
            f x, f = not и x = (Succ Zero)
    ------------------------------------------------------------
            f :: Bool -> Bool следовательно x :: Bool
    -------------------------------------------------------------
            (Succ Zero) :: Bool
\end{code}

Воспользовавшись правилом применения мы узнали, что тип
выражения \In{Succ Zero} должен быть равен \In{Bool}, 
проверим так ли это?

\begin{code}
(Succ Zero) - ?
        Succ :: Nat -> Nat,     Zero :: Nat
     ----------------------------------------------------------
            f x, f = Succ, x = Zero следовательно (f x) :: Nat
     ----------------------------------------------------------
                        (Succ Zero) :: Nat
\end{code}

Из этой цепочки следует, что \In{(Succ Zero)} имеет тип \In{Nat},
мы пришли к противоречию и сообщаем об этом пользователю.

\begin{code}
<interactive>:1:5:
    Не могу сопоставить ожидаемый тип 'Bool' с выведенным 'Nat'
    В типе результата вызова `Succ'
	В первом аргументе `not', а именно `(Succ Zero)'
    В выражении: not (Succ Zero)	
\end{code}

Потренируйтесь в составлении неправильных выражений,
и посмотрите почему они не правильные. Мысленно сверьтесь с
правилом применения в каждом из слагаемых.

\subsubsection{Специализация типов при подстановке}

Мы говорили о том, что тип аргумента функции и тип подставляемого
значения должны совпадать, но на самом деле есть и другая
возможность. Тип аргумента или тип значения могут быть 
полиморфными в этом случае происходит специализация 
общего типа. Например при выполнении выражения

\begin{code}
*Nat> Succ Zero + Zero
Succ (Succ Zero)
\end{code}

Происходит специализация общей функции \In{(+) :: Num a => a -> a -> a}
до функции \In{(+) :: Nat -> Nat -> Nat}, которая определена 
в экземпляре \In{Num} для \In{Nat}.

\subsection{Проверка типов с контекстом}

Предположим, что у функции \In{f} есть контекст, который
говорит о том, что первый аргумент принадлежит некоторому
классу \In{f :: C a => a -> b},  тогда значение, которое
мы подставляем в функцию должно быть экземпляром класса \In{C}.

Для иллюстрации давайте попробуем сложить логические значения:

\begin{code}
*Nat Prelude> True + False

<interactive>:11:6:
    No instance for (Num Bool)
      arising from a use of `+'
    Possible fix: add an instance declaration for (Num Bool)
    In the expression: True + False
    In an equation for `it': it = True + False
\end{code}

Компилятор говорит о том, что для типа \In{Bool} не  
определён экземпляр для класса \In{Num}

\begin{code}
No instance for (Num Bool) 
\end{code}

Запишем это в виде правила:

\begin{code}
                    f :: C a => a -> b,  x :: T, instance C T 
                    -----------------------------------------
                                (f x) :: b
\end{code}

Важно отметить, что \In{x} имеет конкретный тип \In{T}, 
если \In{x} -- значение, у которого тип с параметром, компилятор не сможет
определить для какого типа конкретно мы хотим выполнить применение. 
Мы будем называть такую ситуацию неопределённостью:

\begin{code}
x :: T a => a
f :: C a => a -> b

f x :: ??  -- неопределённость
\end{code}

Мы видим, что тип \In{x}, это какой-то тип, одновременно принадлежащий
и классу \In{T} и классу \In{C}. Но мы не можем сказать какой это
тип. У этого поведения есть исключение, по умолчанию 
числа приводятся к \In{Integer}, если они не содержат знаков после точки,
и к \In{Double} если содержат.

\begin{code}
*Nat Prelude> let f = (1.5 + )
*Nat Prelude> :t f
f :: Double -> Double
*Nat Prelude> let x = 5 + 0
*Nat Prelude> :t x
x :: Integer
*Nat Prelude> let x = 5 + Zero
*Nat Prelude> :t x
x :: Nat
\end{code}

Умолчания определены только для класса \In{Num}. Для этого
есть специальное ключевое слово \In{default}. 
В рамках модуля мы можем указать какие типы считаются
числами по умолчанию. Например так (такое умолчание действует
в каждом модуле, но мы можем переопределить его):

\begin{code}
default (Integer, Double)
\end{code}

Работает правило: если произошла неопределённость и один 
из участвующих классом является \In{Num}, а все остальные
классы~-- это стандартные классы, определённые в \In{Prelude},
компилятор начинает последовательно подставлять в неопределённый
тип все типы из тех, что перечислены за ключевым словом \In{default},
пока один из них не подойдёт. Если такого типа не окажется, 
компилятор скажет об ошибке. 

\subsection{Ограничение мономорфизма}

С выводом типов в классах связана одна тонкость. 
Мы говорили, что не обязательно выписывать типы выражений,
компилятор может вывести их самостоятельно, например, 
мы постоянно пользуемся этим в интерпретаторе.
Также когда мы говорили о частичном применении,
мы сказали об очень полезном умолчании в типах функций.
О том, что за счёт частичного применения все функции 
являются функциями одного аргумента. Эта особенность
позволяет записывать выражения очень кратко. Но иногда
они получаются чересчур краткими, и вводят компилятор
в заблуждение, зайдём в интерпретатор:

\begin{code}
Prelude> let add = (+)
Prelude> :t add
add :: Integer -> Integer -> Integer
\end{code}

Мы хотели определить синоним для метода плюс из класса \In{Num},
но вместо ожидаемого общего типа получили более частный. 
Сработало умолчание для численного типа. Но зачем оно сработало?
Если мы попробуем дать синоним методу из класса \In{Eq},
ситуация станет ещё более странной:

\begin{code}
Prelude> let eq = (==)
Prelude> :t eq
eq :: () -> () -> Bool
\end{code}

Мы получили какую-то ерунду. Если мы попытаемся загрузить 
модуль с этими определениями:

\begin{code}
module MR where

add = (+)
eq  = (==)
\end{code}

\noindent то получим:

\begin{code}
*MR> :l MR
[1 of 1] Compiling MR               ( MR.hs, interpreted )

MR.hs:4:7:
    Ambiguous type variable `a0' in the constraint:
      (Eq a0) arising from a use of `=='
    Possible cause: the monomorphism restriction applied to the following:
      eq :: a0 -> a0 -> Bool (bound at MR.hs:4:1)
    Probable fix: give these definition(s) an explicit type signature
                  or use -XNoMonomorphismRestriction
    In the expression: (==)
    In an equation for `eq': eq = (==)
Failed, modules loaded: none.
\end{code}

Компилятор жалуется о том, что в определении для \In{eq}
ему встретилась неопределённость и он не смог вывести тип. 
Если же мы допишем недостающие типы:

\begin{code}
module MR where

add :: Num a => a -> a -> a
add = (+)

eq :: Eq a => a -> a -> Bool
eq  = (==)
\end{code}

то всё пройдёт гладко:

\begin{code}
Prelude> :l MR
[1 of 1] Compiling MR               ( MR.hs, interpreted )
Ok, modules loaded: MR.
*MR> eq 2 3
False
\end{code}

Но оказывается, что если мы допишем аргументы у функций
и сотрём объявления, компилятор сможет вывести тип и
тип окажется общим. Это можно проверить в интерпретаторе,
для этого начнём новую сессию интерпретатора:

\begin{code}
Prelude> let eq a b = (==) a b 
Prelude> :t eq
eq :: Eq a => a -> a -> Bool
Prelude> let add a = (+) a
Prelude> :t add
add :: Num a => a -> a -> a
\end{code}

Запишите эти выражения в модуле без типов и попробуйте
загрузить. Почему так происходит? По смыслу определения

\begin{code}
add a b = (+) a b
add     = (+)
\end{code}

\noindent ничем не отличаются друг от друга, но второе
сбивает компилятор столку. Компилятор путается из-за
того, что второй вариант похож на определение константы.
Мы с вами знаем, что выражение справа от знака равно является
функцией, но компилятор, посчитав аргументы слева от знака
равно, думает, что это возможно константа, потому что она
выглядит как константа. У таких возможно-констант
есть специальное имя, они называются константными аппликативными
формами (constant applicative form или сокращённо CAF). 
Константы можно вычислять один раз, на то они и константы. 
Но если тип константы перегружен и мы не знаем что 
это за тип (если пользователь не подсказал нам об этом в 
объявлении типа), то нам приходится вычислять его 
каждый раз заново, посмотрим на пример:

\begin{code}
res = s + s

s = someLongLongComputation 10

someLongLongComputation :: Num a => a -> a
\end{code}

Здесь значение \In{s} содержит результат вычисления
какой-то большой-пребольшой функции. Перед компилятором 
стоит задача вывода типов. По тексту можно определить,
что у \In{s} и \In{res} некоторый числовой тип. 
Проблема в том, что поскольку компилятор не знает какой тип
у \In{s} конкретно в выражении \In{s + s} он вынужден
вычислить \In{s} дважды. Это привело разработчиков 
Haskell к мысли о том, что все выражения, которые
выглядят как константы должны вычисляться как константы,
то есть лишь один раз. 
Это ограничения называют ограничением \emph{мономорфизма}.
По умолчанию все константы должны иметь конкретный тип, если 
только пользователь не укажет обратное в типе
или не подскажет компилятору косвенно, подставив
неопределённое значение в другое значение, тип которого
определён, например такой модуль загрузится без ошибок:

\begin{code}
eqToOne = eq one

eq = (==)

one :: Int
one = 1
\end{code}

Только в этом случае мы не получим общего типа для 
\In{eq}, компилятор постарается вывести значение,
которое не содержит контекста. Поэтому получится, что
функция  \In{eq} определена на \In{Int}.
Эта очень спорная особенность языка, поскольку
на практике получается так, что ситуации в которых
она мешает возникают гораздо чаще. Немного забегая вперёд, отметим, что
это поведение компилятора по умолчанию и его можно
изменить, компилятор даже подсказал нам как это сделать
в сообщении об ошибке:

\begin{code}
    Probable fix: give these definition(s) an explicit type signature
                  or use -XNoMonomorphismRestriction
\end{code}

Мы можем активировать расширение языка, которое отменяет
это ограничение. Сделать это можно несколькими способами.
Мы можем запустить интерпретатор с флагом \In{-XNoMonomorphismRestriction}:

\begin{code}
Prelude> :q
Leaving GHCi.
$ ghci -XNoMonomorphismRestriction
Prelude> let eq = (==)
Prelude> :t eq
eq :: Eq a => a -> a -> Bool
\end{code}

\noindent или в самом начале модуля написать:

\begin{code}
{-# Language NoMonomorphismRestriction #-}
\end{code}

Расширение будет действовать только в рамках данного модуля.


\section{Рекурсивные типы}

Обсудим ещё одну особенность системы типов \In{Haskell}. 
Типы могут быть рекурсивными,
то есть одним из подтипов в определении типа может быть
сам определяемый тип. Мы уже пользовались этим в определении
для \In{Nat}

\begin{code}
data Nat = Zero | Succ Nat
\end{code}

Видите во второй альтернативе участвует сам тип \In{Nat}.
Это приводит к бесконечному числу значений. Таким
простым и коротким определением мы описываем все
положительные числа. Рекурсивные определения типов приводят
к рекурсивным функциям. Помните мы определял сложение 
и умножение:

\begin{code}
(+) a Zero     = a
(+) a (Succ b) = Succ (a + b)

(*) a Zero     = Zero
(*) a (Succ b) = a + (a * b)   
\end{code}

И та и другая функция получились рекурсивными.
Они следуют по одному сценарию: сначала определяем базу
рекурсии~-- тот случай, в котором мы заканчиваем 
вычисление функции, и затем определяем путь к базе~--
цепочку рекурсивных вызовов. 

Рассмотрим тип по-сложнее. Списки:

\begin{code}
data [a] = [] | a : [a]
\end{code}

Деревья значений для \In{Nat} напоминают цепочку 
конструкторов \In{Succ}, которая венчается конструктором
\In{Zero}. Дерево значений для списка отличается лишь тем,
что теперь у каждого конструктора \In{Succ} есть отросток,
который содержит значение неокоторого типа \In{a}. Значение 
заканчивается пустым списком \In{[]}.

Мы можем предположить, что функции для списков также будут
рекурсивными. Это и правда так. Помотрим на
три основные функции для списков, все они определены в 
\In{Prelude}. Начнём с функции преобразования всех элементов списка:

\begin{code}
map :: (a -> b) -> [a] -> [b]
\end{code}

Посмотрим как она работает:

\begin{code}
Prelude> map (+100) [1,2,3]
[101,102,103]
Prelude> map not [True, True, False, False, False]
[False,False,True,True,True]
Prelude> :m +Data.Char
Prelude Data.Char> map toUpper "Hello World"
"HELLO WORLD"
\end{code}

Теперь опишем эту функцию.
Базой рекурсии будет случай для пустого списка.
В нём мы говорим, что если элементы закончились, нам нечего
больше преобразовывать, и возвращаем пустой список. 
Во втором уравнении нам встретится узел дерева,
который содержит конструктор \In{:}, а в дочерних узлах
сидят элемент списка \In{a} и оставшаяся часть списка \In{as}. 
 В этом случае 
мы составляем новый список, элемент которого содержит
преобразованный элемент \In{(f a)} исходного списка
и оставшуюся часть списка, которую мы также
преобразуем с помощью функции \In{map}:

\begin{code}
map :: (a -> b) -> [a] -> [b]
map f []     = []
map f (a:as) = f a : map f as
\end{code}

Какое длинное объяснение для такой короткой функции! Надеюсь, что
мне не удалось сбить вас с толку. Обратите внимание на то, 
что поскольку конструктор символьный (начинается с двоеточия) 
мы пишем его между дочерними поддеревьями, а не сначала.
Немного отвлекитесь
и поэкспериментируйте с этой функцией в интерпретаторе,
она очень важная. Составляйте самые разные списки.
Чтобы не перенабирать каждый раз списки водите
синонимы с помощью \In{let}.

Перейдём к следующей функции. Это функция фильтрации:

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
\end{code}

Она принимает предикат и список, угдайте что она делает:

\begin{code}
Prelude Data.Char> filter isUpper "Hello World"
"HW"
Prelude Data.Char> filter even [1,2,3,4,5]
[2,4]
Prelude Data.Char> filter (>10) [1,2,3,4,5]
[]
\end{code}

Да, она оставляет лишь те элементы, на которых
предикат вернёт истину. Потренируйтесь и с этой функцией.
Теперь определение.

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter p []     = []
filter p (x:xs) = if p x then x : filter p xs else filter p xs
\end{code}

Попробуйте разобраться с ним самостоятельно по аналогии
с \In{map}. Оно может показаться немного громоздким,
но это ничего, совсем скоро мы узнаем как записать
его гораздо проще. 

Рассмотрим ещё одну функцию для списков, она называется функцией свёртки:

\begin{code}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z []     = z
foldr f z (a:as) = f a (foldr f z as)
\end{code}

Визуально её действие можно представить как замену 
всех конструкторов в дереве значения на подходящие
по типу функции. В этой маленькой функции кроется 
невероятная сила. Посмотрим на несколько примеров:

\begin{code}
Prelude Data.Char> :m -Data.Char
Prelude> let xs = [1,2,3,4,5]
Prelude> foldr (:) [] xs
[1,2,3,4,5]
\end{code}

Мы заменили конструкторы на самих себя и получили 
исходный список, теперь давайте сделаем что-нибудь
более конструктивное. Например вычислим сумму
всех элементов или произведение:

\begin{code}
Prelude> foldr (+) 0 xs
15
Prelude> foldr (*) 1 xs
120
Prelude> foldr max (head xs) xs
5
\end{code}

\section{Краткое содержание}

В этой главе мы присмотрелись к типам и узнали
как ограничения общие для всех типов сказываются на 
структуре значений. Мы узнали, что константы в Haskell 
очень похожи на деревья, а запись 
констант на строчную запись дерева. Также мы присмотрелись
к функциям. И узнали, что операция определения синонима 
распадается на две -- это композиция и декомпозиция значений.

\begin{code}
name   декомпозиция   =   композиция
\end{code}


Существует несколько правил для построения композиций:

\begin{itemize}

\item Одно для функций в префиксной форме записи:

\begin{code}
                    f :: a -> b,           x :: a 
                    -------------------------------
                              (f x) :: b
\end{code}

\item И два для функций в инфиксной форме записи:

Это левое сечение:

\begin{code}
                    (*) :: a -> (b -> c),     x :: a 
                    ---------------------------------
                             (x *) :: b -> c
\end{code}

И правое сечение:

\begin{code}
                    (*) :: a -> (b -> c),     x :: b 
                    ---------------------------------
                                (* x) :: a -> c
\end{code}

\end{itemize}


Декомпозиция происходит в аргументах функции. 
С её помощью мы можем извлечь из составной константы-дерева
какую-нибудь часть. Или указать на какие константы мы реагируем 
в данном уравнении. 

Ещё мы узнали о \emph{частичном применении}. О том, что все
функции в Haskell являются функциями одного аргумента,
которые возвращают константы или другие функции одного аргумента. 

Мы потренировались в составлении неправильных выражений
и посмотрели как компилятор на основе правил применения 
узнаёт, что они неправильные. Мы узнали, что такое
ограничение мономорфизма и как оно появляется.
Также мы присмотрелись к рекурсивным функциям. 

\Fig{Конструкторы и синонимы}{../pic/3/vis1.ps}{Vis1}{0.25}

\section{Упражнения}

\begin{itemize}

\item Составьте в интерпретаторе как можно больше
    неправильных выражений и посмотрите, на сообщения об ошибках.
    Разберитесь почему выражение оказалось неправильным.
    Для этого проверьте типы с помощью правил применения.
    Составьте несколько выражений, ведущих к ошибке
    из-за ограничения мономорфизма.


\Fig{Синоним-константа}{../pic/3/vis2.ps}{Vis2}{0.3}

\Fig{Функция извлечения первого элемента списка}{../pic/3/vis3.ps}{Vis3}{0.35}
\Fig{Функция преобразования элементов списка}{../pic/3/vis4.ps}{Vis4}{0.7}

\item В этой главе было много картинок и графических аналогий, 
попробуйте попрограммировать в картинках. Нарисуйте 
определённые нами функции или какие-нибудь новые в
виде деревьев. Например это можно сделать так.
Мы будем отличать конструкторы от синонимов. Конструкторы
будем рисовать в ординарном кружке, а синонимы в двойном:

Мы будем все функции писать также как и прежде, но 
вместо аргументов слева от знака равно и выражений
справа от знака равно будем рисовать деревья. 

Например объявим простой синоним-константу (\RefFig{Vis2}).
Мы будем дорисовывать сверху типы значений, вместо объявления типа
функции.


Несколько функций для списков. Извлечение первого элемента 
(\RefFig{Vis3}) и функция преобразования всех элементов списка 
(\RefFig{Vis4}).
Попробуйте в таком же духе определить несколько функций.

\end{itemize}


