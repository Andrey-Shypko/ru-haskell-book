\setcounter{chapter}{7}
\chapter{Редукция выражений}

В этой главе мы поговорим о том как вычисляются программы. 
В самом начале мы говорили о том, что 
процесса вычисления значений нет. В том смысле, что у нас
нет новых значений, у нас ничего не меняется, мы лишь
расшифровываем синонимы значений. Но даже этот процесс
должен как-то происходить внутри компьютера. 

Вкратце вспомним то, что мы уже знаем о вычислениях.
Сначала мы с помощью типов определяем
множество всех возможных значений. Значения -- это деревья
в узлах которых записаны конструкторы, которые мы 
определяем в типах. Так например мы можем определить тип:

\begin{code}
data Nat = Zero | Succ Nat
\end{code}

Этим типом мы определяем множество допустимых значений. 
В данном случае это цепочки конструкторов \In{Succ},
которые заканчиваются конструктором \In{Zero}:

\begin{code}
Zero, Succ Zero, Succ (Succ Zero), ...
\end{code}
    
Затем начинаем давать им
новые имена, создавая константы (простые имена-синонимы) 
  
\begin{code}
zero    = Zero
one     = Succ zero
two     = Succ one
\end{code}


\noindent и функции (составные имена-синонимы):

\begin{code}
foldNat :: a -> (a -> a) -> Nat -> a
foldNat z  s  Zero      = z
foldNat z  s  (Succ n)  = s (foldNat z s n)

add a = foldNat a   Succ
mul a = foldNat one (add a) 
\end{code}

Затем мы передаём нашу программу на проверку компилятору. 
Мы просим у него проверить не создаём ли мы случайно 
какие-нибудь бессмысленные
выражения. Бессмысленные потому, что они пытаются 
создать значение, которое не вписывается в наши типы.
Например если мы где-нибудь попробуем составить выражение:

\begin{code}
add Zero mul
\end{code}

Компилятор напомнит нам о том, что мы пытаемся подставить
функцию \In{mul} на место обычного значения типа \In{Nat}.
Тогда мы исправим выражение на:

\begin{code}
add Zero two
\end{code}

Компилятор согласится. И передаст выражение вычислителю. 
И тут мы говорили, что вычислитель начинает проводить
расшифровку нашего описания. Он подставляет на место 
синонимов их определения, правые части из уравнений. Этот
процесс мы называли \emph{редукцией}. 
Вычислитель видит два синонима и одно значение. С какого синонима начать? 
С \In{add} или \In{two}?

\section{Стратегии вычислений}

Этот вопрос приводит нас к понятию стратегии вычислений.
Поскольку вычисляем мы только константы, то наше выражение
также можно представить в виде дерева. Только теперь у нас 
в узлах записаны не только конструкторы, но и синонимы.
Процесс редукции можно представить как процесс очистки такого
дерева от синонимов. Посмотрим на дерево нашего значения:

Оказывается у нас есть две возможности очистки синонимов.

\EmphDesc{Cнизу-вверх}{%
    \Strategy{вычисление по значению}
    начинаем с листьев и убираем все синонимы в листьях дерева 
    выражения. Как только в данном узле и всех дочерних узлах 
    остались одни конструкторы можно переходить на уровень выше. 
    Так мы поднимаемся выше и выше пока не дойдём до корня. 
}

\EmphDesc{Cверху-вниз}{%
    \Strategy{вычисление по имени}
    начинаем с корня, самого внешнего синонима и
    заменяем его на определение (с помощью уравнения на правую часть 
    от знака равно), если на верху снова окажется синоним, мы опять 
    заменим его на определение и так пока на верху не появится 
    конструктор, тогда мы спустимся в дочерние деревья и будем
    повторять эту процедуру пока не дойдём до листьев дерева.
}

\smallskip

Посмотрим как каждая из стратегий будет редуцировать
наше выражение. Начнём со стратегии от листьев к корню (снизу-вверх):

\begin{code}
        add Zero two                    
-- видим два синонима add и two 
-- раскрываем two, ведь он находится ниже всех синонимов
=>      add Zero (Succ one)    
-- ниже появился ещё один синоним, раскроем и его
=>      add Zero (Succ (Succ zero))    
-- появился синоним zero раскроем его
=>      add Zero (Succ (Suсс Zero))
-- все узлы ниже содержат конструкторы, поднимаемся вверх до синонима
-- заменяем add на его правую часть
=>      foldNat Succ Zero (Succ (Succ Zero))  
-- самый нижний синоним foldNat, раскроем его
-- сопоставление с образцом проходит во втором уравнении для foldNat
=>      Succ (foldNat Succ Zero (Succ Zero))
-- снова раскрываем foldNat
=>      Succ (Succ (foldNat Zero Zero))
-- снова раскрываем foldNat, но на этот раз нам подходит
-- первое уравнение из определения foldNat
=>      Succ (Succ Zero)
-- синонимов больше нет можно вернуть значение
-- результат:
        Succ (Succ Zero)
\end{code}

В этой стратегии для каждой функции мы сначала вычисляем до конца
все аргументы, потом подставляем расшифрованные значения в
определение функции.

Теперь посмотрим на вычисление от корня к листьям (сверху-вниз):
    
\begin{code}
        add Zero two
-- видим два синонима add и two, начинаем с того, что ближе всех к корню
=>      foldNat Succ Zero two
-- теперь выше всех foldNat, раскроем его
\end{code}
    
Но для того чтобы раскрыть \In{foldNat} нам нужно узнать
какое уравнение выбрать для этого нам нужно понять какой
конструктор находится в корне у второго аргумента, если
это \In{Zero}, то мы выберем первое уравнение, а если это
\In{Succ}, то второе:

\begin{code}
-- в уравнении для foldNat видим декомпозицию по второму 
-- аргументу. Узнаем какой конструктор в корне у two
=>      foldNat Succ Zero (Succ one)
-- Это Succ нам нужно второе уравнение:
=>      Succ (foldNat Succ Zero one)
-- В корне м ыполучили конструктор, можем спуститься ниже.
-- Там мы видим foldNat, для того чтобы раскрыть его нам
-- снова нужно понять какой конструктор в корне у второго аргумента:
=>      Succ (foldNat Succ Zero (Succ zero))
-- Это опять Succ переходим ко второму уравнению для foldNat
=>      Succ (Succ (foldNat Succ Zero zero))
-- Снова раскрываем второй аргумент у foldNat
=>      Succ (Succ (foldNat Succ Zero Zero))
-- Ага это Zero, выбираем первое уравнение
=>      Succ (Succ Zero)
-- Синонимов больше нет можно вернуть значение
-- результат:
        Succ (Succ Zero)
\end{code}
   
В этой стратегии мы всегда раскрываем самый верхний уровень
выражения, можно представить как мы вытягиваем конструкторы
от корня по цепочке. У этих стратегий есть специальные имена:

\begin{itemize}
\item вычисление \emph{по значению} (call by value), когда 
    мы идём от листьев к корню.

\item вычисление \emph{по имени} (call by need), когда
    мы идём от корня к листьям.
\end{itemize}

Отметим, что стратегию вычисления по значению также принято
называть \emph{энергичными вычислениями} (eqger evaluation)
или \emph{аппликативной} (applicative) стратегией редукции. 
Вычисление по имени также принято называть
\emph{нормальной} (normal) стратегией редукции.

\subsection{Преимущества и недостатки стратегий}

В чём преимущества, той и другой стратегии. 

\begin{quote}
Если выражение вычисляется полностью, первая стратегия
более эффективна по расходу памяти.
\end{quote}

\emph{Вычисляется полностью} означает все компоненты
выражения участвуют в вычислении. Например то выражении,
которое мы рассмотрели так подробно, вычисляется полностью.
Приведём пример выражения, при вычислении которого нужна лишь
часть аргументов, для этого определим функцию: 

\begin{code}
isZero :: Nat -> Bool
isZero Zero     = True
isZero _        = False
\end{code}

Она проверяет является ли нулём данное число, теперь представим
как будет вычисляться выражение, в той и другой стратегии:

\begin{code}
isZero (add Zero two)
\end{code}

Первая стратегия сначала вычислит все аргументы у \In{add}
потом расшифрует \In{add} и только в самом конце доберётся 
до \In{isZero}. На это уйдёт восемь шагов (семь 
на вычисление \In{add Zero two}).
В то время как вторая стратегия начнёт с \In{isZero}. 
Для вычисления \In{isZero} ей потребуется узнать какой конструктор в корне у
выражения \In{add Zero two}. Она узнает это за два шага. 
Итого три шага. Налицо экономия усилий. 

Почему вторая стратегия экономит память? Поскольку мы всегда
вычисляем аргументы функции, мы можем не хранить описания
в памяти а сразу при подстановке в функцию начинать редукцию.
Эту ситуацию можно понять на таком примере, посчитаем сумму чисел
от одного до четырёх с помощью такой функции:

\begin{code}
sum :: Int -> [Int] -> Int
sum []      res = res
sum (x:xs)  res = sum xs (res + x) 
\end{code}

Посмотрим на то как вычисляет первая стратегия, с учётом
того что мы вычисляем значения при подстановке:

\begin{code}
        sum [1,2,3,4] 0
=>      sum [2,3,4]   (0 + 1)    
=>      sum [2,3,4]   1
=>      sum [3,4]     (1 + 2)
=>      sum [3,4]     3
=>      sum [4]       (3+3)
=>      sum [4]       6
=>      sum []        (6+4)
=>      sum []        10
=>      10
\end{code}

Теперь посмотрим на вторую стратегию:

\begin{code}
        sum [1,2,3,4] 0
=>      sum [2,3,4]   0+1
=>      sum [3,4]     (0+1)+2
=>      sum [4]       ((0+1)+2)+3
=>      sum []        (((0+1)+2)+3)+4
=>      (((0+1)+2)+3)+4
=>      ((1+2)+3)+4
=>      (3+3)+4
=>      6+4
=>      10
\end{code}

А теперь представьте, что мы решили посчитать сумму чисел
от 1 до миллиона. Сколько вычислений нам придётся накопить!
В этом недостаток второй стратегии. 
Но есть и ещё один недостаток, рассмотрим выражение:

\begin{code}
(\x -> add (add x x) x) (add Zero two)
\end{code}

Первая стратегия сначала редуцирует выражение \In{add Zero two}
в то время как вторая подставит это выражение в функцию
и утроит свою работу!

Но у второй стратегии есть одно очень веское преимущество,
она может вычислять больше выражений чем вторая. Определим 
значение бесконечность:

\begin{code}
infinity    :: Nat
infinity    = Succ infinity
\end{code}

Это рекурсивное определение, если мы попытаемся его распечатать
мы получим бесконечную последовательность \In{Succ}. Чем не 
бесконечность? Теперь посмотрим на выражение:

\begin{code}
isZero infinity
\end{code}

Первая стратегия захлебнётся, вычисляя аргумент функции \In{isZero},
в то время как вторая найдёт решение за два шага. 

Подведём итоги. Плюсы вычисления по значению:

\begin{itemize}
\item Эффективный расход памяти в том случае если все 
        составляющие выражения участвуют в вычислении.

\item Она не может дублировать вычисления, как стратегия
        вычисления по имени.
\end{itemize}

Плюсы вычисления по имени:

\begin{itemize}
\item Меньше вычислений в том случае, если при вычислении выражения
    участвует лишь часть составляющих.

\item Большая выразительность. Мы можем вычислить больше значений.
\end{itemize}

Какую из них выбрать? В Haskell пошли по второму пути. Всё-таки
преимущество выразительности языка оказалось самым существенным.
Но для того чтобы избежать недостатков стратегии вычисления по имени
оно было модифицировано. Давайте посмотрим как.

\subsection{Вычисление по необходимости}

\Strategy{вычисление по необходимости}
\Strategy{ленивые вычисления}
Вернёмся к выражению: 

\begin{code}
(\x -> add (add x x) x) (add Zero two)
\end{code}

Нам нужно как-то рассказать функции о том, что имя \In{x}
в её теле указывает на одно и то же значение. И если
в одном из \In{x} значение будет вычислено переиспользовать
эти результаты в других \In{x}. Вместо значения мы будем
передовать в функцию \emph{ссылку} на область памяти,
которая содержит рецепт получения этого значения. 
Напомню, что мы по-прежнему вычисляем значение сверху вниз,
сейчас мы просто хотим избавиться от проблемы дублирования.
Вернитесь к примеру с вычислением по имени и просмотрите его
ещё раз. Обратите внимание на то, что значения вычислялись
лишь при сопоставлении с образцом. 
Мы вычисляем верхний конструктор аргумента лишь для того,
чтобы понять какое уравнение для \In{foldNat} выбрать. 
Теперь мы будем хранить ссылку на \In{(add Zero two)}
в памяти и как только, внешняя функция запросит
верхний конструктор мы обновим значение в памяти новым
вычисленным до корневого конструктора значением.
Если в любом другом месте функции мы вновь обратимся 
к значению, мы не будем его перевычислять, а сразу 
вернём конструктор. Посмотрим как это происходит на примере:

\begin{code}
--  выражение                               | память:
--------------------------------------------|-------------------------
    (\x -> add (add x x) x) M               | M = (add Zero two)
-- подставим ссылку в тело функции          |
=>  add (add M M) M                         |
-- раскроем самый верхний синоним           |
=>  foldNat (add M M) Succ M                |
-- для foldNat узнаем верхний конструктор   |
-- последнего аргумента (пропуская          |
-- промежуточные шаги, такие же как выше)   |
=>                                          | M  = Succ M1
                                            | M1 = foldNat Succ Zero one
-- по M выбираем второе уравнение           |
=> Succ (foldNat (add M M) Succ M1)         |
-- запросим следующий верхний конструктор:  |
=>                                          | M  = Succ M1
                                            | M1 = Succ M2
                                            | M2 = foldNat Succ Zero zero
-- по M1 выбираем второе уравнение          |
=> Succ (Succ (foldNat (add M M) Succ M2))  | 
-- теперь для определения уравнения foldNat |
-- раскроем M2                              |
=>                                          | M  = Succ M1
                                            | M1 = Succ M2
                                            | M2 = Zero
-- выбираем первое уравнение для foldNat:   |
=> Succ (Succ (add M M))                    |
-- раскрываем самый верхний синоним:        |
=> Succ (Succ (foldNat M Succ M))           |
-- теперь, поскольку M уже вычислялось, в   |
-- памяти уже записан верхний конструктор,  |
-- мы знаем, что это Succ и выбираем второе |
-- уравнение:                               |
=> Succ (Succ (Succ (foldNat M Succ M1)))   |
-- и M1 тоже уже вычислялось, сразу         |
-- выбираем второе уравнение                |----+
=> Succ (Succ (Succ (Succ (foldNat M Succ M2)))) |
-- M2 вычислено, идём на первое уравнение   |----+
=> Succ (Succ (Succ (Succ (Succ M))))       |
-- далее остаётся только подставить уже     |
-- вычисленные значения M                   |
-- и вернуть значение.                      |
\end{code}

Итак подставляется не значение а ссылка на него, 
вычисленная часть значения используется сразу в нескольких
местах. Эта стратегия редукции называется вычислением 
\emph{по необходимости} (call by need) или \emph{ленивой}
стратегией вычислений (lazy evaluation).

Теперь немного терминологии. Значение 
может находится в четырёх состояниях:

\begin{itemize}
\item Нормальная форма (normal form, далее НФ),
    когда оно полностью вычислено (нет синонимов);

\item Слабая заголовочная НФ (weak head NF, далее СЗНФ), 
    когда известен хотя бы один верхний конструктор;

\item Отложенное вычисление (thunk), 
    когда известен лишь рецепт вычисления;

\item Дно (bottom, часто рисуют как $\bot$), 
    когда известно, что значение неопределено.
\end{itemize}


Вы могли понаблюдать за значением в первых трёх состояниях
на примере выше. Но что такое $\bot$? Вспомним определение
для функции извлечения головы списка \In{head}:

\begin{code}
head :: [a] -> a
head (a:_)  = a
head []     = error "error: empty list" 
\end{code}

Второе уравнение возвращает $\bot$. У нас есть две функции,
которые возвращают это \Quote{значение}:

\begin{code}
undefined   :: a
error       :: String -> a
\end{code}

Первая -- это $\bot$ в чистом виде, а вторая не только возвращает
неопределённое значение, но и приводит к выводу на экран 
сообщения об ошибке. Обратите внимание на тип этих функций,
результат может быть значением любого типа. Это наблюдение
приводит нас к ещё одной тонкости. Когда мы определяем тип:

\begin{code}
data Bool       = False | True
data Maybe a    = Nothing | Just a
\end{code}

На самом деле мы пишем:

\begin{code}
data Bool       = undefined | False | True
data Maybe a    = undefined | Nothing | Just a
\end{code}

Компилятор автоматически прибавляет ещё одно значение
к любому определённому пользователем типу. Такие
типы называют \emph{поднятыми} (lifted type). А значения
таких типов принято называть \emph{запакованными} (boxed).
Незапакованное (unboxed) значение -- это простое примитивное значение.
Например целое или действительное число в том виде, в котором
оно хранится на компьютере. В Haskell даже числа \Quote{запакованы}.
Поскольку нам необходимо, чтобы \In{undefined} могло возвращать
в том числе и значение типа \In{Int}:

\begin{code}
data Int = undefined  | I# Int# 
\end{code}

Тип \In{Int}\verb!#! -- это низкоуровневое представление 
огграниченного целого числа. Принято писать незапакованные
типы с решёткой на конце. \In{I}\verb!#! -- это конструктор. 
Нам приходится запаковывать значения ещё и потому, что
значение может принимать несколько состояний (в зависимости
от того, насколько оно вычислено), всё это ведёт к тому,
что у нас хранится не просто значение, а значение
с какой-то дополнительной информацией, которая зависит
от конкретной реализации языка Haskell. 

Мы решили проблему дублирования вычислений, но наше решение 
усугубило проблему расхода памяти. Ведь теперь мы храним
не просто значения, но ещё и дополнительную информацию,
которая отвечает за проведение вычислений. 
Эта проблема может проявляться в очень простых задачах.
Например попробуем вычислить сумму чисел от одного до миллиарда:

\begin{code}
sum [1 .. 1e9]
<interactive>: out of memory (requested 2097152 bytes)
\end{code}

Интуитивно кажется, что для решения этой задачи нам нужно 
лишь две ячейки памяти. В одной мы будем постоянно прибавлять 
к значению единицу, пока не дойдём до миллиарда, так 
мы последовательно будем получать 
элементы списка, а в другой мы будем хранить значение суммы.
Мы начнём с нуля и будем прибавлять значения первой ячейки. 
У ленивой стратегии другое мнение на этот счёт.
Если вы вернётесь к примеру выше, то заметите, что 
\In{sum} копит отложенные выражения до самого 
последнего момента. Поскольку память ограничена, такой 
момент не наступает. Как нам быть? В Haskell по умолчанию
все вычисления проводятся по необходимости, но
предусмотрены и средства для имитации вычисления по значению.
Давайте посмотрим на них.


\subsection{Аннотации строгости}

Языки с ленивой стратегией вычислений называют не строгими (non-strict),
а языки с энергичной стратегией вычислений соответственно~-- строгими.

\subsubsection{Принуждение к СЗНФ с помощью seq}

Мы говорили о том, что при вычислении по имени значения вычисляются 
только при сопоставлении с образцом или в \In{case}-выражениях. 
Есть специальная функция \In{seq}, которая форсирует приведение к СЗНФ:

\begin{code}
seq :: a -> b -> b
\end{code}

Она принимает два аргумента, при выполнении функции первый
аргумент приводится к СЗНФ и \emph{затем} возвращается второй.
Вернёмся к примеру с \In{sum}. Привести к СЗНФ число -- означает
вычислить его полностью. Опрделим функцию \In{sum'}, которая 
перед рекурсивным вызовом вычисляет промежуточный результат:

\begin{code}
sum' :: Num a => [a] -> a
sum' = iter 0 
    where iter res []        = res
          iter res (a:as)    = let res' = res + a
                               in  res' `seq` iter res' as 
\end{code}

Сохраним результат в отдельном модуле \In{Strict.hs} и
попробуем теперь вычислить значение, придётся подождать:

\begin{code}
Strict> sum' [1 .. 1e9]
\end{code}

И мы ждём, и ждём, и ждём.


\subsubsection{Компиляция модулей}

И мы ждём и ждём и ждём. Но переполнения памяти не происходит.
Это хорошо. Но давайте прервём вычисления. Нажмём \In{ctrl+c}.
Функция \In{sum'} вычисляется, но вычисляется очень медленно.
Мы можем существенно ускорить её, если \emph{скомпилируем}
модуль \In{Strict}. До сих пор мы всегда интерпретировали модули. 
В процессе компиляции функция оптимизируется специальным
образом, она может стать на порядок быстрее. 

Для того чтобы скомпилировать модуль нужно переключиться
в его текущую директорию и вызвать компилятор \In{ghc} с
флагом  \verb!--!\In{make}:

\begin{code}
ghc --make Strict
\end{code}

Появились два файла \In{Strict.hi} и \In{Strict.o}. Первый
файл называется интерфейсным он описывает какие в модуле 
определения, а второй файл называется объектным. Он содержит
скомпилированный код модуля. Теперь мы можем загрузить 
модуль \In{Strict} в интерпретатор и сравнить выполнение двух функций:


\begin{code}
Strict> sum' [1 .. 1e6]
5.000005e11
(0.00 secs, 89133484 bytes)
Strict> sum [1 .. 1e6]
5.000005e11
(0.57 secs, 142563064 bytes)
\end{code}

Обратите внимание на прирост скорости. Умение понимать
в каких случаях стоит ограничить лень очень важно. 
И в программах на Haskell тоже. 
Также компилировать модули можно из интерпретатора.
Для этого воспользуемся командой \In{:!}, она 
выполняет системные команды в интерпретаторе \In{ghci}:

\begin{code}
Strict> :! ghc --make Strict
[1 of 1] Compiling Strict           ( Strict.hs, Strict.o )
\end{code}

Отметим наличие специальной функции применения, которая
просит перед применением привести аргумент к СЗНФ, эта 
функция определена в \In{Prelude}:

\begin{code}
($!) :: (a -> b) -> a -> b
 f $! a = a `seq` f a
\end{code}

С этой функцией мы можем определить функцию \In{sum} так:

\begin{code}
sum' :: Num a => [a] -> a
sum' = iter 0 
    where iter res []        = res
          iter res (a:as)    = flip iter as $! res + a
\end{code}


\subsubsection{Функции с хвостовой рекурсией}

Определим функцию, которая не будет лениться при
вычислении произведения чисел, мы назовём её \In{product'}:

\begin{code}
product' :: Num a => [a] -> a
product' = iter 1
    where iter res []        = res
          iter res (a:as)    = let res' = res * a
                               in  res' `seq` iter res' as 
\end{code}

Смотрите функция \In{sum} изменилась лишь в двух местах. Это
говорит о том, что пора задуматься о том, а нет ли такой
общей функции, которая включает в себя и то и другое поведение.
Такая функция есть и называется она \In{foldl'}, вот её определение:

\begin{code}
foldl' :: (a -> b -> a) -> a -> [b] -> a
foldl' op init = iter init
    where iter res []        = res
          iter res (a:as)    = let res' = res `op` a
                               in  res' `seq` iter res' as 
\end{code}

Мы вынесли в аргументы функции бинарную операцию и 
начальное значение. Всё остальное осталось прежним.
Эта функция живёт в модуле \In{Data.List}. Теперь
мы можем определить функции \In{sum'} и \In{prod'}:

\begin{code}
sum'        = foldl' (+) 0
product'    = foldl' (*) 1
\end{code}


Также в \In{Prelude} определена функция \In{foldl}. 
Она накапливает значения в аргументе, но без принуждения вычислять 
промежуточные результаты:

\begin{code}
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl op init = iter init
    where iter res []        = res
          iter res (a:as)    = iter (res `op` a) as 
\end{code}

Такая функция называется функцией с \emph{хвостовой рекурсией}
(tail-recursive function). Рекурсия хвостовая тогда, когда 
рекурсивный вызов функции является последним действием, которое 
выполняется в функции. Посмотрите на второе уравнение функции
\In{iter}. Мы вызываем функцию \In{iter} рекурсивно последним
делом. В языках с вычислением по значению часто хвостовая рекурсия
имеет преимущество за счёт экономии памяти (тот момент который
мы обсуждали в самом начале). Но как видно из этого раздела
в ленивых языках это не так. Библиотечная функция \In{sum}
будет накапливать выражения перед вычислением с риском
исчерпать всю доступную память, потому что она
определена через \In{foldl}.

\subsubsection{Тонкости применения seq}

Хочу подчеркнуть, что функция \In{seq} не вычисляет 
свой первый аргумент полностью. Первый аргумент не приводится
к нормальной форме. Мы лишь просим вычислитель узнать какой 
конструктор находится в корне у данного выражения.
Например в выражении \In{isZero $! infinity} знак
\In{$!} ничем не отличается от простого применения мы
и так будем приводить аргумент \In{infinity} к СЗНФ,
когда нам понадобится узнать какое из уравнений для 
\In{isZero} выбрать, ведь в аргументе функции 
есть сопоставление с образцом.

Рассмотрим пример. Определим такой тип данных:

\begin{code}
data TheDouble = TheDouble Double
    deriving (Show, Eq)

instance Num TheDouble where
    (+) = inTheDouble2 (+)
    (-) = inTheDouble2 (-)
    (*) = inTheDouble2 (*)

    abs = inTheDouble1 abs
    signum = inTheDouble1 signum
    fromInteger = TheDouble . fromInteger 

inTheDouble1 f  (TheDouble a)                = TheDouble $ f a
inTheDouble2 op (TheDouble a) (TheDouble b)  = TheDouble $ op a b
\end{code}

Теперь посчитаем сумму чисел с помощью нашей функции \In{sum'}
и сравним результат с обычной функцией \In{sum} и с вычислениями
\In{sum'} на просто \In{Double}. Сохраним тип \In{TheDouble}
в модуле \In{Strict}, скомпилируем модуль для скорости и
загрузим в интерпретатор:

\begin{code}
Prelude Strict> :! ghc --make Strict
[1 of 1] Compiling Strict           ( Strict.hs, Strict.o )
Prelude Strict> :l Strict
Ok, modules loaded: Strict.
(0.00 secs, 576936 bytes)
\end{code}

Теперь посмотрим на вычисления:

\begin{code}
Prelude Strict> sum' [1::Double .. 1e6]
5.000005e11
(0.05 secs, 88609416 bytes)
Prelude Strict> sum [1::Double .. 1e6]
5.000005e11
(0.56 secs, 142566848 bytes)
Prelude Strict> sum' $ map TheDouble [1::Double .. 1e6]
TheDouble 5.000005e11
(0.52 secs, 237439212 bytes)
\end{code}

Смотрите после того как мы завернули все числа
в \In{TheDouble} вычисления стали проходить с такой же
скоростью, что и в случае обычной функции \In{sum}.
Это происходит потому, что теперь численный тип сидит
в обёртке, когда мы попробуем вычислить СЗНФ в функции
\In{seq}, мы не узнаем ничего нового кроме конструктора обёртки:

\begin{code}
вычислим СЗНФ:
        TheDouble 1 + TheDouble 2

=>      inTheDouble2 (+) (TheDouble 1) (TheDouble 2)
=>      TheDouble $ (TheDouble 1) + (TheDouble 2)
=>      TheDouble ((TheDouble 1) + (TheDouble 2))
-- мы узнали, что в корне сидит конструктор TheDouble,
-- дальше нам идти не нужно, вернём значение:
        TheDouble thunk
\end{code}

И теперь суммы по прежнему накапливаются, но в 
конструкторе \In{TheDouble}. Кстати на этом примере
можно понять разницу между \In{data} и \In{newtype},
если мы определим тип \In{TheDouble} через \In{newtype}
вычисления будут происходить быстрее.

Посмотрим на один типичный пример. Вычисление среднего
для списка чисел. Среднее равно сумме всех элементов
списка, разделённой на длину списка. Для того
чтобы вычислить значение за один проход мы будем
одновременно вычислять и сумму элементов и значение
длины. Также мы понимаем, что нам не нужно откладывать
вычисления, воспользуемся функцией \In{foldl'}:

\begin{code}
mean :: [Double] -> Double
mean = division . foldl' count (0, 0)
    where count  (sum, leng) a = (sum+a, leng+1)
          division (sum, leng) = sum / fromIntegral leng
\end{code}

Проходим по списку, копим сумму в первом элементе пары и
длину во втором. В самом конце делим первый элемент на второй.
Обратите внимание на функцию \In{fromIntegral} она преобразует
значения из целых чисел, в какие-нибудь другие из класса \In{Num}.
Сохраним это определение в модуле \In{Strict} скомпилируем
модуль и загрузим в интерпретатор, не забудьте импортировать
модуль \In{Data.List}, он нужен для функции \In{foldl'}. 
Посмотрим, что у нас получилось:


\begin{code}
Prelude Strict> mean [1 .. 1e7]
5000000.5
(49.65 secs, 2476557164 bytes)
\end{code}

Получилось очень медленно, странно ведь порядок этой функции
должен быть таким же что и у \In{sum'}. Посмотрим на скорость \In{sum'}:

\begin{code}
Prelude Strict> sum' [1 .. 1e7]
5.0000005e13
(0.50 secs, 881855740 bytes)
\end{code}

В 100 раз быстрее. Теперь представьте, что у нас 10 таких функций
как \In{mean} они разбросаны по всему коду и делают своё чёрное 
ленивое дело. Причина такого поведения кроется в том, что мы
опять завернули значение в другой тип, на этот раз в пару.
Когда вычислитель дойдёт до \In{seq}, он остановится на 
выражении \verb!(thunk, thunk)! вместо двух чисел. Он вновь будет 
накапливать отложенные вычисления, а не значения.

Перепишем \In{mean}, теперь мы будем вычислять значения
пары по отдельности и попросим вычислитель привести
к СЗНФ каждое из них перед вычислением итогового значения:

\begin{code}
mean' :: [Double] -> Double
mean' = division . iter (0, 0)
    where iter res          []      = res
          iter (sum, leng)  (a:as)  = 
                let s = sum  + a
                    l = leng + 1
                in  s `seq` l `seq` iter (s, l) as
          
          division (sum, leng) = sum / fromIntegral leng
\end{code}

Такой вот монстр. Функция \In{seq} право ассоциативна
поэтому скобки будут группироваться в нужном порядке.
В этом определении мы просим вычислитель привести
к СЗНФ \emph{числа}, а не пары чисел, как в прошлой версии.
Для чисел СЗНФ совпадает с НФ, и всё должно пройти гладко,
но сохраним это определение и проверим результат:

\begin{code}
Prelude Strict> :! ghc --make Strict
[1 of 1] Compiling Strict           ( Strict.hs, Strict.o )
Prelude Strict> :load Strict
Ok, modules loaded: Strict.
(0.00 secs, 0 bytes)
Prelude Strict> mean' [1 .. 1e7]
5000000.5
(0.65 secs, 1083157384 bytes)
\end{code}

Получилось! Скорость чуть хуже чем у \In{sum'}, но не в сто раз.


\subsubsection{Энергичные образцы}

В GHC предусмотрены специальные обозначения для 
принудительного приведения выражения к СЗНФ. Они не входят
в стандарт языка Haskell, поэтому для того, чтобы
воспользоваться ими, нам необходимо подключить их. 
Расширения подключаются с помощью специального
комментария в самом начале модуля:

\begin{code}
{-# LANGUAGE BangPatterns #-}
\end{code}

Эта запись активирует расширение языка с именем \In{BangPatterns}.
Ядро языка Haskell фиксировано стандартом, но каждый разработчик
компилятора может вносить свои дополнения. Они подключаются 
через директиву \In{LANGUAGE}:

\begin{code}
{-# LANGUAGE 
        Расширение1, 
        Расширение2, 
        Расширение3 #-}
\end{code}

Мы заключаем директиву в специальные комментарии с решёткой,
говорим \In{LANGUAGE} а затем через запятую перечисляем
имена расширений, которые нам понадобятся. Расширения активны 
только в рамках данного модуля. Например если мы импортируем
функции из модуля, в котором включены расширения, то эти
расширения не распространяются дальше на другие модули. 
Такие комментарии с решёткой называют \emph{прагмами} (pragma).

Нас интересует расширение \In{BangPatterns} (bang -- восклицательный
знак, вы сейчас поймёте почему оно так называется). 
Посмотрим на функцию, которая использует энергичные образцы:

\begin{code}
iter (!sum, !leng) a = (step + a, leng + 1)
\end{code}

В декомпозиции пары перед переменными у нас появились 
восклицательные знаки. Они говорят вычислителю о том, 
чтобы он так уж и быть сделал ещё одно усилие и заглянул в корень
значений переменных, которые были переданы в эту функцию. 

Вычислитель говорит ладно-ладно сделаю. А там числа! И
получается, что они не накапливаются. С помощью
энергичных образцов мы можем переписать функцию \In{mean'} 
через \In{foldl'}, а не выписывать её целиком:

\begin{code}
mean'' :: [Double] -> Double
mean'' = division . foldl' iter (0, 0)
    where iter (!sum, !leng) a = (sum  + a, leng + 1)
          division (sum, leng) = sum / fromIntegral leng
\end{code}

Проверим в интерпретаторе

\begin{code}
*Strict> :! ghc --make Strict
[1 of 1] Compiling Strict           ( Strict.hs, Strict.o )
*Strict> :l Strict
Ok, modules loaded: Strict.
(0.00 secs, 581304 bytes)
Prelude Strict> mean'' [1 .. 1e7]
5000000.5
(0.78 secs, 1412862488 bytes)
Prelude Strict> mean' [1 .. 1e7]
5000000.5
(0.65 secs, 1082640204 bytes)
\end{code}

Функция работает чуть медленнее, чем исходная версия, но не
сильно.

\subsubsection{Энергичные типы данных}

Расширение \In{BangPatterns} позволяет указывать какие
значения привести к СЗНФ не только в образцах, но и в 
типах данных. Мы можем создать тип:

\begin{code}
data P a b = P !a !b
\end{code}

Этот тип обозначает пару, элементы которой обязаны находиться
в СЗНФ. Теперь мы можем написать ещё один вариант функции
поиска среднего:

\begin{code}
mean''' :: [Double] -> Double
mean''' = division . foldl' iter (P 0 0)
    where iter (P sum leng) a = P (sum  + a) (leng + 1)
          division (P sum leng) = sum / fromIntegral leng
\end{code}

\subsubsection{Незапакованные типы данных}

Незапакованные типы данных позволяют хранить примитивные
типы данных без дополнительной служебной информации.
Как если бы они были представлены в имперптивном языке 
программирования (например таком как С). Например в
модуле \In{Data.Array.ST}, кроме обычных массивов \In{STArray} 
определены ещё и массивы нехапакованных значений \In{STUArray}.
Мы и сами можем создавать незапакованные значения. 
Это делается с помощью специальной прагмы \In{UNPACK}:

\begin{code}
data P a b = P {-# UNPACK #-} !a 
               {-# UNPACK #-} !b
\end{code}

Теперь наша пара хранит только примитиввные типы данных.
Применение этой прагмы имеет смысл только перед строгими типами
(теми типами, которые отмечены восклицательными знаками).
Такие типы будут занимать гораздо меньше места. Однако
мы теряем преимущества ленивой стратегии, связанные с 
отложенными вычислениями. Значения таких типов
будут вычислены в любом случае. Подробнее о применении
этой прагмы можно почитать в слайдах Джоана Тайбела (Johan Tibel) 
High Performance Haskell.


\section{Реализация Haskell в GHC}

На момент написания этой книги основным компилятором
Haskell является GHC. Остальные конкуренты отстают очень
сильно. Отметим компилятор Hugs (его хорошо использовать 
для демонстрации Haskell на чужом компьютере, если вы не хотите
устанавливать тяжёлый GHC).
В этом разделе мы обзорно рассмотрим как язык Hаskell 
реализован в GHC. 
GHC -- как ни парадоксально это звучит, это самая успешная
программа написанная на Haskell. GHC уже двадцать лет.
Отметим основных разработчиков. Это Саймон Пейтон Джонс
(Simon Peyton Jones) и Саймон Марлоу (Simon Marlow).

GHC состоит из трёх частей. Это сам компилятор, основные
библиотеки языка (такие как Prelude) и низкоуровневая 
система вычислений (она отвечает за управление памятью, 
потоками, вычисление примитивных операций). 
Весь GHC кроме системы вычислений
написан на Haskell. Система вычислений написана на C.
Компилятор принимает набор файлов с исходным кодом 
(а также возможно объектных и интерфейсных файлов) 
и генерирует код низкого уровня. Система вычислений низкого уровня
используется в этом коде как библиотека. Она статически 
подключается к любому нативному коду, который генерируется GHC. 
Далее мы сосредоточимся на изучении компилятора. 

Но перед этим давайте освежим в памяти (или узнаем)
несколько терминов. У нас есть код на Haskell, что значит
перевести в код низкого уровня? Код низкого уровня представляет
собой набор инструкций, которые изменяют значения в памяти
компьютера. Изменение значений происходит с помощью 
базовых операций, которые выполняются в процессоре компьютера.
Память компьютера представляет собой ленту ячеек. У каждой
ячейки есть адрес и содержание. По адресу мы можем читать
данные из ячейки и записывать их туда. Эти операции также
выполняются с помощью инструкций. 
Мы будем делить память на стек (stack), кучу (heap) и 
регистры (registers). 

Стек~-- это очередь с 
принципом работы \Quote{последним пришёл, первым ушёл}.
Стек можно представить как стопку книг. У нас есть две
операции: положить книгу наверх, и снять верхнюю книгу.
Стек очень удобен для переключения контекстов вычисления.
Представьте, что у нас есть функция, которая внутри 
вызывает другую функцию, а та следующую. Находясь в 
верхней функции при заходе во вторую мы сохраняем контекст
внешней функции в стеке. Контекст -- это та информация, которая
нужна нам для того, чтобы продолжить вычисления. 
Как только мы доходим до третьей функции, мы \Quote{кладём на стопку
сверху} контекст второй функции, как только третья функция вычислена,
мы обращаемся к стеку и снимаем с него контекст второй функции
продолжаем вычислять и как только вторая функция заканчивается
снова обращаемся к стеку. А там сверху уже лежит контекст 
самой первой функции. Мы можем продолжать вычисления. Так 
происходит вычисление вложенных функций в императивных 
языках программирования. 

В куче мы храним разные данные. Данные бывают статическими
(они нужны нам на протяжении выполнения всей программы)
и динамическими (время жизни динамических данных заранее
неизвестно, например это могут быть отложенные вычисления,
мы не знаем когда ни нам понадобятся).
У кучи также две операции: выделить блок памяти, эта операция
принимает размер блока и возвращает адрес, по которому
удалось выделить память, и освободить память по указанному адресу.

Регистры находятся в процессоре. В них можно записывать и читать
данные, при этом операции обращения к регистрам будут 
происходить очень быстро.

Посмотрим как GHC справляется с переводом процесса редукции 
синонимов на язык понятный нашему компьютеру. Язык обновления стека и кучи.

\subsection{Этапы компиляции}

Рассмотрим этапы компиляции программы (\RefFig{CompilerStages}).

\newcommand{\Dia}[1]{\fbox{\text{#1}}}

\begin{figure}[ht]
\centering
\begin{diagram}
 &          & \text{Файл .hs} \\
 &          & \dTo  \\
 &          & \Dia{Построение синтаксического дерева} \\
 &          & \dTo \\
 &          & \Dia{Разрешение имён} \\
 &          & \dTo \\
 &          & \Dia{Проверка типов} \\
 &          & \dTo \\
 &          & \Dia{Устранение синтаксического сахара} \\
 &          & \dTo^{\text{Core}} \\
 &          & \Dia{Упрощение Core}     & \rTo & \Dia{Генерация кода для ghci} \\
 &          & \dTo^{\text{STG}} \\
 &          & \Dia{Генерация Cmm} \\ 
 &          & \dTo \\
 &          & \Dia{Cmm}    &        &  \\
 & \ldTo    & \dTo          & \rdTo  &  \\
\Dia{C} &  & \Dia{Native} &        & \Dia{LLVM}  \\
\end{diagram}
\caption{Этапы компиляции}
\label{fig:CompilerStages}
\end{figure}

На первых трёх этапах происходит проверка ошибок. 
Сначала мы строим синтаксическое дерево программы. 
Если мы нигде не забыли скобки, не ошиблись в простановке 
ключевых слов, то этот этап успешно завершится. 
Далее мы приписываем ко всем функциям их полные имена.
Дописываем перед всеми определениями имя модуля, в котором они
определены. Обычно на этом этапе нам сообщают о том, что
мы забыли определить какую-нибудь функцию, часто это связано
с простой опечаткой. Следующий этап -- самый важный. 
Происходит вывод типов для всех значений и проверка
программы по типам. Блок кода, отвечающий за проверку типов,
является самым большим в GHC. Haskell имеет очень 
развитую систему типов. Многих возможностей мы ещё 
не коснулись, часть из них мы рассмотрим в главе 16.
Допустим, что мы исправили все ошибки связанные с типами,
тогда компилятор начнёт переводить Haskell в Core.

Core -- это функциональный язык программирования, который 
является сильно урезанной версией Haskell. Помните мы говорили, что 
в Haskell поддерживается несколько стилей (композиционный
и декларативный). Что хорошо для программиста, не очень хорошо 
для компилятора. Компилятор устраняет весь синтаксический сахар
и выражает все определения через простейшие конструкции языка Core.
Далее происходит серия оптимизаций языка Core. На дереве
описания программы выполняется серия функций типа  \mbox{\In{Core -> Core}}.
Например происходит замена вызовов коротких функций на 
их правые части урвнений (встраивание или inlining), 
выражения, которые проводят декомпозицию в \In{case}-выражениях 
по константам, заменяются на соответствующие этим константам 
выражения. По требованию GHC может провести анализ строгости
(strictness analysis). Он заключается в том, что GHC
ищет аргументы функций, которые могут быть вычислены 
более эфективно с помощью вычисления по значению и
расставляет анотации строгости. И многие многие другие
оптимизации кода. Все они представлены в виде преобразования
синтаксического дерева программы. Также этот этап называют
упрощением программы. 

После этого Core переводится на STG. Это функциональный
язык, повторяющий Core. Он содержит дополнительную информацию,
которая необходима низкоуровневым бибилиотекам на этапе 
вычисления программы. Затем из STG генерируется код
языка \verb!C--!. Это язык низкого уровня, \Quote{портируемый ассемблер}.
На этом языке не пишут программы, он предназначен для 
автоматической генерации кода. Далее из него получают
другие низкоуровневые коды. Возможна генерация C, LLVM
и нативного кода (код, который исполняется операционной системой). 

\subsection{Язык STG}

STG расшифровывается как Spineless Tagless G-machine. 
G-machine или Г-машина -- это низкоуровневое описание 
процесса редукции графов (от Graph). Пока мы называли этот процесс
редукцией синонимов. Spineless и Tagless -- это термины специфичные
для G-машины, которая была придумана разработчиками GHC.
Tagless относится к особому представлению объектов в куче
(объекты представлены единообразно, так что им не нужен специальный
тег для обозначения типа объекта), а Spineless относится
к тому, что в отличие от машин-предшественников, которые
описывают процесс редукции графов виде последовательности
инструкций, STG является небольшим функциональным языком. 
На \RefFig{SyntaxSTG} представлен синтаксис языка STG. 
Синтаксис упрощён для чтения людьми. Несмотря на упрощения 
мы сможем посмотреть как происходит вычисление выражений. 
    
\begin{figure}[ht]
\centering
\[\begin{array}{rrlll}
\text{Переменные}   & x,y,f,g   &       &   &  \\
\text{Конструкторы} & C         &       &   & 
    \text{Объявлены в определениях типов}  \\
\text{Литералы}     & lit       & ::=   & i \Or d & 
    \text{Незапакованные целые} \\
 & & & & \text{или действительные числа} \\
\text{Атомы}        & a, v      & ::=   & lit \Or x & 
    \text{Аргументы функций атомарны} \\
\text{Арность функции} & k      & ::=   & \bullet   & 
    \text{Арность неизвестна} \\
                       &        & \Or   & n         & 
    \text{Арность известна } n \geq 1 \\
\\
\text{Выражения}       &   e     & ::=  & a         & \text{Атом} \\
                       &         & \Or  & f^k\ a_1 \dots a_n & 
    \text{Вызов функции } (n \geq 1) \\ 
                       &         & \Or  & \oplus\ a_1 \dots a_n & 
    \text{Вызов примитивной функции } (n \geq 1) \\  
\\
                       &         & \Or  & 
            \texttt{let}\ x\ \texttt{=}\ obj\ \texttt{in}\ e  & 
    \text{Выделение нового объекта } obj \text{ в куче} \\ 
                       &         & \Or  & 
            \texttt{case } e \texttt{ of } \{ alt_1; \dots ;alt_n \}  & 
    \text{Приведение выражения } e \text{ к СЗНФ} \\  
\\
\text{Альтернативы}    & alt     & ::=  & C\ x_1 \dots x_n \Ra e &
    \text{Сопоставление с образцом } (n \geq 1) \\
                       &         & \Or  & x \Ra e &
    \text{Альтернатива по умолчанию} \\
\\
\text{Объекты в куче}  & obj     & ::=  & FUN(x_1 \dots x_n \Ra e)  &
    \text{Функция арности } n \geq 1 \\
                        &        & \Or  & PAP(f\ a_1 \dots a_n) &
    \text{Частичное применение } f \text{ может} \\
 & & & & \text{указывать только на } FUN \\
                        &        & \Or  & CON(C\ a_1 \dots a_n) &
        \text{Полное применение конструктора } (n \geq 0) \\
                        &        & \Or  & THUNK\ e  & 
        \text{Отложенное вычисление}  \\   
                        &        & \Or  & BLACKHOLE &
        \text{Используется только во время} \\
 & & & & \text{выполнения программы} \\
\text{Программа}        & prog  & ::=   & 
    f_1 \texttt{=} obj_1\ ; \dots ;\ f_n \texttt{=} obj_n & \\

\end{array}\]
\caption{Синтаксис STG}
\label{fig:SyntaxSTG}
\end{figure}

По синтаксису STG можно понять, какие выражения языка
Haskell являются синтаксическим сахаром. Им просто нет 
места в языке STG. Например, не видим мы сопоставления с образцом.
Оно как и \In{if}-выражения переписывается через \In{case}-выражения.
Исчезли \In{where}-выражения. Конструкторы могут применяться
только полностью, то есть для применения конструктора мы должны
передать ему все аргументы. В STG \In{let}-выражения
разделяют на не рекурсивные (\In{let}) и рекурсивные (\In{letrec}).
Разделение проводится в целях оптимизации, мы же будем
считать, что эти случаи описываются одной конструкцией. 

На что стоит обратить внимание? Заметим, что функции
могут принимать только атомарные значения 
(либо примитивные значения, либо переменные). 
В данном случае переменные указывают на объекты в куче. 
Так если в Haskell мы пишем:

\begin{code}
foldr f (g x y) (h x)
\end{code}

В STG это выражение примет вид:

\begin{code}
let gxy = THUNK (g x y)
    hx  = THUNK (h x)
in  foldr f gxy hx
\end{code}

У функций появились степени. Что это? Степени указывают
на арность функции, то есть на количество принимаемых аргументов.
Количество принимаемых аргументов определяется по левой части
функции. Поскольку в Haskell функции могут возвращать другие функции,
очень часто мы не можем знать арность, тогда мы пишем $\bullet$.

Отметим два важных принципа вычисления на STG:

\begin{itemize}
\item Новые объекты создаются в куче \emph{только} в \In{let}-выражениях
\item Выражение приводится к СЗНФ \emph{только} в \In{case}-выражениях
\end{itemize}

Выражение \In{let a = obj in e} означает
добавь в кучу объект \In{obj} под именем \In{a} и затем вычисли \In{e}.
Выражение \In{case e of}~\verb!{alt1;...;alt2}! означает
узнай конструктор в корне \In{e} и продолжи вычисления в соответствующей
альтернативе. Обратите внимание на то, что сопоставления с образцом
в альтернативах имеет только один уровень вложенности. 
Также аргумент \In{case}-выражения в отличие от функции не обязан
быть атомарным. 

Для тренировки перепишем на STG пример из раздела про ленивые вычисления.

\begin{code}
data Nat = Zero | Succ Nat

zero    = Zero
one     = Succ zero
two     = Succ one

foldNat :: a -> (a -> a) -> Nat -> a
foldNat z  s  Zero      = z
foldNat z  s  (Succ n)  = s (foldNat z s n)

add a = foldNat a   Succ
mul a = foldNat one (add a) 

exp = (\x -> add (add x x) x) (add Zero two)
\end{code}

Теперь в STG:

\begin{code}
data Nat = Zero | Succ Nat

zero    = CON(Zero)
one     = CON(Succ zero)
two     = CON(Succ one)

foldNat = FUN( z s arg -> 
            case arg of 
                Zero    -> z
                Succ n  -> let next = THUNK (foldNat z s n)
                           in  s next  
          )

add     = FUN( a ->
            let succ = FUN( x -> 
                        let r = CON(Succ x) 
                        in r)
            in  foldNat a succ
          )

mul     = FUN( a -> 
            let succ = THUNK (add a)
            in  foldNat one succ
          )

exp     = THUNK( 
            let f = FUN( x -> let axx = THUNK (add x x)
                              in  add axx x) 
                a = THUNK (add Zero two)
            in  f a    
          )
\end{code}    

Программа состоит из связок вида \In{имя = объектКучи}.
Эти связки называют глобальными, они становятся
статическими объектами кучи, остальные объекты
выделяются динамически в \In{let}-выражениях.
Глобальный объект типа \In{THUNK} называют 
постоянной аппликативной формой (constant applicative form или 
сокращённо CAF).

\subsection{Вычисление STG}

Итак у нас есть упрощённый функциональный язык. Как мы будем
вычислять выражения? Присутствие частичного применения усложняет
этот процесс. Для многих функций мы не знаем заранее их арность.
Так например в выражении

\begin{code}
f x y
\end{code}

Функция \In{f} может иметь один аргумент в определении, 
но вернуть функцию. Есть два способа вычисления таких функций:

\begin{itemize}
\item \emph{вставка-вход} (push-enter). Когда мы видим 
применение функции, мы сначала \emph{вставляем} все аргументы в стек,
затем совершаем \emph{вход} в тело функции. В процессе входа
мы вычисляем функцию \In{f} и узнаём число аргументов, которое
ей нужно, после этого мы извлекаем из стека необходимое число 
аргументов, и применяем к ним функцию, если мы снова получаем функцию,
тогда мы опять добираем необходимое число аргументов из стека.
И так пока аргументы в стеке не кончатся.

\item \emph{вычисление-применение} (eval-apply). Вместе с функцией
мы храним информацию о том, сколько аргументов ей нужно. 
Если это статически определённая функция 
(определение выписано пользователем), то число аргументов мы можем
понять по левой части определения. В этой стратегии, если число
аргументов известно, мы сразу \emph{вычисляем} значение с
нужным числом аргументов, сохранив оставшиеся в стеке, 
а затем извлекаем аргументы из стека и \emph{применяем}
к ним вычисленное значение.
\end{itemize}

Возвращаясь к исходному примеру, предположим, что арность
функции \In{f} равна единице. Тогда стратегия вставка-вход
сначала добавит на стек \In{x} и \In{y}, а затем будет добирать
из стека необходимые аргументы. Стратегия вычисление-применение
сначала вычислит \In{(f x)}, сохранив \In{y} на стеке, затем
попробует применить результат к \In{y}. Почему мы говорим
попробует? Может так случиться, что арность значения \In{f x}
окажется равным трём, но пока у нас есть лишь один аргумент,
тогда мы создадим объект \In{PAP}, который соответствует 
частичному применению. 

Эти стратегии применимы как к ленивым, так и к энергичным языкам. 
Исторически сложилось, что ленивые языки тяготеют к первой 
стратегии, а энергичные ко второй. До недавнего времени
и в GHC применялась первая стратегия. Пока однажды разработчики GHC 
всё же не решили сравнить две стратегии. Реализовав обе стратегии,
и проверив их на большом количестве разных по сложности программ,
они пришли к выводу, что ни одна из стратегий не даёт существенного
преимущества на этапе вычислений. Потребление ресурсов оказалось 
примерно равным. Но вторая стратегия заметно выигрывала
в простоте реализации. Подробнее об этом можно почитать в статье
Simon Marlow, Simon Peyton Jones:
Making a Fast Curry: Push/Enter vs. Eval/Apply.
Описание модели вычислений GHC, которое вы сейчас читаете
копирует описание приведённое в этой статье. 

\subsubsection{Куча}

Объекты кучи принято называть \emph{замыканиями} (closure).
Их называют так, потому что обычно для вычисления выражения
нам не достаточно знать его текст, например посмотрим на
функцию:

\begin{code}
mul     = FUN( a -> 
            let succ = THUNK (add a)
            in  foldNat one succ
          )
\end{code}

Для того, чтобы вычислить \In{THUNK(add a)} нам необходимо
знать значение \In{a}, это значение определено в теле функции.
Оно определяется из контекста. По отношению к объекту
такую переменную называют \emph{свободной} (free). 
В куче мы будем хранить не только выражение \In{(add a)},
но и ссылки на все свободные переменные, которые участвуют
в выражении объекта. Эти ссылки называют \emph{довесок} (payload).
Объект кучи содержит ссылку на специальную таблицу и довесок. 
В таблице находятся информация о типе объекта и 
код, который необходимо вычислить, а также другая 
служебная информация. При вычислении объекта мы заменяем
ссылки настоящими значениями или ссылками на конструкторы. 

Объект кучи может быть:

\begin{itemize}
\item \In{FUN} -- определением функции;
\item \In{PAP} -- частичным применением;
\item \In{CON} -- полностью применённым конструктором;
\item \In{THUNK} -- отложенным вычислением;
\item \In{BLACKHOLE} -- это значение используется во время вычисления
    \In{THUNK}. Этот трюк предотвращает появление утечек памяти. 
\end{itemize}

Мы будем считать, что куча -- это таблица, которая ставит 
в соответствие адресам объекты или вычисленные значения.


\subsubsection{Стек}

Стек служит для быстрого переключения контекста. Мы будем пользоваться
стеком при вычислении \In{case}-выражений и \In{THUNK}-объектов. 
При вычислении \In{case}-выражения мы сохраняем в стеке альтернативы
и место возврата значения, а сами начинаем вычислять аргумент
\In{case}-выражения. При вычислении \In{THUNK}-объекта мы запомним
в стеке, адрес с которым необходимо связать полученное значение. 

При вычислении в стратегии вставка-вход мы будем сохранять 
в стеке аргументы функции. А при вычислении в стратегии 
вычисление-применение мы также будем сохранять аргументы 
функции в стеке. Какая разница между этими вариантами?
В первой стратегии мы можем доставать из стека произвольное
число аргументов, после определения арности функции мы добираем столько,
сколько нам нужно, поэтому мы будем хранить аргументы по одному.
Во второй же стратегии нам нужно просто сохранить все оставшиеся
аргументы. Мы сохраняем и извлекаем их все сразу. Упрощая,
объекты стека можно представить так:

\[\begin{array}{llll}
k   & ::=  & \texttt{case } \bullet \texttt{ of } \{ alt_1; \dots alt_n \} & 
        \text{контекст \texttt{case}-выражения}  \\
    & \Or  & Upd\ \ t\ \ \bullet                &  
        \text{Обновить отложенное вычисление} \\
    & \Or  & (\bullet \ a_1 \dots a_n )     &  
        \text{Применить функцию к аргументам, только для} \\
    &      &                             &  
        \text{стратегии вычисление-применение} \\
    & \Or  & Arg\ a                      &  
        \text{Аргумент на потом, только для}  \\
    &      &                             &  
        \text{стратегии вставка-вход} \\ 
\end{array}\]



\subsubsection{Правила общие для обеих стратегий вычисления}

Состояние вычислителя состоит из трёх частей. Это выражение
для вычисления $e$, стек $s$ и куча $H$. Мы рассмотрим правила
по которым вычислитель переходит из одного состояния в другое.
Все они имеют вид:

\[ e_1;\quad s_1;\quad H_1\quad \RA\quad e_2;\quad s_2;\quad H_2 \]

Левая часть переходит в правую, при условии, что левая часть
имеет определённый вид. Начнём с правил, которые одинаковы и в той
и в другой стратегии вычисления. Для простоты пока мы будем полагать,
что объекты только добавляются в кучу и никогда не стираются.
Мы будем обозначать добавление в стек как добавление элемента 
в обычный список: $elem\ :\ s$. 

Рассмотрим правило для \In{let}-выражений:

\[ \texttt{let } x \texttt{ = } obj \texttt{ in } e;\quad s;\quad H 
    \quad \RA \quad e[x'/x]; \quad s ;\quad H[x' \Ra obj],\quad x' 
    \text{ -- новое имя} \]

В этом правиле мы добавляем в кучу новый объект $obj$ 
под именем (или по адресу) $x'$. Запись $e[x'/x]$ означает
замену $x$ на $x'$ в выражении $e$. 

Теперь разберёмся с правилами для \In{case}-выражений. 

\[\begin{array}{lll}
\texttt{case}\ v\ \texttt{of}\ \{\dots;C\ x_1\dots x_n \Ra e ;\dots\};
    &\quad \RA  \quad &  e[a_1/x_1 \dots a_n / x_n]; \quad s; \quad H \\
s;\quad H[v \Ra CON(C\ a_1\dots a_n)] & & \\    
\\
\texttt{case}\ v\ \texttt{of}\ \{\dots; x \Ra e\};\quad s;\quad H 
    &\quad \RA  \quad & e[v/x];\quad s; \quad  H \\
    & & \text{Если } v \text{ -- литерал или } H[v] \text{ -- значение,} \\
    & & \text{которое не подходит ни по одной из альтернатив} \\
\\
\texttt{case}\ e\ \texttt{of}\ \{\dots\};\quad s; \quad H 
    & \quad \RA \quad & e;\quad 
    \texttt{case}\ \bullet \ \texttt{of}\ \{\dots\}\ :\ s; \quad H \\
\\

v;\quad \texttt{case}\ \bullet \ \texttt{of}\ \{\dots\}\ :\ s; \quad H 
    & \quad \RA \quad & \texttt{case}\ v\ \texttt{of}\ \{\dots\}; 
    \quad s; \quad H \\ 
\end{array}\]


Вычисления начинаются с третьего правила, в котором нам встречается
\In{case}-выражения с произвольным $e$. В этом правиле мы сохраняем
в стеке альтернативы и адрес возвращаемого значения и продолжаем
вычисление выражения $e$. После вычисления мы перейдём к четвёртому правилу,
тогда мы снимем со стека информацию необходимую для продолжения вычисления
\In{case}-выражения. Это приведёт нас к одному из первых двух правил.
В первом правиле значение аргумента содержит конструктор, подходящий
по одной из альтернатив, а во втором мы выбираем альтернативу по умолчанию.

Теперь посмотрим как вычисляются \In{THUNK}-объекты.

\[\begin{array}{lll}
x;\quad s; \quad H[x \Ra THUNK\ e]  &\quad \RA  \quad & 
    e; \quad Upd\ \ x\ \ \bullet\ :\ s; \quad H[x \Ra BLACKHOLE] \\
\\

y;\quad Upd\ \ x\ \ \bullet\ :\ s; \quad H
&\quad \RA  \quad & y; \quad s; \quad H[x \Ra H[y]] \\ 
& & \text{если } H[y] \text{ является значением} \\
\end{array}\]

Если переменная указывает на отложенное вычисление $e$, 
мы сохраняем в стеке адрес по которому необходимо обновить
значение и вычисляем значение $e$. В это время мы записываем
в по адресу $x$ объект $BLACKHOLE$. У нас нет такого правила,
которое реагирует на левую часть, если в ней содержится
объект $BLACKHOLE$. Поэтому во время вычисления $THUNK$ 
ни одно из правил сработать не может. Этот трюк необходим
для избежания утечек памяти. Как только выражнение будет
вычислено мы извлечём из стека адрес $x$ и обновим значение.

Правила применения функций, если арность совпадает
с числом аргументов в тексте выражения:

\[\begin{array}{lll}
f^n\ a_1 \dots a_n; \quad s; \quad H[y \Ra FUN(x_1 \dots x_n \Ra e)] 
&\quad \RA  \quad &  e[a_1/x_1 \dots a_n/x_n]; s; H \\
\\
\oplus\ a_1 \dots a_n; \quad s; \quad H
&\quad \RA  \quad & a;\quad s;\quad H \\
& & a \text{ -- результат вычисления } (\oplus\ a_1 \dots a_n)  \\
\end{array}\]

Мы просто заменяем все вхождения аргументов на значения. Второе
правило выполняет применение примитивной функции к значениям.

\subsubsection{Правила для стратегии вставка-вход}

\[\begin{array}{lll}
f^k\ a_1 \dots a_m ; \quad s; \quad H 
&\quad \RA  \quad &  f ;\quad Arg\ a_1: \text{\dots} : \ Arg\ a_m \ :\ s ;\quad H \\
\\
\multicolumn{3}{l}{f; \quad Arg\ a_1: \text{\dots} : \ Arg\ a_n \ :\ s ;\quad 
    H[f \Ra FUN(x_1 \dots x_n \Ra e)]} \\ 
&\quad \RA  \quad & e[a_1/x_1 \dots a_n/x_n] ;\quad s; \quad H \\
\\
\multicolumn{3}{l}{f; \quad Arg\ a_1: \text{\dots} : \ Arg\ a_m \ :\ s ;\quad 
    H[f \Ra FUN(x_1 \dots x_n \Ra e)]} \\ 
&\quad \RA  \quad & p;\quad s; \quad H[p \Ra PAP(f\ a_1 \dots a_m)] \\
&  & \text{при } m \geq 1;\ m < n;\ \text{верхний элемент } s \\
&  & \text{ не является } Arg;\ p\ \text{-- новый адрес} \\
\\
\multicolumn{3}{l}{f; \quad Arg\ a_{n+1}\ :\ s;
    \quad H[f \Ra PAP(g\ a_1 \dots a_n)]} \\
&\quad \RA  \quad & g;\quad 
    Arg\ a_1: \text{\dots} : \ Arg\ a_n \ : \ Arg\ a_{n+1} \ :\ s ;\quad H
\end{array}\]

Первое правило выполняет этап \Quote{вставка}. 
Если мы видим применение функции,
мы первым делом сохраняем все аргументы в стеке. Во втором
правиле мы вычислили значение \In{f}, оно оказалось
функцией с арностью $n$. Тогда мы добираем из стека $n$ 
аргументов и подставляем их в правую часть функции $e$.
Если  в стеке оказалось слишком мало аргументов,
то мы переходим к третьему правилу и составляем 
частичное применение. Последнее правило говорит о том как
расшифровывается частичное применение. Мы вставляем в стек
все аргументы и начинаем вычисление функции $g$ из тела $PAP$.



\subsubsection{Правила для стратегии вычисление-применение}

\[\begin{array}{lll}
\multicolumn{3}{l}{f^{\bullet}\ a_1 \dots a_n;\quad s;\quad 
    H[f \Ra FUN(x_1 \dots x_n \Ra e)]} \\
    & \quad \RA  \quad &  e[a_1/x_1 \dots a_n/x_n];\quad s;\quad H \\
\\
\multicolumn{3}{l}{f^k\ a_1 \dots a_m;\quad s;\quad 
    H[f \Ra FUN(x_1 \dots x_n \Ra e)]} \\
    & \quad \RA  \quad &  e[a_1/x_1 \dots a_n/x_n];\quad 
        (\bullet \ a_{n+1} \dots a_m)\ :\ s;\quad H \\ 
    & &  \text{при } m \geq n \\
    & \quad \RA  \quad & p;\quad s ;\quad H[p \Ra PAP(f\ a_1 \dots a_m)] \\
    & &  \text{при } m < n,\ p \text{ -- новый адрес} \\
    \\
\multicolumn{3}{l}{f^{\bullet}\ a_1 \dots a_m;\quad s;\quad 
    H[f \Ra THUNK\ e]} \\
    & \quad \RA  \quad &  f;\quad (\bullet \ a_1 \dots a_m)\ :\ s;\quad H \\ 
\\
\multicolumn{3}{l}{f^k\ a_{n+1} \dots a_m;\quad s;\quad 
    H[f \Ra PAP(g\ a_1 \dots a_n)]} \\
    & \quad \RA  \quad &  g^\bullet\ a_1 \dots a_n\ a_{n+1} \dots a_m; 
        \quad s; \quad H \\ 
\\
f;\quad (\bullet \ a_1 \dots a_n)\ :\ s;\quad H 
    & \quad \RA  \quad & f^\bullet\ a_1 \dots a_n;\quad s;\quad H \\ 
    & & H[f] \text{ является } FUN \text{ или } PAP
\\
\end{array}\]

Разберёмся с первыми двумя правилами.
В первом правиле статическая арность $f$ неизвестна, но
значение $f$ уже вычислено, и мы можем узнать арность по
объекту $FUN$, далее возможны три случая. Число аргументов
переданных в функцию совпадает с арностью $FUN$, тогда
мы применяем аргументы к правой части $FUN$. Если
в функцию передано больше аргументов чем нужно, мы 
сохраняем лишние на стеке. Если же аргументов меньше,
то мы создаём объект $PAP$. 
Третье правило говорит о том, что нам делать, если значение
$f$ ещё не вычислено. Оно является $THUNK$. Тогда мы 
сохраним аргументы на стеке и вычислим его. В следующем
правиле мы раскрываем частичное применение. Мы просто
организуем вызов функции со всеми аргументами (и со стека
и из частичного применения). Последнее правило срабатывает
после третьего. Когда мы вычислим $THUNK$ и увидим там 
$FUN$ или $PAP$. Тогда мы составляем применение функции.  

Сложность применения стратегии вставка-вход связана
с плохо предсказуемым изменением стека. Если в стратегии вычисление-выполнение
мы добавляем и снимаем все аргументы, то в стратегии вставка-вход
мы добавляем их по одному и неизвестно сколько снимем в следующий раз.
Кроме того стратегия вычисление-применение позволяет проводить
оптимизацию перемещения аргументов. Вместо стека мы можем хранить
аргументы в регистрах. Тогда скорость обращения к аргументам
резко возрастёт. 

\subsection{Управление памятью. Сборщик мусора}

В прошлом разделе для простоты мы считали, что объекты только добавляются
на кучу. На самом деле это не так. Допустим во время вычисления функции
нам нужно было вычислить какие-то промежуточные данные, например
объявленные в локальных переменных, тогда после вычисления результата
все эти значения больше не нужны. При этом в куче висит
много-много объектов, которые уже не нужны. Нам нужно 
как-то от них избавится. Этой задачей занимается отдельный 
блок компилятора, который называется \emph{сборщиком мусора} 
(garbage collector), соответственно процесс автоматического
освобождения памяти называется сборкой мусора (garbage collection или GC).

На данный момент в GHC используется копирующий последовательный
сборщик мусора, который работает по алгоритму Чейни (Cheney). 
Изначально под кучу выделяется небольшая область памяти,
по умолчанию 512 Кб (эта цифра может изменится). 
Эта область разделена на две части. 
Сначала мы создаём объекты в одной половине, как только при
выполнении \In{let} оказывается, что мы исчерпали доступную память.
Мы копируем из текущей половины в другую все \Quote{живые} объекты.
Теперь эта половина считается свободной. Этот этап называется
поверхностной очисткой (minor GC). Если после поверхностной
очистки памяти оказалось недостаточно. Начинается 
глубокая очистка (major GC).
Мы просматриваем обе половины и ищем там все живые объекты.
Для этих объектов мы выделяем новую область памяти и 
копируем их туда. После этого вся прежняя память считается свободной.
Мы выделяем столько памяти, сколько осталось живых объектов. 
Так например, если у нас было выделено 30 Мб памяти и оказалось,
что живые объекты занимают 10 Мб, мы выделим ещё 10 Мб, скопируем
туда все живые объекты и общий объём памяти станет равным 40 Мб.

Поверхностная очистка происходит в младшем поколении, а
глубокая в старшем поколении. Мы можем изменять размеры
выделенной памяти с помощью специальных флагов. 
Эти флаги предназнчены для вычислителя низкого уровня
(realtime system или RTS), они заключаются в окружение 
\In{+RTS ... -RTS}, если флаги идут в конце строки и считается,
что все последующие флаги предназначены для \In{RTS}
мы можем просто написать \In{ghc --make file.hs +RTS ...}
Все флаги можно посмотреть в документации GHC. Мы обратим
внимание на несколько флагов. Для начала посмотрим на
флаги \In{s[file]} и \In{S[file]} они позволяют посмотреть
на статистику выполнения программы. Например запустим программу
    
\begin{code}

\end{code}



,



Пока мы ищем мы копируем эти объекты в новую область памяти

оказалось, что 
в другой половине нам не хватило места для всех живых объект


\begin{code}
\end{code}

\begin{code}
\end{code}

\begin{code}
\end{code}

\begin{code}
\end{code}


\subsection{Оптимизация программ}

\subsection{Просмотр показателей вычисления в GHC}
\begin{code}
\end{code}

\begin{code}
\end{code}


\section{Краткое содержание}

В этой главе мы узнали о том как происходят вычисления
в Haskell. Мы узнали, что они ленивые. Всё вычисляется
как можно позже и как можно меньше. Такие вычисления
называются вычислениями по необходимости.

Также мы узнали о вычислениях по значению и вычислениях по имени.

\begin{itemize}
\item В \emph{вычислениях по значению} редукция проводится от 
        листьев дерева выражения к корню
\item В \emph{вычислениях по имени} редукция проводится от корня 
        дерева выражения к листьям.
\end{itemize}

Вычисление по необходимости является улучшением 
вычисления по имени. Мы не дублируем выражения
во время применения. Все аргументы функции вычисляются
не более одного раза.

Мы познакомились с терминологией процесса вычислений.
Выражение может находится в \emph{нормальной форме}. Это значит
что оно вычислено. Может находится в \emph{слабой заголовочной
нормальной форме}. Это значит, что мы знаем хотя бы один 
конструктор в корне выражения. Также возможно выражение 
ещё не вычислялось, тогда оно является \emph{отложенным} (thunk).

Суть ленивых вычислений заключается в том, что они
происходят синхронно. Если у нас есть 
композиция двух функций:

\[ g\ (f\ x) \]

Внутренняя функция \In{f} не начнёт вычисления до тех
пор пока значения не понадобятся внешней функции \In{g}.
О последствиях этого мы остановимся подробнее в следующей главе.
Значения могут потребоваться при сопоставлении с образцом.
Когда мы хотим узнать какое из уравнений нам выбрать.

Иногда ленивые вычисления не эффективны по расходу памяти. 
Это происходит когда выражение состоит из большого числа
подвыражений, которые будут вычислены в любом случае.
В Haskell у нас есть способы борьбы с ленью. 
Это функция \In{seq} и взрывные образцы. 

Функция \In{seq}:

\begin{code}
seq :: a -> b -> b
\end{code}

Сначала приводит к слабой заголовочной форме свой первый
аргумент, а затем возвращает второй. Взрывные образцы
выполняют те же функции, но они используются в декомпозиции 
аргументов или в объявлении типа. 

Также мы узнали как компилируются модули в \In{ghc}. Это делается
с помощью команды:

\begin{code}
ghc --make ИмяМодуля
\end{code}

Модули можно компилировать и из интерпретатора, выполнив команду

\begin{code}
Prelude>:! ghc --make ИмяМодуля
\end{code}

\section{Упражнения}

\begin{itemize}

\item Потренируйтесь в понимании того как происходят
        ленивые вычисления. Вычислите на бумаге 
        следующие выражения (если это возможно):

\begin{itemize}
\item 
\begin{code}
sum $ take 3 $ filter (odd . fst) $ 
    zip [1 ..] [1, undefined, 2, undefined, 3, undefined, undefined]
\end{code}

\item \In{take 2 $ foldr (+) 0 $ map Succ $ repeat Zero}
\item \In{take 2 $ foldl (+) 0 $ map Succ $ repeat Zero}
\end{itemize}

\item Посмотрите на такую функцию вычисления суммы
        всех чётных и нечётных чисел в списке. 

\begin{code}
sum2 :: [Int] -> (Int, Int)
sum2 []     c = c
sum2 (x:xs) c = sum2 xs (tick x c)

tick :: Int -> (Int, Int) -> (Int, Int)
tick x (c0, c1) | even x    = (c0, c1 + 1)
                | otherwise = (c0 + 1, c1)
\end{code} 

    Эта функция очень медленная. Кто-то слишком много ленится.
    Узнайте кто, и ускорьте функцию.
   
\item Потренируйтесь переводить программы в STG.
    После перевода представьте последовательность действий,
    выполняемых компилятором при редукции выражения.
    Переводите пока не почувствуете уверенность в понимании того как 
    происходит вычисление программы.
\end{itemize}
