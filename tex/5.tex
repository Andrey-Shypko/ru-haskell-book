\setcounter{chapter}{4}
\chapter{Функции высшего порядка}

\Funs{высшего порядка}
\emph{Функцией высшего порядка} называют функцию, которая может
принимать на вход функции или возвращать функции в качестве результата.
За счёт частичного применения в Haskell все функции,
которые принимают более одного аргумента, являются функциями
высшего порядка. 

В этой главе мы подробно обсудим способы 
составления функций, недаром Haskell -- функциональный язык.
В Haskell функции являются очень гибким объектом, они позволяют
выделять сложные способы комбинирования значений. Часто за счёт
развитых средств составления новых функций в Haskell пользователь 
определяет лишь базовые функции, получая остальные \Quote{на лету}
применением двух-трёх операций, это выглядит примерно как \In{(2+3)*5},
где вместо чисел стоят базовые функции, а операции \In{+} и \In{*} составляют
новые функции из простейших.

\section{Обобщённые функции}

В этом разделе мы познакомимся с несколькими функциями,
которые принимают одни функции и составляют по ним другие.
Эти функции используются в Haskell очень часто. 
Все они живут в модуле \In{Data.Function}. Модуль \In{Prelude}
экспортирует их из этого модуля. 

\subsection{Функция тождества}

Начнём с самой простой функции. Это функция \In{id}.
Она ничего не делает с аргументом, просто возвращает его:

\begin{code}
id :: a -> a
id x = x
\end{code}

Зачем нам может понадобиться такая функция? Сама по себе
она бесполезна. Она приобретает ценность при совместном 
использовании с другими функциями, поэтому пока мы не будем 
приводить примеров.

\subsection{Константная функция}

Следующая функция \In{const} принимает значение и возвращает
постоянную функцию. Эта функция будет возвращать константу
для любого переданного в неё значения:

\begin{code}
const :: a -> b -> a
const a _ = a
\end{code}

Функция \In{const} является конструктором постоянных
функций, так например мы получаем пятёрки на любой аргумент:

\begin{code}
Prelude> let onlyFive = const 5
Prelude> :t onlyFive 
onlyFive :: b -> Integer
Prelude> onlyFive "Hi"
5
Prelude> onlyFive (1,2,3)
5
Prelude> map onlyFive "abracadabra"
[5,5,5,5,5,5,5,5,5,5,5]
\end{code}

С её помощью мы можем легко построить и постоянную
функцию двух аргументов:

\begin{code}
const2 a = const (const a)
\end{code}

Вспомним определение для \In{&&}:

\begin{code}
(&&) :: Bool -> Bool -> Bool
(&&) True   x  = x
(&&) False  _  = False  
\end{code}

С помощью функций \In{id} и \In{const} мы можем сократить число 
аргументов и уравнений:

\begin{code}
(&&) :: Bool -> Bool -> Bool
(&&) a = if a then id else (const False)
\end{code}

Также мы можем определить и логическое \Quote{или}:

\begin{code}
(||) :: Bool -> Bool -> Bool
(||) a = if a then (const True) else id
\end{code}

\subsection{Функция композиции}

Функция композиции принимает две функции и составляет
из них последовательное применение функций:

\begin{code}
(.) :: (b -> c) -> (a -> b) -> a -> c
(.) f g = \x -> f (g x)
\end{code}

Это очень полезная функция. Она позволяет нанизывать
функции друг на друга. Мы перехватываем выход второй функции,
сразу подставляем его в первую и возвращаем её выход в качестве
результата. Например перевернём список символов и затем 
сделаем все буквы заглавными:

\begin{code}
Prelude> :m +Data.Char
Prelude Data.Char> (map toUpper . reverse) "abracadabra"
"ARBADACARBA"
\end{code}

Приведём пример посложнее:

\begin{code}
add :: Nat -> Nat -> Nat
add  a  Zero     = a
add  a  (Succ b) = Succ (add a b)
\end{code}

Если мы определим функцию свёртки для \In{Nat}, которая
будет заменять в значении типа \In{Nat} конструкторы на 
соответствующие по типу функции:

\begin{code}
foldNat :: a -> (a -> a) -> Nat -> a
foldNat zero succ Zero     = zero
foldNat zero succ (Succ b) = succ (foldNat zero succ b)
\end{code}

То мы можем переписать с помощью функции композиции эту функцию так:

\begin{code}
add :: Nat -> Nat -> Nat
add = foldNat  id  (Succ . )
\end{code}

Куда делись аргументы? Они выражаются через функции \In{id}
и \In{(.)}. Поведение этой функции лучше проиллюстрировать 
на примере. Пусть у нас есть два числа типа \In{Nat}:

\begin{code}
two     = Succ (Succ Zero)
three   = Succ (Succ (Succ Zero))
\end{code}

Вычислим 

\begin{code}
add two three
\end{code}

Вспомним о частичном применении:

\begin{code}
    add two three 
=>  (add two) three
=>  (foldNat id (Succ . ) (Succ (Succ Zero))) three
\end{code}

Теперь функция свёртки заменит все конструкторы \In{Succ} 
на \In{(Succ . )}, а конструкторы \In{Zero} на \In{id}:

\begin{code}
=>  ((Succ . ) ((Succ . ) id)) three
\end{code}

Что это за монстр?

\begin{code}
((Succ . ) ((Succ . ) id))
\end{code}

Функция \In{(Succ . )} это левое сечение операции \In{(.)}. 
Эта функция, которая принимает функции и возвращает функции.
Она принимает функцию и навешивает на её выход конструктор \In{Succ}.
Давайте упростим это большое выражение с помощью определений функций
\In{(.)} и \In{id}:


\begin{code}
    ((Succ . ) ((Succ . ) id))
=>   (Succ . ) (\x -> Succ (id x))
=>   (Succ . ) (\x -> Succ x)
=>   \x -> Succ (Succ x)
\end{code}

Теперь нам осталось применить к этой функции наше второе
значение:

\begin{code}
    (\x -> Succ (Succ x)) three
=>  Succ (Succ three)
=>  Succ (Succ (Succ (Succ (Succ x))))
\end{code}

Так мы получили, что и ожидалось от сложения. За каждый
конструктор \In{Succ} в первом аргументе мы добавляем 
применение \In{Succ} к результату, а вместо \In{Zero}
протаскиваем через \In{id} второй аргумент. 

\subsection{Аналогия с числами}


С помощью функции композиции мы можем нанизывать
друг на друга списки функций. Попробуем в интерпретаторе: 

\begin{code}
Prelude> let f = foldr (.) id [sin, cos, sin, cos, exp, (+1), tan]
Prelude> f 2
0.6330525927559899
Prelude> f 15
0.7978497904127007
\end{code}

Функция \In{foldr} заменит в списке каждый конструктор  \In{(:)}
на функцию композиции, а пустой список на функцию \In{id}. 
В результате получается композиция из всех функций в списке.

Это очень похоже на сложение или умножение чисел в списке.
При этом в качестве нуля (для сложения) или единицы (для умножения)
мы используем функцию \In{id}. Мы пользуемся тем, что по
определению для любой функции \In{f} выполнены тождества:

\begin{code}
f  . id  ==  f
id . f   ==  f
\end{code}

Поэтому мы можем использовать \In{id} в качестве накопителя 
результата композиции, как в случае: 

\begin{code}
Prelude> foldr (*) 1 [1,2,3,4]
24
\end{code}

Если сравнить \In{(.)} с умножением, то \In{id} похоже
на единицу, а \In{(const a)} на ноль. В самом деле для 
любой функции \In{f} и любого значения \In{a} выполнено
тождество:

\begin{code}
const a  .  f  == const a
\end{code}

Мы словно умножаем функцию на ноль, делая 
её вычисление бессмысленным. 

\subsection{Функция перестановки}

Функция перестановки \In{flip} принимает функцию
двух аргументов и меняет аргументы местами:

\begin{code}
flip  :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x
\end{code}

К примеру:

\begin{code}
Prelude> foldr (-) 0 [1,2,3,4]
-2
Prelude> foldr (flip (-)) 0 [1,2,3,4]
-10
\end{code}

Иногда это бывает полезно.

\subsection{Функция on}

Функция \In{on} (от англ.~на) перед применением бинарной
функции пропускает аргументы через унарную функцию:

\begin{code}
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
(.*.) `on` f = \x y -> f x .*. f y
\end{code}

Она часто используется в сочетании с функцией \In{sortBy}
из модуля \In{Data.List}. Эта функция имеет тип:

\begin{code}
sortBy :: (a -> a -> Ordering) -> [a] -> [a]
\end{code}

Она сортирует элементы списка согласно некоторой
функции упорядочивания \In{f ::  (a -> a -> Ordering)}.
С помощью функции \In{on} мы можем легко составить такую
функцию на лету:

\begin{code}
let xs = [(3, "John"), (2, "Jack"), (34, "Jim"), (100, "Jenny"), (-3, "Josh")]  
Prelude> :m +Data.List Data.Function
Prelude Data.List Data.Function> 
Prelude Data.List Data.Function> sortBy (compare `on` fst) xs
[(-3,"Josh"),(2,"Jack"),(3,"John"),(34,"Jim"),(100,"Jenny")]
Prelude Data.List Data.Function> map fst (sortBy (compare `on` fst) xs)
[-3,2,3,34,100]
Prelude Data.List Data.Function> map snd (sortBy (compare `on` fst) xs)
["Josh","Jack","John","Jim","Jenny"]
\end{code}

Мы импортировали в интерпретатор модуль \In{Data.List} для функции
\In{sortBy} а также модуль \In{Data.Function} для функции \In{on}.
Они не импортируются модулем \In{Prelude}.

Выражением \In{(compare `on` fst)} мы составили функцию 

\begin{code}
\a b -> compare (fst a) (fst b)

fst = \(a, b) -> a
\end{code}

Тем самым ввели функцию упорядочивания на парах, которая 
будет сравнивать пары по первому элементу.
Отметим, что аналогичного эффекта можно добиться
с помощью функции \In{comparing} из модуля \In{Data.Ord}.


\subsection{Функция применения}

Ещё одной очень полезной функцией является функция применения \In{($)}.
Посмотрим на её определение:

\begin{code}
($) :: (a -> b) -> a -> b
f $ x  =  f x
\end{code}

На первый взгляд её определение может показаться бессмысленным.
Зачем нам специальный знак для применения, если у нас уже есть
пробел? Для ответа на этот вопрос нам придётся 
познакомиться с приоритетом инфиксных операций.

\section{Приоритет инфиксных операций}

В Haskell очень часто используются 
бинарные операции для составления функций \Quote{на лету}.
В этом помогает и частичное применение, мы можем в одном
выражении применить к функции часть аргументов, построить 
из неё новую функцию с помощью какой-нибудь такой бинарной
операции и всё это передать в другую функцию! 

Для сокращения числа скобок нам понадобится разобраться в
понятии приоритета операции. Так например в выражении 

\begin{code}
> 2 + 3 * 10
32
\end{code}

Мы полагаем, что умножение имеет больший приоритет чем
сложение и со скобками это выражение будет выглядеть так:

\begin{code}
> 2 + (3 * 10)
32
\end{code}

Фраза \Quote{больший приоритет} означает: сначала умножение
потом сложение. Мы всегда можем изменить поведение по умолчанию
с помощью скобок:

\begin{code}
> (2 + 3) * 10
50
\end{code}

В Haskell приоритет функций складывается из двух понятий:
старшинство и ассоциативность. Старшинство определяется числами,
они могут быть от 0 до 9. Чем больше это число, тем выше приоритет
функций. 

Старшинство используется вычислителем для группировки 
разных операций, например \In{(+)} имеет старшинство 6, а 
\In{(*)} имеет старшинство 7. Поэтому интерпретатор сначала
ставит скобки вокруг выражения с \In{(*)}, а затем вокруг \In{(+)}.
Считается, что обычное префиксное применение имеет высший приоритет 10.
Нельзя задать приоритет выше применения, это значит, что операция
\Quote{пробел} будет всегда выполняться первой.

Ассоциативность используется для группировки одинаковых
операций, например мы видим:

\begin{code}
1+2+3+4
\end{code}

Как нам быть? Мы можем группировать скобки слева направо:

\begin{code}
((1+2)+3)+4
\end{code}

Или справа налево:

\begin{code}
1+(2+(3+4))
\end{code}

Ответ на этот вопрос даёт ассоциативность, она бывает левая и
правая. Например операции \In{(+)} \In{(-)} и (*) являются лево-ассоциативными,
а операция возведения в степень \In{(^)} является право-ассоциативной.

\begin{code}
1 + 2 + 3 == (1 + 2) + 3
1 ^ 2 ^ 3 ==  1 ^ (2 ^ 3)
\end{code}


Приоритет функции можно узнать в интерпретаторе с помощью
команды \In{:i}:

\begin{code}
*FunNat> :m Prelude
Prelude> :i (+)
class (Eq a, Show a) => Num a where
  (+) :: a -> a -> a
  ...
  	-- Defined in GHC.Num
infixl 6 +
Prelude> :i (*)
class (Eq a, Show a) => Num a where
  ...
  (*) :: a -> a -> a
  ...
  	-- Defined in GHC.Num
infixl 7 *
Prelude> :i (^)
(^) :: (Num a, Integral b) => a -> b -> a 	-- Defined in GHC.Real
infixr 8 ^
\end{code}

Приоритет указывается в строчках \In{infixl 6 +} и \In{infixl 7 *}.
Цифра указывает на старшинство операции, а суффикс \In{l} 
(от англ.~left -- левая) или \In{r} (от англ.~right -- правая)
на ассоциативность. 

Если мы создали свою функцию, мы можем определить для 
неё ассоциативность. Для этого мы пишем в коде:

\begin{code}
module Fixity where

import Prelude(Num(..))

infixl 4 *** 
infixl 5 +++
infixr 5 `neg`

(***) = (*)
(+++) = (+)
neg   = (-)
\end{code}

Мы ввели новые операции и поменяли старшинство операций
сложения и умножения местами и изменили ассоциативность 
у вычитания. Проверим в интерпретаторе:

\begin{code}
Prelude> :l Fixity
[1 of 1] Compiling Fixity           ( Fixity.hs, interpreted )
Ok, modules loaded: Fixity.
*Fixity> 1 + 2 * 3
7
*Fixity> 1 +++ 2 *** 3
9
*Fixity> 1 - 2 - 3
-4
*Fixity> 1 `neg` 2 `neg` 3
2
\end{code}

Посмотрим как это вычислялось:

\begin{code}
1   +   2   *  3  ==   1   +   (2    *   3)
1  +++  2  *** 3  ==  (1  +++   2)  ***  3

1   -   2   -  3  ==  (1   -    2)   -   3
1 `neg` 2 `neg 3` ==   1 `neg` (2  `neg` 3)
\end{code}

Также в Haskell есть директива \In{infix} это тоже самое, что и
\In{infixl}.


\subsection{Приоритет функции композиции}

Посмотрим на приоритет функции композиции:

\begin{code}
Prelude> :i (.)
(.) :: (b -> c) -> (a -> b) -> a -> c 	-- Defined in GHC.Base
infixr 9 .
\end{code}

Она имеет высший приоритет. Она очень часто используется
при определении функции в бесточечном стиле. Такая функция 
похожа на конвейер функций:

\begin{code}
fun a = fun1 a . fun2 (x1 + x2) . fun3 . (+x1) 
\end{code}


\subsection{Приоритет функции применения}

Теперь посмотрим на полное определение функции применения:

\begin{code}
infixr 0 $

($) :: (a -> b) -> a -> b
f $ x  =  f x
\end{code}

Ответ на вопрос о полезности этой функции кроется в её приоритете. Ей
назначен самый низкий приоритет. Она будет исполняться в последнюю
очередь. Очень часто возникают ситуации вроде:

\begin{code}
foldNat zero succ (Succ b) = succ (foldNat zero succ b)
\end{code}

С помощью функции применения мы можем переписать это
определение так:

\begin{code}
foldNat zero succ (Succ b) = succ $ foldNat zero succ b
\end{code}

Если бы мы написали без скобок:

\begin{code}
... = succ foldNat zero succ b
\end{code}

То выражение было бы сгруппировано так:

\begin{code}
... = (((succ foldNat) zero) succ) b
\end{code}

Но поскольку мы поставили барьер в виде операции \In{($)}
с низким приоритетом, группировка скобок произойдёт так:

\begin{code}
... = (succ $ ((foldNat zero) succ) b)
\end{code}

Это как раз то, что нам нужно. Преимущество этого подхода
проявляется особенно ярко если у нас несколько вложенных
функций на конце выражения:

\begin{code}
xs :: [Int]
xs = reverse $ map ((+1) . (*10)) $ filter even $ ns 40

ns :: Int -> [Int]
ns 0  = []
ns n  = n : ns (n - 1)
\end{code}

В списке \In{xs} мы сначала создаём в функции \In{ns} 
убывающий список чисел, затем оставляем лишь чётные, 
потом применяем два арифметических действия ко всем элементам
списка, затем переворачиваем список.

Проверим работает ли это в интерпретаторе, заодно поупражняемся
в композиционном стиле:

\begin{code}
Prelude> let ns n = if (n == 0) then [] else n : ns (n - 1)
Prelude> let even x = 0 == mod x 2
Prelude> let xs = reverse $ map ((+1) . (*10)) $ filter even $ ns 20
Prelude> xs 
[21,41,61,81,101,121,141,161,181,201]
\end{code}

Если бы не функция применения нам пришлось бы написать 
это выражение так:

\begin{code}
xs = reverse (map ((+1) . (*10)) (filter even (ns 40)))
\end{code}


\section{Функциональный калькулятор}

Мне бы хотелось сделать акцент на одном из вступительных 
предложений этого раздела:

\begin{quote}
За счёт развитых средств составления новых функций в Haskell пользователь 
определяет лишь базовые функции, получая остальные \Quote{на лету}
применением двух-трёх операций, это выглядит примерно как \In{(2+3)*5},
где вместо чисел стоят базовые функции, а операции \In{+} и \In{*} составляют
новые функции из простейших.
\end{quote}

Такие обобщённые функции как \In{id}, \In{const}, \In{(.)}, \In{map}
\In{filter} позволяют очень легко комбинировать различные функции.
Бесточечный стиль записи функций превращает функции
в простые значения или значения-константы, которые можно 
подставлять в другие функции. 
В этом разделе мы немного потренируемся в перегрузке численных значений и
превратим числа в функции, функции и в самом деле станут 
константами. Мы определим экземпляр \In{Num} для функций,
которые возвращают числа. Смысл этих операций заключается
в том, что теперь мы применяем обычные операции сложения умножения
к функциям, аргумент которых совпадает по типу. Например для того 
чтобы умножить функции \verb!\!\In{t -> t+2} и
\verb!\!\In{t -> t+3} мы составляем новую функцию
\verb!\!\In{t -> (t+2) * (t+3)}, которая получает на
вход значение \In{t} применяет его к каждой из функций 
и затем умножает результаты:

\begin{code}
module FunNat where

import Prelude(Show(..), Eq(..), Num(..), error)

instance Show (t -> a) where
    show _ = error "Sorry, no show. It's just for Num"
instance Eq (t -> a) where
    (==) _ _ = error "Sorry, no Eq. It's just for Num"

instance Num a => Num (t -> a) where
    (+) = fun2 (+)
    (*) = fun2 (*)
    (-) = fun2 (-)

    abs      = fun1 abs
    signum   = fun1 signum

    fromInteger = const . fromInteger

fun1 :: (a -> b) -> ((t -> a) -> (t -> b))
fun1 = (.)

fun2 :: (a -> b -> c) -> ((t -> a) -> (t -> b) -> (t -> c))
fun2 op a b = \t -> a t `op` b t
\end{code}

Функции \In{fun1} и \In{fun2} превращают функции, которые
принимают значения, в функции, которые принимают другие
функции. 

Из-за контекста класса \In{Num} нам пришлось объявить 
два фиктивных экземпляра для классов \In{Show} и \In{Eq}.
Загрузим модуль \In{FunNat} в интерпретатор и 
посмотрим что же у нас получилось:

\begin{code}
Prelude> :l FunNat.hs
[1 of 1] Compiling FunNat           ( FunNat.hs, interpreted )
Ok, modules loaded: FunNat.
*FunNat> 2 2
2
*FunNat> 2 5
2
*FunNat> (2 + (+1)) 0 
3
*FunNat> ((+2) * (+3)) 1
12
\end{code}

На первый взгляд кажется что выражение \In{2 2} не должно
пройти проверку типов, ведь мы применяем значение к константе.
Но на самом деле \In{2} это не константа, а значение \In{2 :: Num a => a}
и подспудно к двойке применяется функция \In{fromInteger}.
Поскольку в нашем модуле мы определили экземпляр \In{Num} для
функций, второе число \In{2} было конкретизировано по умолчанию 
до \In{Integer}, а первое число \In{2} было конкретизировано
до \In{Integer -> Integer}. Компилятор вывел из контекста,
что под \In{2} мы понимаем функцию. Функция была создана 
с помощью метода \In{fromInteger}. Эта функция принимает любое 
значение и возвращает двойку.

Далее мы складываем и перемножаем функции словно это обычные значения.
Что интересно мы можем составлять и такие выражения:

\begin{code}
*FunNat> let f = ((+) - (*))
*FunNat> f 1 2
1
\end{code}

Как была вычислена эта функция? Мы определили экземпляр функций
для значений типа \In{Num a => t -> a}. Если мы вспомним, что
функция двух аргументов на самом деле является функцией одного
аргумента: \In{Num a => t1 -> (t2 -> a)}, мы заметим, что 
тип \In{Num a => (t2 -> a)} принадлежит \In{Num}, теперь если 
мы обозначим его за \In{a'}, то мы получим тип \In{Num a' => t1 -> a'},
это совпадает с нашим исходным экземпляром. 

Получается, что за счёт механизма частичного применения мы одним
махом определили экземпляры \In{Num} для функций \emph{любого} 
числа аргументов, которые возвращают значение типа \In{Num}.

Итак функция \In{f} имеет вид:

\begin{code}
\t1 t2 -> (t1 + t2) - (t1 * t2)
\end{code}

Подставим значения:

\begin{code}
(\t1 t2 -> (t1 + t2) - (t1 * t2)) 1 2
(\t2 -> (1 + t2) - (1 * t2) 2
(1 + 2) - (1 * 2)
3 - 2
1
\end{code}

Теперь давайте составим несколько выражений 
с обобщёнными функциями.
Для этого добавим в модуль \In{FunNat} директиву импорта
функций из модуля \In{Data.Function}. Также добавим несколько
основных функций для списков и класс \In{Ord}:

\begin{code}
module FunNat where

import Prelude(Show(..), Eq(..), Ord(..), Num(..), error)

import Data.Function(id, const, (.), ($), flip, on)
import Prelude(map, foldr, filter, zip, zipWith)

...
\end{code}

и загрузим модуль в интерпретатор:

\begin{code}
Prelude> :load FunNat
[1 of 1] Compiling FunNat           ( FunNat.hs, interpreted )
Ok, modules loaded: FunNat.
\end{code}

Составим функцию, которая принимает один аргумент, 
умножает его на два, вычитает 10 и берёт модуль числа.

\begin{code}
*FunNat> let f = abs $ id * 2 - 10 
*FunNat> f 2
6
*FunNat> f 10
10
\end{code}

Давайте посмотрим как была составлена эта функция:

\begin{code}
    abs $ id * 2 - 10                   

=>  abs $ (id * 2) - 10                 -- приоритет умножения
=>  abs $ (\x -> x * \x -> 2) - 10      -- развернём id и 2
=>  abs $ (\x -> x * 2) - 10            -- по определению (*) для функций
=>  abs $ (\x -> x * 2) - \x -> 10      -- развернём 10
=>  abs $ \x -> (x * 2) - 10            -- по определению (-) для функций
=>  \x -> abs x . \x -> (x * 2) - 10    -- по определению abs для функций
=>  \x -> abs ((x * 2) - 10)            -- по определению (.)

=>  \x -> abs ((x * 2) - 10)
\end{code}



Функция возведения в квадрат:

\begin{code}
*FunNat> let f = id * id
*FunNat> map f [1,2,3,4,5]
[1,4,9,16,25]
*FunNat> map (id * id - 1) [1,2,3,4,5]
[0,3,8,15,24]
\end{code}

Обратите внимание на краткость записи. В этом выражении
\mbox{\In{(id * id - 1)}} проявляется основное преимущество 
бесточечного стиля, избавившись от аргументов, мы можем
пользоваться функциями так, словно это простые значения. 
Этот приём используется в Haskell очень активно. Пока
нам встретились лишь две инфиксных операции для функций 
(это композиция и применение с низким приоритетом),
но в будущем вы столкнётесь с целым морем подобных операций.
Все они служат одной цели, они прячут аргументы функции, 
позволяя быстро составлять функции на лету из примитивов. 
Чтобы не захлебнуться в этом море помните, что скорее
всего новый символ означает либо композицию либо 
применение для функций специального вида. 

Возведём в четвёртую степень:

\begin{code}
*FunNat> map (f . f) [1,2,3,4,5]
[1,16,81,256,625]
\end{code}

Составим функцию двух аргументов, которая будет
вычислять сумму квадратов двух аргументов:

\begin{code}
*FunNat> let x = const id
*FunNat> let y = flip $ const id
*FunNat> let d = x * x + y * y
*FunNat> d 1 2
5
*FunNat> d 3 2
13
\end{code}

Так мы составили функцию, ни прибегая к помощи аргументов.
Эти выражения могут стать частью других выражений:

\begin{code}
*FunNat> filter  ((<10) . d 1) [1,2,3,4,5]
[1,2]
*FunNat> zipWith d [1,2,3] [3,2,1]
[10,8,10]
*FunNat> foldr (x*x - y*y) 0 [1,2,3,4]
3721610024
*FunNat> zipWith ((-) * (-) + const id) [1,2,3] [3,2,1]
[7,2,5]
\end{code}

В последнем выражении трудно предугадать результат. В таких
выражениях всё-таки лучше пользоваться синонимами.
В бесточечном стиле мы можем 
несколькими операциями собрать из базовых функций
сложную функцию и передать её аргументом в другую функцию,
которая также может поучаствовать в комбинации других
функций!

\section{Функции, возвращающие несколько значений}

\Types{кортежи}
Как было сказано ранее функции, которые возвращают несколько 
значений, реализованы в Haskell с помощью кортежей. 
Например функция, которая расщепляет поток на голову и хвост выглядит так:

\begin{code}
decons :: Stream a -> (a, Stream a)
decons (a :& as) = (a, as)
\end{code}

Здесь функция возвращает сразу два значения. Отметим несколько
частных случаев для кортежей. Но всегда ли уместно пользоваться 
кортежами? Для композиции функций, которые возвращают несколько
значений нам придётся разбирать возвращаемые значения
с помощью сопоставления с образцом и затем использовать
эти значения в других функциях. Посудите сами если у нас
есть функции:

\begin{code}
f :: a  -> (b1, b2)
g :: b1 -> (c1, c2)
h :: b2 -> (c3, c4)
\end{code}

Мы уже не сможем комбинировать их так просто как если бы
это были обычные функции без кортежей. 

\begin{code}
q x = (\(a, b) -> (g a, h b)) (f x)
\end{code}

В случае пар нам могут прийти на помощь функции \In{first}
и \In{second}:

\begin{code}
q = first g . second h . f
\end{code}

Если мы захотим составить какую-нибудь другую 
функцию из \In{q}, то ситуация заметно усложнится. 
Функции, возвращающие кортежи, сложнее 
комбинировать в бесточечном стиле.
Здесь стоит вспомнить правило Unix. 

\begin{quote}
Пишите функции, которые делают одну вещь, но делают её хорошо. 
\end{quote}

Функция, которая возвращает кортеж пытается
сделать сразу несколько дел. И теряет в гибкости,
ей трудно взаимодействовать с другими функциями. 
Старайтесь чтобы таких функций было как можно меньше. 

Если функция возвращает несколько значений, попытайтесь
разбить её на несколько, которые возвращают лишь одно
значение. Часто бывает так, что эти значения тесно связаны
между собой и такую функцию не удаётся разбить на 
несколько составляющих. Если у вас появляется много 
таких функций, то это повод задуматься о создании нового
типа данных. 

Например в качестве точки на плоскости можно использовать
пару \In{(Float, Float)}. В этом случае, если вы начнёте 
писать модуль на геометрическую тему у вас появится много функций,
которые принимают и возвращают точки:

\begin{code}
rotate      :: Float -> (Float, Float) -> (Float, Float)
norm        :: (Float, Float) -> (Float, Float)
translate   :: (Float, Float) -> (Float, Float) -> (Float, Float)
...    
\end{code}

Все они стараются делать несколько дел одновременно,
возвращая кортежи. Но мы можем изменить ситуацию 
определением новых типов:

\begin{code}
data Point  = Point  Float Float
data Vector = Vector Float Float
data Angle  = Angle  Float
\end{code}

Объявления функций станут более краткими и наглядными.

\begin{code}
rotate      :: Angle  -> Point -> Point
norm        :: Point  -> Point
translate   :: Vector -> Point -> Point
...    
\end{code}


\section{Краткое содержание}


\subsection*{Основные функции высшего порядка}

Мы познакомились с функциями из модуля \In{Data.Function}.
Их можно разбить на несколько типов:

\begin{itemize}

\item Примитивные функции (генераторы функций). 
        
\begin{code}
id      = \x -> x
const a = \_ -> a
\end{code}

\item Функции, которые комбинируют функции или функции и значения:
        
\begin{code}
f . g  = \x -> f (g x)
f $ x  = f x

(.*.) `on` f = \x y -> f x .*. f y
\end{code}
        
\item Преобразователи функций, принимают функцию и возвращают функцию:

\begin{code}
flip f = \x y -> f y x
\end{code}

\end{itemize}


\subsection*{Приоритет инфиксных операций}

Мы узнали о специальном синтаксисе для задания приоритета 
применения функций в инфиксной форме:

\begin{code}
infixl 3 #
infixr 6 `op`
\end{code}

Приоритет складывается из двух частей: старшинства (от 1 до 9)
и ассоциативности (бывает левая и правая). Старшинство определяет 
распределение скобок между разными функциями:

\begin{code}
infixl 6 +
infixl 7 *

1 + 2 * 3 == 1 + (2 * 3)
\end{code}

А ассоциативность -- между одинаковыми:

\begin{code}
infixl 6 +
infixr 8 ^

1 + 2 + 3 == (1 + 2) + 3    
1 ^ 2 ^ 3 ==  1 ^ (2 ^ 3)  
\end{code}

Мы узнали, что функции \In{($)} и \In{(.)} стоят на разных
концах шкалы приоритетов функций и как этим пользоваться. 

\section{Упражнения}

\begin{itemize}

\item Просмотрите написанные вами функции, или функции
        из примеров. Можно ли их переписать с помощью
        основных функций высшего порядка? 
        Если да, то перепишите. Попробуйте определить
        их в бесточечном стиле.



\item В прошлой главе у нас было упражнение о потоках.
        Сделайте поток экземпляром класса \In{Num}.
        Для этого поток должен содержать значения из класса \In{Num}.
        Методы из класса \In{Num} применяются поэлементно.
        Так сложение двух потоков будет выглядеть так:

\begin{code}
    (a1 :& a2 :& a3 :& ...) + (b1 :& b2 :& b3) ==
==  (a1 + b1 :& a2 + b2 :& a3 + b3 :& ...)
\end{code}


\item Определите приоритет инфиксной операции \In{(:&)}  
        так чтобы вам было удобно использовать её в сочетании
        с арифметическими операциями.

\item Дополните модуль потоков новым типом. Этот
      тип будет содержать функции преобразования
      потоков.

\begin{code}
data F a b = F (Stream a -> Stream b)
\end{code}

Определите для этого типа основные функции высшего порядка.
Чтобы не возникало конфликта имён с модулем \In{Data.Function}
мы не будем его импортировать. Вместо него мы импортируем
модуль \In{Control.Category}. Он содержит класс:

\begin{code}
class Category cat where
        id  :: cat a a
        (.) :: cat b c -> cat a b -> cat a c
\end{code}

Если присмотреться к типам функций, можно понять,
что тип-экземпляр \In{cat} принимает два параметра. 
Совсем как тип функции \In{(a -> b)}. Формально его можно записать
в префиксной форме так \In{(->) a b}. Получается,
что тип \In{cat} это что-то вроде функции. Это некоторые
сущности, у которых есть понятия тождества и композиции.

Для обычных функций экземпляр класса \In{Category}
уже определён. Но в этом модуле у нас есть ещё и 
необычные функции, функции на потоках. Функции 
\In{id} и \In{(.)} мы определим, сделав наш тип \In{F}
экземпляром класса \In{Category}.

Для остальных функций мы переопределим исходные функции:

\begin{code}
const   :: a -> F b a                       -- константа
ap      :: F a b -> Stream a -> Stream b    -- применение
flip    :: F a (F b c) -> F b (F a c)       -- перестановка

curry   :: F (a,b) c -> F a (F b c)         -- частичное применение
\end{code}

Потренируйтесь с тем, что у вас получилось в интерпретаторе
на манер нашего функционального калькулятора. Попробуйте 
составлять сочетания выражений из этого модуля с функциями из упражнения
предыдущей главы.

\item Сделайте тип \In{(Num b => F a b)} экземпляром класса \In{Num}.

\end{itemize}



