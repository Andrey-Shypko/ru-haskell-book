\setcounter{chapter}{6}
\chapter{Примеры из мира специальных функций}

В этой главе мы закрепим на примерах то, что мы 
узнали о монадах и функторах. Напомню, что 
с помощью монад и функторов мы можем комбинировать 
специальные функции вида \In{(a -> m b)}
с другими специальными функциями.

У нас есть функции тождества и применения:

\begin{code}
class Functor f where
    fmap :: (a -> b) -> f a -> f b

class Functor f => Applicative f where
    pure    :: a -> f a
    (<*>)   :: f (a -> b) -> f a -> f b

class Monad m where
    return  :: a -> m a
    (>>=)   :: m a -> (a -> m b) -> m b

(=<<) :: (a -> m b) -> m a -> m b
(=<<) = flip (>>=)
\end{code}

Вспомним основные производные функции для этих классов:

Или в терминах класса \In{Kleisli}:

\begin{code}
-- Композиция
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)

-- Константные функции
(*>) :: Applicative f => f a -> f b -> f b
(<*) :: Applicative f => f a -> f b -> f a

-- Применение обычных функций к специальным значениям
(<$>)  :: Functor f => (a -> b) -> f a -> f b

liftA  :: Applicative f => (a -> b)           -> f a -> f b
liftA2 :: Applicative f => (a -> b -> c)      -> f a -> f b -> f c
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- Преобразование элементов списка специальной функцией
mapM   :: Monad m => (a -> m b) -> [a] -> m [b]
\end{code}

Нам понадобится модуль с определениями типов и 
экземпляров монад для всех типов, которые мы рассмотрели
в предыдущей главе. Экземпляры для \In{[]} и \In{Maybe}
уже определены в \In{Prelude}, а типы \In{State}, 
\In{Reader} и \In{Writer} можно найти в библиотеке
\In{mtl}. Пока мы не знаем как устанавливать библиотеки
определим эти типы и экземпляры для \In{Monad} 
самостоятельно. Возможно вы уже определили их, выполняя
одно из упражнений предыдущей главы, если это
так сейчас вы можете сверить ответы. Определим 
модуль \In{Types}:

\begin{code}
module Types(
    State(..), Reader(..), Writer(..),
    runState, runWriter, runReader,
    module Control.Applicative,
    module Control.Monad,
    module Data.Monoid)    
where

import Data.Monoid
import Control.Applicative
import Control.Monad

-------------------------------------------------
-- Функции с состоянием
--
--      a -> State s b

data State s a = State (s -> (a, s))

runState :: State s a -> s -> (a, s)
runState (State f) = f

instance Monad (State s) where
    return a  = State $ \s -> (a, s)
    ma >>= mf = State $ \s0 -> 
                    let (b, s1) = runState ma s0
                    in   runState (mf b) s1

---------------------------------------------------
-- Функции с окружением
--
--      a -> Reader env b

data Reader env a = Reader (env -> a)

runReader :: Reader env a -> env -> a
runReader (Reader f) = f

instance Monad (Reader env) where
    return a    = Reader $ const a
    ma >>= mf   = Reader $ \env -> 
                    let b = runReader ma env
                    in  runReader (mf b) env 
                    
---------------------------------------------------
-- Функции-накопители
--
--      Monoid msg => a -> Writer msg b

data Writer msg a = Writer (a, msg)
    deriving (Show)

runWriter :: Writer msg a -> (a, msg)
runWriter (Writer f) = f

instance Monoid msg => Monad (Writer msg) where
    return a    = Writer (a, mempty)
    ma >>= mf   = Writer (c, msgA `mappend` msgF)
        where (b, msgA) = runWriter ma
              (c, msgF) = runWriter $ mf b
\end{code}

Я пропустил определения для экземпляров классов \In{Functor} 
и \In{Applicative}, их можно получить из экземпляра для
класса \In{Monad} с помощью стандартных функций 
\In{liftM}, \In{return} и \In{ap} из модуля \In{Control.Monad}.

Нам встретилась новая запись в экспорте модуля.
Для удобства мы экспортируем модули \In{Control.Applicative},
\In{Control.Monad} и \In{Data.Monoid} целиком. 
Для этого мы написали ключевое слово
\In{module} перед экспортируемым модулем. Теперь если
мы в каком-нибудь другом модуле импортируем модуль \In{Types}
нам станут доступными все функции из этих модулей.

Мы определили экземпляры для \In{Functor} и \In{Applicative}
с помощью производных функций класса \In{Monad}.

\section{Случайные числа}

С помощью монады \In{State} можно имитировать
    случайные числа. Мы будем генерировать случайные
    числа из интервала от 0 до 1 с помощью алгоритма:
    
\begin{code}
nextRandom :: Double -> Double
nextRandom = snd . properFraction . (105.947 * )
\end{code}

Функция \In{properFraction} возвращает пару, которая 
состоит из целой части и остатка числа. Взяв второй элемент пары с помощью 
\In{snd}, мы выделяем остаток. 
Функция \In{nextRandom} представляет собой генератор
случайных чисел, который принимает значение с предыдущего шага
и строит по нему следующее значение.

Построим тип для случайных чисел:

\begin{code}
type Random a = State Double a

next :: Random Double
next = State $ \s -> (s, nextRandom s)
\end{code}

Теперь определим функцию, которая прибавляет к
данному числу случайное число из интервала
от 0 до 1:

\begin{code}
addRandom :: Double -> Random Double
addRandom x = fmap (+x) next 
\end{code}

Посмотрим как эта функция работает в интерпретаторе:

\begin{code}
*Random> runState (addRandom 5) 0.5
(5.5,0.9735000000000014)
*Random> runState (addRandom 5) 0.7
(5.7,0.16289999999999338)
*Random> runState (mapM addRandom [1 .. 5]) 0.5
([1.5,2.9735000000000014,3.139404500000154,4.769488561516319,
 5.5250046269694195],0.6226652135290891)
\end{code}

В последней строчке мы с помощью функции \In{mapM} 
прибавили ко всем элементам списка разные случайные
числа, обновление счётчика происходило за кадром,
с помощью функции \In{mapM} и экземпляра \In{Monad}
для \In{State}.

Также мы можем определить функцию, которая складывает
два случайных числа, одно из интервала \In{[-1+a, 1+a]},
а другое из интервала \In{[-2+b,2+b]}:

\begin{code}
addRandom2 :: Double -> Double -> Random Double
addRandom2 a b = liftA2 add next next
    where add  a b = \x y -> diap a 1 x + diap b 1 y
          diap c r = \x   -> x * 2 * r - r + c
\end{code}

Функция \In{diap} перемещает интервал от 0 до 1
в интервал от \In{c-r} до \In{c+r}. Обратите внимание
на то как мы сначала составили обычную функцию
\In{add}, которая перемещает значения из интервала
от 0 до 1 в нужный диапазон и складывает. И только
в самый последний момент мы применили к этой функции
случайные значения. Посмотрим как работает эта функция:

\begin{code}
*Random> runState (addRandom2 0 10) 0.5
(10.947000000000003,0.13940450000015403)
*Random> runState (addRandom2 0 10) 0.7
(9.725799999999987,0.2587662999992979)
\end{code}

Прибавим два списка и получим сумму:

\begin{code}
*Random> let res = fmap sum $ zipWithM addRandom2 [1..3] [11 .. 13]
*Random> runState res 0.5
(43.060125804029965,0.969511377766409)
*Random> runState res 0.7
(39.86034841613788,0.26599261421101517)
\end{code}

Функция \In{zipWithM} является аналогом функции \In{zipWith}.
Она устроена также как и функция \In{mapM}, сначала применяется
обычная функция \In{zipWith}, а затем функция \In{sequence}.

С помощью типа \In{Random} мы можем определить 
функцию подбрасывания монетки:

\begin{code}
data Coin = Heads | Tails
    deriving (Show)

dropCoin :: Random Coin
dropCoin = fmap drop' next
    where drop' x 
            | x < 0.5   = Heads
            | otherwise = Tails                    
\end{code}

У монетки две стороны орёл (\In{Heads}) и решка (\In{Tails}).
Поскольку шансы на выпадание той или иной стороны равны, мы 
для определения стороны разделяем интервал от 0 до 1 в равных
пропорциях.

Подбросим монетку пять раз:

\begin{code}
*Random> let res = sequence $ replicate 5 dropCoin
\end{code}

Функция \In{replicate n a} составляет список из
\In{n} повторяющихся элементов \In{a}.
Посмотрим что у нас получилось:

\begin{code}
*Random> runState res 0.4
([Heads,Heads,Heads,Heads,Tails],0.5184926967068364)
*Random> runState res 0.5
([Tails,Tails,Heads,Tails,Tails],0.6226652135290891)
\end{code}


\section{Конечные автоматы}

С помощью монады \In{State} можно описывать
конечные автоматы (finite-state machine). Конечный автомат находится
в каком-то начальном состоянии. Он принимает
на вход ленту событий. Одно событие происходит за другим. 
На каждое событие автомат реагирует переходом из
одного состояния в другое. 

\begin{code}
type FSM s = State s s

fsm :: (ev -> s -> s) -> (ev -> FSM s)
fsm transition = \e -> State $ \s -> (s, transition e s)
\end{code}

Функция \In{fsm} принимает функцию переходов состояний
\In{transition}
и возвращает функцию, которая принимает состояние и
возвращает конечный автомат.
В качестве значения конечный автомат \In{FSM} будет
возвращать текущее состояние.

С помощью конечных автоматов можно описывать
различные устройства. Лентой событий будет
ввод пользователя (нажатие на кнопки, включение/выключение
питания). 

Приведём простой пример. Рассмотрим колонки, у них
есть розетка, кнопка вкл/выкл и регулятор громкости. 
Возможные состояния:

\begin{code}
type Speaker = (SpeakerState, Level)

data SpeakerState = Sleep | Work
    deriving (Show)

data Level  = Level Int
    deriving (Show)
\end{code}

Тип колонок складывается из двух значений:
состояния и уровня громкости.
Колонки могут быть выключенными (\In{Sleep}) или
работать на определённой громкости (\In{Work}).
Считаем, что максимальный уровень громкости составляет
10 единиц, а минимальный ноль единиц. Границы диапазона 
громкости описываются такими функциями:

\begin{code}
quieter :: Level -> Level
quieter (Level n) = Level $ max 0 (n-1)

louder :: Level -> Level
louder (Level n) = Level $ min 10 (n+1)
\end{code}

Мы будем обновлять значения уровня громкости не напрямую,
а с помощью вспомогательных функций \In{louder} и \In{quieter}.
Так мы не сможем выйти за пределы заданного диапазона.

Возможные события:

\begin{code}
data User = Button | Quieter | Louder
    deriving (Show)
\end{code}

Пользователь может либо нажать на кнопку вкл/выкл или повернуть
реле громкости влево, чтобы приглушить звук (\In{Quieter}) 
или вправо, чтобы сделать погромче (\In{Louder}). Будем считать,
что колонки всегда включены в розетку.

Составим функцию переходов:

\begin{code}
speaker :: User -> FSM Speaker
speaker = fsm $ trans
    where trans Button    (Sleep, n) = (Work, n)
          trans Button    (Work,  n) = (Sleep, n)
          trans Louder    (s,     n) = (s, louder n)
          trans Quieter   (s,     n) = (s, quieter n)
\end{code}

Мы считаем, что при выключении колонок реле остаётся 
некотором положении, так что при следующем включении
они будут работать на той же громкости. Реле можно крутить
и в состоянии \In{Sleep}.
Посмотрим на типичную сессию работы колонок:

\begin{code}
*FSM> let res = mapM speaker [Button, Louder, Quieter, Quieter, Button] 
\end{code}

Сначала мы включаем колонки, затем прибавляем громкость, 
затем дважды делаем тише и в конце выключаем. Посмотрим что получилось:


\begin{code}
*FSM> runState res (Sleep, Level 2)
([(Sleep,Level 2),(Work,Level 2),(Work,Level 3),(Work,Level 2),
 (Work,Level 1)],(Sleep,Level 1))
*FSM> runState res (Sleep, Level 0)
([(Sleep,Level 0),(Work,Level 0),(Work,Level 1),(Work,Level 0),
 (Work,Level 0)],(Sleep,Level 0))
\end{code}

Смотрите, изменив начальное значение, мы изменили
весь список значений.
Обратите внимание на то, что во втором прогоне мы не ушли в минус
по громкости, не смотря на то, что пытались крутить реле за 
установленный предел.

Определим колонки другого типа. Наши новые колонки
будут безопаснее предыдущих. Представьте ситуацию, что 
мы выключили колонки на высоком уровне громкости.
Мы слушали домашнюю запись с низким уровнем звука.
Мы выключили и забыли. Потом мы решили послушать 
другую мелодию, которая записана с нормальным уровнем
звука. При включении колонок нас оглушил шквал звука.
Чтобы этого избежать мы решили воспользоваться 
другими колонками.

Колонки при выключении будут выставлять уровень 
громкости на ноль и реле можно будет крутить
только если колонки включены.


\begin{code}
safeSpeaker :: User -> FSM Speaker
safeSpeaker = fsm $ trans
    where trans Button  (Sleep, _) = (Work,  Level 0)
          trans Button  (Work,  _) = (Sleep, Level 0)
          trans Quieter (Work,  n) = (Work,  quieter n)
          trans Louder  (Work,  n) = (Work,  louder n)
          trans _       (Sleep, n) = (Sleep, n)
\end{code}

При нажатии на кнопку вкл/выкл уровень громкости выводится
в положение 0. Колонки реагируют на запросы изменения
уровня громкости только в состоянии \In{Work}. Посмотрим
как работают наши новые колонки:

\begin{code}
*FSM> let res = mapM safeSpeaker [Button, Louder, Quieter, Button, Louder]
\end{code}

Мы включаем колонки, делаем по-громче, затем по-тише, затем
выключаем и пытаемся изменить громкость после выключения.
Посмотрим как они сработают, представим, что мы выключили
колонки на уровне громкости \In{10}:

\begin{code}
*FSM> runState res (Sleep, Level 10)
([(Sleep,Level 10),(Work,Level 0),(Work,Level 1),(Work,Level 0),
 (Sleep,Level 0)],(Sleep,Level 0))
\end{code}

Первое значение в списке является стартовым состоянием, которое
мы задали. После этого колонки включаются и мы видим, что
уровень громкости переключился на ноль. Затем мы увеличиваем 
громкость, сбавляем её и выключаем. Попытка изменить 
громкость выключенных колонок не проходит. Это видно
по последнему элементу списка и итоговому состоянию колонок,
которое находится во втором элементе пары.

Предположим, что колонки работают с самого начала, тогда
первым действием мы выключаем их. Посмотрим, что случится
дальше:

\begin{code}
*FSM> runState res (Work, Level 10)
([(Work,Level 10),(Sleep,Level 0),(Sleep,Level 0),(Sleep,Level 0),
 (Work,Level 0)],(Work,Level 1))
\end{code}

Дальше мы пытаемся изменить громкость но у нас ничего не выходит.

\section{Отложенное вычисление выражений}

В этом примере мы будем выполнять арифметические
операции на целых числах. Мы будем их складывать, вычитать и 
умножать. Но вместо того, чтобы сразу вычислять выражения
мы будем составлять их описание. Мы будем кодировать
операции конструкторами. 

\begin{code}
data Exp    = Var String
            | Lit Int
            | Neg Exp
            | Add Exp Exp
            | Mul Exp Exp
            deriving (Show, Eq)
\end{code}

У нас есть тип \In{Exp}, который может быть либо переменной
\In{Var} с данным строчным именем, либо целочисленной константой \In{Lit},
либо одной из трёх операций: вычитанием (\In{Neg}), сложением (\In{Add})
или умножением (\In{Mul}).

Такие типы называют \emph{абстрактными синтаксическими деревьями} 
(abstract syntax tree, AST). Они содержат описание выражений.
Теперь вместо того чтобы сразу проводить
вычисления мы будем собирать выражения в значении типа \In{Exp}.
Сделаем экземпляр для \In{Num}:

\begin{code}
instance Num Exp where
    negate  = Neg
    (+)     = Add
    (*)     = Mul

    fromInteger = Lit . fromInteger

    abs     = undefined
    signum  = undefined
\end{code}

Также определим вспомогательные функции для обозначения
переменных: 

\begin{code}
var :: String -> Exp
var = Var

n :: Int -> Exp
n = var . show
\end{code}

Функция \In{var} составляет переменную с данным именем,
а функция \In{n} составляет переменную, у которой имя
является целым числом. Сохраним эти определения в модуле \In{Exp}.
Теперь у нас всё готово для составления выражений:

\begin{code}
*Exp> n 1
Var "1"
*Exp> n 1 + 2
Add (Var "1") (Lit 2)
*Exp> 3 * (n 1 + 2)
Mul (Lit 3) (Add (Var "1") (Lit 2))
*Exp> - n 2 * 3 * (n 1 + 2)
Neg (Mul (Mul (Var "2") (Lit 3)) (Add (Var "1") (Lit 2)))
\end{code}

Теперь давайте создадим функцию для вычисления таких выражений.
Она будет принимать выражение и возвращать целое число.

\begin{code}
eval :: Exp -> Int
eval (Lit n)    = n
eval (Neg n)    = negate $ eval n
eval (Add a b)  = eval a + eval b
eval (Mul a b)  = eval a * eval b
eval (Var name) = ???
\end{code}

Как быть с конструктором \In{Var}? Нам нужно откуда-то
узнать какое значение связано с переменной. Функция
\In{eval} должна также принимать набор значений
для всех переменных, которые используются в выражении. 
Этот набор значений мы будем называть окружением.

Обратите внимание на то, что в каждом составном конструкторе
мы рекурсивно вызываем функцию \In{eval}, мы словно обходим
всё дерево выражения. Спускаемся вниз, до самых листьев
в которых расположены либо значения (\In{Lit}), либо переменные
(\In{Var}). Нам было бы удобно иметь возможность пользоваться
окружением из любого узла дерева. В этом нам поможет тип
\In{Reader}.

Представим что у нас есть значение типа \In{Env} и функция,
которая позволяет читать значения переменных по имени:

\begin{code}
value :: Env -> String -> Int
\end{code}

Теперь определим функцию \In{eval}:

\begin{code}
eval :: Exp -> Reader Env Int
eval (Lit n)    = pure n
eval (Neg n)    = liftA  negate $ eval n
eval (Add a b)  = liftA2 (+) (eval a) (eval b)
eval (Mul a b)  = liftA2 (*) (eval a) (eval b)
eval (Var name) = Reader $ \env -> value env name 
\end{code}

Определение сильно изменилось, оно стало не таким
наглядным. Теперь значение \In{eval} стало специальным,
поэтому при рекурсивном вызове функции \In{eval} нам
приходится поднимать в мир специальных функций
обычные функции вычитания, сложения
и умножения. Мы можем записать это выражение  
немного по другому:

\begin{code}
eval :: Exp -> Reader Env Int
eval (Lit n)    = pure n
eval (Neg n)    = negateA $ eval n
eval (Add a b)  = eval a `addA` eval b
eval (Mul a b)  = eval a `mulA` eval b
eval (Var name) = Reader $ \env -> value env name    
   
addA      = liftA2 (+)
mulA      = liftA2 (*)  
negateA   = liftA negate  
\end{code}

\subsection{Тип Map}

\Types{Map, ассоциативные массивы}
Для того чтобы закончить определение функции \In{eval}
нам нужно определить тип \In{Env} и функцию \In{value}.
Для этого мы воспользуемся типом \In{Map}, он предназначен
для хранения значений по ключу. 

Этот тип живёт в стандартном модуле \In{Data.Map}. 
Посмотрим на его описание:

\begin{code}
data Map k a = ..
\end{code}

Первый параметр типа \In{k} это ключ, а второй это значение.
Мы можем создать значение типа \In{Map} из списка пар
ключ значение с помощью функции \In{fromList}.

Посмотрим на основные функции:

\begin{code}
-- Создаём значения типа Map                    -- создаём  
empty :: Map k a                                -- пустой Map
fromList :: Ord k => [(k, a)] -> Map k a        -- по списку (ключ, значение)

-- Узнаём значение по ключу
(!)     :: Ord k => Map k a -> k -> a           
lookup  :: Ord k => k -> Map k a -> Maybe a

-- Добавляем элементы
insert :: Ord k => k -> a -> Map k a -> Map k a

-- Удаляем элементы
delete :: Ord k => k -> Map k a -> Map k a
\end{code}

Обратите внимание на ограничение \In{Ord k} в этих функциях,
ключ должен быть экземпляром класса \In{Ord}.
Посмотрим как эти функции работают:

\begin{code}
*Exp> :m +Data.Map
*Exp Data.Map> :m -Exp
Data.Map> let v = fromList [(1, "Hello"), (2, "Bye")]
Data.Map> v ! 1
"Hello"
Data.Map> v ! 3
"*** Exception: Map.find: element not in the map
Data.Map> lookup 3 v
Nothing
Data.Map> let v1 = insert 3 "Yo" v
Data.Map> v1 ! 3
"Yo"
\end{code}

Функция \In{lookup} является стабильным аналогом 
функции \In{!}. В том смысле, что она определена 
с помощью \In{Maybe}. Она не приведёт к падению программы,
если для данного ключа не найдётся значение.

Теперь мы можем определить функцию \In{value}:

\begin{code}
import qualified Data.Map as M(Map, lookup, fromList)

...

type Env = M.Map String Int

value :: Env -> String -> Int
value env name = maybe errorMsg $ M.lookup env name 
    where errorMsg = error $ "value is undefined for " ++ name
\end{code}

Обычно функции из модуля \In{Data.Map} включаются
с директивой \In{qualified}, поскольку имена многих
функций из этого модуля совпадают с именами из 
модуля \In{Prelude}. Теперь все определения из модуля
\In{Data.Map} пишутся с приставкой \In{M.}.

Создадим вспомогательную функцию, которая 
упростит вычисление выражений:

\begin{code}
runExp :: Exp -> [(String, Int)] -> Int
runExp a env = runReader (eval a) $ M.fromList env
\end{code}

Сохраним определение новых функций 
в модуле \In{Exp}. И посмотрим что у нас получилось:

\begin{code}
*Exp> let env a b = [("1", a), ("2", b)]
*Exp> let exp = 2 * (n 1 + n 2) - n 1
*Exp> runExp exp (env 1 2)
5
*Exp> runExp exp (env 10 5)
20
\end{code}

Так мы можем пользоваться функциями
с окружением для того, чтобы читать значения из
общего источника. Впрочем мы можем просто 
передавать окружение дополнительным
аргументом и не пользоваться монадами:

\begin{code}
eval :: Env -> Exp -> Int
eval env x = case x of
    Lit n       -> n
    Neg n       -> negate $ eval' n
    Add a b     -> eval' a + eval' b
    Mul a b     -> eval' a + eval' b
    Var name    -> value env name
    where eval' = eval env
\end{code}

\section{Накопление результата}

Рассмотрим по-подробнее тип \In{Writer}. Он выполняет
задачу обратную к типу \In{Reader}. Когда мы пользовались
типом \In{Reader}, мы могли в любом месте функции извлекать
данные из окружения. Теперь же мы будем не извлекать данные
из окружения, а записывать их. 

Рассмотрим такую задачу нам нужно обойти дерево типа \In{Exp}
и подсчитать все бинарные операции. Мы прибавляем к накопителю
результата единицу за каждый конструктор \In{Add} или \In{Mul}.
Тип сообщений будет числом. Нам нужно сделать
экземпляр класса \In{Monoid} для чисел. 

Напомню, что тип накопителя должен быть экземпляром класса
\In{Monoid}:

\begin{code}
class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a

    mconcat :: [a] -> a
    mconcat = foldr mappend mempty
\end{code}


Но для чисел возможно несколько вариантов, которые удовлетворяют
свойствам. Для сложения:

\begin{code}
instance Num a => Monoid a where
    mempty  = 0
    mappend = (+)
\end{code}

И умножения:

\begin{code}
instance Num a => Monoid a where
    mempty  = 1
    mappend = (*)
\end{code}

Для нашей задачи подойдёт первый вариант, но не
исключена возможность того, что для другой задачи
нам понадобится второй. Но тогда мы уже не сможем
определить такой экземпляр. Для решения этой проблемы
в модуле \In{Data.Monoid} определено два типа обёртки:

\begin{code}
newtype Sum  a = Sum  { getSum  :: a }
newtype Prod a = Prod { getProd :: a }
\end{code}

В этом определении есть два новых элемента.
Первый это ключевое слово \KeyWord{newtype} \In{newtype}, а второй
это фигурные скобки. Что всё это значит?


\subsection{Тип-обёртка newtype}

Ключевое слово \In{newtype} вводит новый тип-обёртку.
Тип-обёртка может иметь только один конструктор, у
которого лишь одни аргумент. Запись:

\begin{code}
newtype Sum a = Sum a
\end{code}

Это тоже самое, что и 

\begin{code}
data Sum a = Sum a
\end{code}

Единственное отличие заключается в том, что
в случае \In{newtype} вычислитель не видит 
разницы между \In{Sum a} и \In{a}. Её видит
лишь компилятор. Это означает, что на разворачивание
и заворачивание такого значения в тип обёртку 
не тратится никаких усилий. Такие типы подходят для решения двух задач:


\begin{itemize}
\item Более точная проверка типов.

Например у нас есть типы, которые описывают
физические величины, все они являются числами,
но у них также есть и размерности. Мы можем написать:

\begin{code}
type Velocity   = Double
type Time       = Double
type Length     = Double

velocity :: Length -> Time -> Velocity
velocity leng time = leng / time
\end{code}

В этом случае мы спокойно можем подставить на
место времени путь и наоборот. Но с помощью
типов обёрток мы можем исключить эти случаи:

\begin{code}
newtype Velocity   = Velocity   Double
newtype Time       = Time       Double
newtype Length     = Length     Double

velocity :: Length -> Time -> Velocity
velocity (Length leng) (Time time) = Velocity $ leng / time
\end{code}

В этом случае мы проводим проверку по размерностям,
компилятор не допустит смешивания данных.


\item Определение нескольких экземпляров одного класса
        для одного типа. Этот случай мы как раз и рассматриваем
        для класса \In{Monoid}. Нам нужно сделать два
        экземпляра для одного и того же типа \In{Num a => a}.

        Сделаем две обёртки! 

\begin{code}
newtype Sum  a = Sum  a
newtype Prod a = Prod a
\end{code}

Тогда мы можем определить два экземпляра для двух
разных типов:

Один для \In{Sum}:

\begin{code}
instance Num a => Monoid (Sum a) where
    mempty  = Sum 0
    mappend (Sum a) (Sum b) = Sum (a + b)
\end{code}

А другой для \In{Prod}:

\begin{code}
instance Num a => Monoid (Prod a) where
    mempty  = Prod 1
    mappend (Prod a) (Prod b) = Prod (a * b)
\end{code}

\end{itemize}

\subsection{Записи}

Вторая новинка заключалась в фигурных скобках. 
С помощью фигурных скобок в Haskell обозначаются 
\emph{записи} (records). Запись это произведение
типа, но с выделенными именами для полей.

Например мы можем сделать тип для описания паспорта:

\begin{code}
data Passport   = Person {
    surname         :: String,      -- Фамилия
    givenName       :: String,      -- Имя
    nationality     :: String,      -- Национальность
    dateOfBirth     :: Date,        -- Дата рождения
    sex             :: Bool,        -- Пол
    placeOfBirth    :: String,      -- Место рождения
    authority       :: String,      -- Место выдачи документа
    dateOfIssue     :: Date,        -- Дата выдачи
    dateOfExpiry    :: Date         -- Дата окончания срока
    } deriving (Eq, Show)           --      действия

data Date   = Date {
                day     :: Int,
                month   :: Int,
                year    :: Int
              } deriving (Show, Eq)
\end{code}

В фигурных скобках через запятую мы указываем поля. 
Поле состоит из имени и типа. Теперь нам доступны
две операции:

\begin{itemize}
\item Чтение полей

\begin{code}
hello :: Passport -> String
hello p = "Hello, " ++ givenName p ++ "!"
\end{code}

Для чтения мы просто подставляем в имя 
поля данное значение. В этой функции мы приветствуем
человека и обращаемся к нему по имени. Для того, чтобы
узнать его имя мы подсмотрели в паспорт, в поле 
\In{givenName}.

\item Обновление полей. Для обновления полей
мы пользуемся таким синтаксисом:

\begin{code}
value { fieldName1 = newValue1, fieldName2 = newValue2, ... }
\end{code}

Мы присваиваем в значении \In{value} полю с именем
\In{fieldName} новое значение \In{newFieldValue}.
К примеру продлим срок действия паспорта на десять лет:

\begin{code}
prolongate :: Passport -> Passport 
prolongate p = p{ dateOfExpiry = newDate }
    where newDate = oldDate { year = year oldDate + 10 }
          oldDate = dateOfExpiry p      
\end{code}

\end{itemize}


Вернёмся к типам \In{Sum} и \In{Prod}:

\begin{code}
newtype Sum  a = Sum  { getSum  :: a }
newtype Prod a = Prod { getProd :: a }
\end{code}

Этой записью мы определили два типа-обёртки.
У нас есть две функции, которые заворачивают
обычное значение, это \In{Sum} и \In{Prod}.
С помощью записей мы тут же в определении типа
определили функции которые разворачивают значения, 
это \In{getSum} и \In{getProd}.

Вспомним определение для типа \In{State}:

\begin{code}
data State s a = State (s -> (a, s))

runState :: State s a -> (s -> (a, s))
runState (State f) = f
\end{code}

Было бы гораздо лучше определить его так:

\begin{code}
newtype State s a = State{ runState :: s -> (a, s) }
\end{code}

\subsection{Накопление чисел}

Но вернёмся к нашей задаче. Мы будем накапливать
сумму в значении типа \In{Sum}. Поскольку нас интересует
лишь значение накопителя, наша функция будет
возвращать значение единичного типа \In{()}. 

\begin{code}
countBiFuns :: Exp -> Int
countBiFuns = getSum . execWriter . countBiFuns'

countBiFuns' :: Exp -> Writer (Sum Int) ()
countBiFuns' x = case x of
    Add a b -> tell (Sum 1) *> bi a b
    Mul a b -> tell (Sum 1) *> bi a b
    Neg a   -> un a
    _       -> pure ()
    where bi a b = countBiFuns' a *> countBiFuns' b  
          un     = countBiFuns'

tell :: Monoid a => a -> Writer a () 
tell a = Writer ((), a)

execWriter :: Writer msg a -> msg
execWriter (Writer (a, msg)) = msg
\end{code}

Первая функция \In{countBiFuns} извлекает значение
из типов \In{Writer} и \In{Sum}. А вторая функция
\In{countBiFuns'} вычисляет значение.

Мы определили две вспомогательные функции \In{tell}, которая
записывает сообщение в накопитель и \In{execWriter}, 
которая возвращает лишь сообщение. Это стандартные для
\In{Writer} функции.

Посмотрим как работает эта функция:

\begin{code}
*Exp> countBiFuns (n 2)
0
*Exp> countBiFuns (n 2 + n 1 + 2 + 3)
3
\end{code}

\subsection{Накопление логических значений}

В модуле \In{Data.Monoid} определены два типа для 
накопления логических значений. Это типы \In{All} 
и \In{Any}. С помощью типа \In{All} мы можем проверить
выполняется ли некоторое свойство для всех значений. 
А с помощью типа \In{Any} мы можем узнать, что существует хотя
бы один элемент, для которых это свойство выполнено.

Посмотрим на определение экземпляров класса \In{Monoid}
для этих типов:

\begin{code}
newtype All = All { getAll :: Bool }

instance Monoid All where
        mempty = All True
        All x `mappend` All y = All (x && y)
\end{code}

В типе \In{All} мы накапливаем значения с помощью 
логического \Quote{и}. Нейтральным элементом является
конструктор \In{True}. Итоговое значение накопителя будет
равно \In{True} только в том случае, если все накапливаемые
сообщения были равны \In{True}.

В типе \In{Any} всё наоборот:

\begin{code}
instance Monoid Any where
        mempty = Any False
        Any x `mappend` Any y = Any (x || y)
\end{code}

Посмотрим как работают эти типы. Составим функцию,
которая проверяет отсутствие оператора минус в выражении:

\begin{code}
noNeg :: Exp -> Bool
noNeg = not . getAny . execWriter . anyNeg

anyNeg :: Exp -> Writer Any ()
anyNeg x = case x of
    Neg _   -> tell (Any True)
    Add a b -> bi a b
    Mul a b -> bi a b
    _       -> pure ()
    where bi a b = anyNeg a *> anyNeg b            
\end{code}

Функция \In{anyNeg} проверяет есть ли в выражении 
хотя бы один конструктор \In{Neg}. В функции \In{noNeg}
мы извлекаем результат и берём его отрицание, чтобы
убедиться в том что в выражении не встретилось ни одного
конструктора \In{Neg}. 

\begin{code}
*Exp> noNeg (n 2 + n 1 + 2 + 3)
True
*Exp> noNeg (n 2 - n 1 + 2 + 3)
False
\end{code}

\subsection{Накопление списков}

Экземпляр класса \In{Monoid} определён и для списков.
Предположим у нас есть дерево, в каждом узле которого
находятся числа, давайте соберём все числа больше 5, но
меньше 10. Деревья мы возьмём из модуля \In{Data.Tree}:

\begin{code}
data Tree a   = Node {
		rootLabel :: a,		    -- значение метки
		subForest :: Forest a	-- ноль или несколько дочерних деревьев
	}

type Forest a = [Tree a]
\end{code}

Интересный тип. Тип \In{Tree} определён через \In{Forest}, 
а \In{Forest} определён через \In{Tree}. По этому типу мы видим,
что каждый узел содержит некоторое значение типа \In{a}, 
и список дочерних деревьев. 

Составим дерево:

\begin{code}
*Exp> :m Data.Tree
Prelude Data.Tree> let t a = Node a []
Prelude Data.Tree> let list a = Node a []
Prelude Data.Tree> let bi v a b = Node v [a, b]
Prelude Data.Tree> let un v a   = Node v [a]
Prelude Data.Tree> 
Prelude Data.Tree> let tree1 = bi 10 (un 2 $ un 6 $ list 7) (list 5)
Prelude Data.Tree> let tree2 = bi 12 tree1 (bi 8 tree1 tree1)
\end{code}

Теперь составим функцию, которая будет обходить дерево,
и собирать числа из заданного диапазона:

\begin{code}
type Diap a = (a, a)

inDiap :: Ord a => Diap a -> Tree a -> [a]
inDiap d = execWriter . inDiap' d

inDiap' :: Ord a => Diap a -> Tree a -> Writer [a] ()
inDiap' d (Node v xs) = pick d v *> mapM_ (inDiap' d) xs 
    where pick (a, b) v
            | (a <= v) && (v <= b)  = tell [v]
            | otherwise             = pure ()
\end{code}

Как и раньше у нас две функции, одна выполняет вычисления,
другая извлекает результат из \In{Writer}. В функции 
\In{pick} мы проверяем число на принадлежность интервалу, если
это так мы добавляем число к результату, а если нет пропускаем
его, добавляя нейтральный элемент (в функции \In{pure}). 
Обратите внимание на то как мы обрабатываем список дочерних 
поддервьев. Функция \In{mapM_} является аналогом функции \In{mapM},
Она используется, если результат функции не важен, а важны
те действия, которые происходят при преобразовании списка.
В нашем случае это накопление результата. Посмотрим на определение
этой функции:

\begin{code}
mapM_ :: Monad m => (a -> m b) ->  [a] -> m ()
mapM_ f = sequence_ . map f

sequence_ :: Monad m => [m a] -> m ()
sequence_ = foldr (>>) (return ())
\end{code}

Основное отличие состоит в функции \In{sequence_}. Раньше
мы собирали значения в список, а теперь отбрасываем их
с помощью константной функции \verb!>>!. В конце мы возвращаем
значение единичного типа \In{()}. 

Теперь сохраним в модуле \In{Tree} определение функции и
вспомогательные функции создания деревьев \In{un}, \In{bi},
и \In{list} и посмотрим как наша функция работает:

\begin{code}
*Tree> inDiap (4, 10) tree2
[10,6,7,5,8,10,6,7,5,10,6,7,5]
*Tree> inDiap (5, 8) tree2
[6,7,5,8,6,7,5,6,7,5]
*Tree> inDiap (0, 3) tree2
[2,2,2]
\end{code}

\section{Монада изменяемых значений ST}

Возможно читатели, для которых \Quote{родным} является
один из императивных языков, немного заскучали по изменяемым
значениям. Мы говорили, что в Haskell ничего не изменяется,
мы даём всё более и более сложные имена статическим значениям,
а потом вычислитель редуцирует имена к настоящим значениям.
Но есть алгоритмы, которые очень элегантно описываются в терминах
изменяемых значений. Примером такого алгоритма может быть
быстрая сортировка. Задача состоит в перестановке элементов
массива так, чтобы на выходе любой последующий элемент массива 
был больше предыдущего (для списков эту задачу решают функции
\In{sort} и \In{sortBy}).  

Само по себе явление обновления значения является побочным
эффектом. Оно ломает представление о статичности мира,
у нас появляются фазы: до обновления и после обновления. 
Но представьте, что обновление происходит локально, 
мы постоянно меняем только одно значение, при этом за
время обновления ни одна другая переменная \emph{не может}
пользоваться промежуточными значениями и обновления происходят
с помощью \emph{чистых} функций. Представьте функцию, 
которая принимает значение, выделяет внутри себя память,
и при построении результата начинает обновлять значение 
внутри этой памяти (с помощью чистых функций) и считать 
что-то ещё полезное на основе этих обновлений, как только 
вычисления закончатся, память стирается, и возвращается
значение. Будет ли такая функция чистой? Интуиция
подсказывает, что да. Это было доказано, но для реализации 
этого требуется небольшой трюк на уровне типов. 
Получается, что не смотря на то, что функция содержит 
побочные эффекты, она является чистой, поскольку 
все побочные эффекты локальны, они происходят только 
внутри вызова функции и только в самой функции.

Для симуляции обновления значения в Haskell
нам нужно решить две проблемы. Как упорядочить обновление 
значения? И как локализовать его? В имеративных
языках порядок вычисления выражений строго связон с порядком
следования выражений, на примитвном уровне, грубо упрощая,
можно сказать, что вычислитель читает код как ленту
и выполняет выражение за выражением. В Haskell всё совсем
по-другому. Мы можем писать функции в любом порядке, также
в любом порядке мы можем объявлять локальные переменные в
\In{where} или \In{let}-выражениях. Компилятор определяет
порядок редукции синонимов по функциональным зависимостям. 
Синоним \In{f} не будет раскрыт раньше синонима \In{g}
только в том случае, если результат \In{g} требуется в \In{f}.
Но с обновлением значения этот вариант не пройдёт, посмотрим
на выражение:

\begin{code}
fun :: Int -> Int
fun arg = 
    let mem = new arg
        x   = read mem
        y   = x + 1
        ??  = write mem y
        z   = read mem
    in z
\end{code}

Предполагается, что в этой функции мы получаем значение \In{arg},
выделяем память \In{mem} c помощью специальной функции 
\In{new}, которая принимает начальное значение,
которое будет храниться в памяти. 
Затем читаем из памяти, прибавляем к значению единицу, снова
записываем в память, потом опять читаем из памяти, сохранив
значение в переменной \In{z}, и в самом конце возвращаем ответ. 
Налицо две проблемы:
\In{z} не зависит от \In{y}, поэтому мы можем считать 
значение \In{z} в любой момент после инициализации памяти и
вторая проблема: что должна возвращть функция \In{write}?

Для того чтобы упорядочить эти вычисления мы воспользуемся
типом \In{State}. Каждое выражение будет принимать фиктивное
состояние и возвращать его. Тогда функция \In{fun} запишется так:

\begin{code}
fun :: Int -> State s Int
fun arg = State $ \s0 -> 
    let (mem, s1)   = runState (new arg)          s0
        ((),  s2)   = runState (write mem arg)    s1
        (x,   s3)   = runState (read mem)         s2
        y           = x + 1
        ((),  s4)   = runState (write mem y)      s3
        (z,   s5)   = runState (read mem)         s4
    in (z, s5)

new     :: a -> State s (Mem a)
write   :: Mem a -> a -> State s ()
read    :: Mem a -> State s a
\end{code}

Тип \In{Mem} параметризован типом значения, которое хранится в памяти. 
В этом варианте мы не можем изменить порядок следования
выражений, поскольку нам приходится передовать состояние.
Мы могли бы записать это выражение гораздо короче с помощью
методов класса \In{Monad}, но мне хотелось подчеркнуть как
передача состояния навязывает порядок вычисления. 
Функция \In{write} теперь возвращает пустой кортеж. 
Но порядок не теряется за счёт состояния. Пустой кортеж
намекает на то, что единственное назначение функции
\In{write} -- это обновление состояния. 

Однако этого не достаточно. Мы хотим, чтобы обновление
значения было скрыто от пользователя в \emph{чистой} функции.
Мы хотим, чтобы тип функции \In{fun} не содержал типа \In{State}.
Для этого нам откуда-то нужно взять начальное значение состояния. 
Мы можем решить эту проблему, зафиксировав тип \In{s}.
Пусть это будет тип \In{FakeState}, скрытый от пользователя.

\begin{code}
module Mutable(
    Mutable, Mem, purge, 
    new, read, write)
where

newtype Mutable a = Mutable (State FakeState a)

data FakeState = FakeState

purge :: Mutable a -> a
purge (Mutable a) = fst $ runState a FakeState

new     :: a -> Mutable (Mem a)
read    :: Mem a -> Mutable a
write   :: Mem a -> a -> Mutable ()
\end{code}

Мы предоставим пользователю лишь тип \In{Mutable} без
конструктора и функцию \In{purge}, которая \Quote{очищает}
значение от побочных эффектов и примитивные функции
для работы с памятью. Также мы определим экземпляры 
классов типа \In{State} для \In{Mutable}, сделать это
будет совсем не трудно, ведь \In{Mutable} -- это просто обёртка.
С помощью этих экземпляров пользователь сможет комбинировать
вычисления, которые связаны с изменением памяти. 
Пока вроде всё хорошо, но обеспчиваем ли мы локальность
изменения значений? Нам важно, чтобы, один раз начав работать
с памятью типа \In{Mem}, мы не смогли бы нигде воспользоваться
этой памятью после выполнения функции \In{purge}. 
Оказывается, что мы можем разрушить локальность. Посмотрите 
на пример:

\begin{code}
let mem = purge allocate
in  purge (read mem)
\end{code}

Мы возвращаем из функции \In{purge} ссылку на память
и спокойно пользуемся ею в другой ветке \In{Mutable}-вычислений.
Можно ли этого избежать? Оказывается, что можно. 
Причём решение весьма элегантно. Мы можем построить типы
\In{Mem} и \In{Mutable} так, чтобы ссылке на память н удалось
просочиться через функцию \In{purge}. Для этого мы вернёмся
к общему типу \In{State} c двумя параметрами. Причём
первый первый параметр мы прицепим и к \In{Mem}:

\begin{code}
data    Mem     s a = ..
newtype Mutable s a = ..

new     :: a -> Mutable s (Mem s a)
write   :: Mem s a -> a -> Mutable s ()
read    :: Mem s a -> Mutable s a
\end{code}

Теперь при создании типы \In{Mem} и \In{Mutable} связаны общим
параметром \In{s}. Посмотрим на тип функции \In{purge}

\begin{code}
purge :: (forall s. Mutable s a) -> a
\end{code}

Она имеет необычный тип. Слово \In{forall} 
означает \Quote{для любых}. Это слово называют квантором
всеобщности. Этим мы говорим, что функция извлечения
значения не может делать никаих предположений о типе 
фиктивного состояния. 
Как дополнительный \In{forall} может нам помочь? 
Функция \In{purge} забывает тип фиктивного состояния \In{s}
из типа \In{Mutable}, но в случае типа \In{Mem}, этот параметр
продолжает своё путешествие по программе в типе значения 
\In{v :: Mem s a}.
По типу \In{v} компилятор может сказать, что существует
такое \In{s}, для которого значение \In{v} имеет смысл
(правильно типизировано). Но оно не любое! Функцию \In{purge}
с трюком интересует не некоторый тип, а все возможные типы \In{s},
поэтому пример не пройдёт проверку типов. Компилятор будет следить
за \Quote{чистотой} наших обновлений.

При таком подходе остаётся вопрос: откуда мы возьмём начальное
значение, ведь теперь у нас нет типа \In{FakeState}? 
В Haskell специально для этого типа было сделано исключение.
Мы возьмём его из воздуха. Это чисто фиктивный параметр, нам главное,
что он скрыт от пользователя, и он нигде не может им воспользоваться.
Поскольку у нас нет конструктора \In{Mutable} мы никогда не сможем
добраться до внутренней функции типа \In{State} и извлечь состояние.
Состояние скрыто за интерфейсом класса \In{Monad} и 
отбрасывается в функции \In{purge}.


\subsection{Тип ST}

Выше я пользовался вымышленными типами для упрощения объяснений,
на самом деле в Haskell за обновление значений отвечает тип \In{ST}
(сокращение от state transformer).
Он живёт в модуле \In{Control.Monad.ST}. Из документации
видно, что у него два параметра, и нет конструкторов:

\begin{code}
data ST s a
\end{code}

Это наш тип \In{Mutable}, теперь посмотрим на тип \In{Mem}.
Он называется \In{ST}-ссылкой и определён в модуле \In{Data.STRef}
(сокращение от ST reference). 
Посмотрим на основные функции:

\begin{code}
newSTRef    :: a -> ST s (STRef s a)
readSTRef   :: STRef s a -> ST s a
writeSTRef  :: STRef s a -> a -> ST s ()
\end{code}

Для иллюстрации этих функций реализуем одну 
вспомогательную функцию из модуля \In{Data.STRef}, функцию
обновления значения по ссылке:

\begin{code}
modifySTRef :: STRef s a -> (a -> a) -> ST s ()
modifySTRef ref f = writeSTRef . f =<< readSTRef ref 
\end{code}

Мы воспользовались тем, что \In{ST} является экземпляром \In{Monad}.
Также как и для \In{State} для \In{ST} определены экземпляры 
классов \In{Functor}, \In{Applicative} и \In{Monad}. 
Какое совпадение! Посмотрим на функцию \In{purge}:

\begin{code}
runST :: (forall s. ST s a) -> a
\end{code}

\subsection{Императивные циклы}

Реализуем \In{for} цикл из языка C:

\begin{verbatim}
Result s;

for (i = 0 ; i < n; i++)
    update(i, s);

return s;
\end{verbatim}

У нас есть стартовое значение счётчика и результата, функция обновления
счётчика, предикат останова и функция обновления результата.
Мы инициализируем счётчик и затем обновляем счётчик и
состояние до тех пор пока предикат счётчика не станет ложным.
Напишем чистую функцию, которая реализует этот процесс. 
В этой функции мы воспользуемся специальным синтаксическим
сахаром, который называется \In{do}-нотация, не пугайтесь это
всё ещё Haskell, для понимания этого примера 
загляните в раздел \Quote{сахар для монад} главы~16. 

\begin{code}
module Loop where

import Control.Monad

import Data.STRef
import Control.Monad.ST

forLoop ::  i -> (i -> Bool) -> (i -> i) -> (i -> s -> s) -> s -> s
forLoop i0 pred next update s0 = runST $ do
    refI <- newSTRef i0
    refS <- newSTRef s0
    iter refI refS
    readSTRef refS
    where iter refI refS = do
            i <- readSTRef refI
            s <- readSTRef refS
            when (pred i) $ do
                writeSTRef refI $ next i
                writeSTRef refS $ update i s
                iter refI refS
\end{code}

Впрочем код выше можно понять если читать его как 
обычный императивный код. Выражения \In{do}-блока выполняются 
последовательно, одно за другим. Сначала мы инициализируем 
два изменяемых значения, для счётчика цикла и для состояния. 
Затем в функции \In{iter} мы читаем значения и выполняем
проверку предиката \In{pred}. Функция \In{when} -- это
стандартная функция из модуля \In{Control.Monad}.
Она проверяет предикат, и если он возвращает \In{True} 
выполняет серию действий, в которых мы записываем
обновлённые значения. Обратите внимание на то, что
связка \In{when-do} это не специальная конструкция языка.
Как было сказано \In{when} -- это просто функция, но
она ожидает одно действие, а мы хотим выполнить сразу несколько.
Следующее за ней \In{do} начинает блок действий (границы блока 
определяются по отступам), который будет интерпретироваться как
одно действие.
В настоящем императивном цикле в обновлении и предикате счётчика 
может участвовать переменная результата, но это считается 
признаком дурного стиля, поэтому наши функции определены
на типе счётчика. Решим типичную задачу, посчитаем
числа от одного до десяти:

\begin{code}
*Loop> forLoop 1 (<=10) succ (+) 0
55
\end{code}

Посчитаем факториал:

\begin{code}
*Loop> forLoop 1 (<=10) succ (*) 1
3628800
*Loop> forLoop 1 (<=100) succ (*) 1
9332621544394415268169923885626670049071596826
4381621468592963895217599993229915608941463976
1565182862536979208272237582511852109168640000
00000000000000000000
\end{code}

Теперь напишем \In{while}-цикл:

\begin{verbatim}
Result s;

while (pred(s))
    update(s);

return s;
\end{verbatim}

В этом цикле участвует один предикат и одна функция обновления
результата, мы обновляем результат до тех пор пока предикат
не станет ложным.

\begin{code}
whileLoop :: (s -> Bool) -> (s -> s) -> s -> s
whileLoop pred update s0 = runST $ do
    ref <- newSTRef s0
    iter ref 
    readSTRef ref
    where iter ref = do
            s <- readSTRef ref
            when (pred s) $ do
                writeSTRef ref $ update s
                iter ref
\end{code}

Посчитаем сумму чисел через \In{while}-цикл:

\begin{code}
*Loop> whileLoop ((>0) . fst) (\(n, s) -> (pred n, n + s)) (10, 0)
(0,55)
\end{code}

Первый элемент пары играет роль счётчика, а во 
втором мы накапливаем результат.

\subsection{Быстрая сортировка}

Реализуем императивный алгоритм быстрой сортировки.
Алгоритм быстрой сортировки хорош не только тем, что
он работает очень быстро, но и минимальным расходом памяти.
Сортировка проводится в самом массиве, с помощью 
обмена элементов местами. Но для этого нам понадобятся 
изменяемые массивы. Этот тип определён в модуле
\In{Data.Array.ST}. В Haskell есть несколько типов
изменяемых массивов (как впрочем и неизменяемых),
это связано с различными нюансами размещения элементов
в массивах, о которых мы пока умолчим. Для предостваления
общего интерфейса к различным массивам был определён класс:

\begin{code}
class (HasBounds a, Monad m) => MArray a e m where
    newArray  :: Ix i => (i, i) -> e -> m (a i e)
    newArray_ :: Ix i => (i, i) -> m (a i e)
\end{code}

\In{MArray} -- это сокращение от mutable (изменяемый)  array.
Метод \In{newArray} создёт массив типа \In{a}, который
завёрнут в тип-монаду \In{m}. Первый аргумент указывает
на диапазон значений индексов массива, а вторым аргументом
передаётся элемент, который будет записан во все ячейки массива.
Вторая функция записывает в массив элемент \In{undefined}. 

Посмотрим на вспомогательные классы:

\begin{code}
class Ord a => Ix a where
    range :: (a, a) -> [a]
    index :: (a, a) -> a -> Int
    inRange :: (a, a) -> a -> Bool
    rangeSize :: (a, a) -> Int

class HasBounds a where
    bounds :: Ix i => a i e -> (i, i)
\end{code}

Класс \In{Ix} описывает тип индекса из непрерывного диапазона значений.
Наверняка по имени функции и типу вы догадаетесь о назначении
методов (можете свериться с интерпретатором на типах
\In{Int} или \In{(Int, Int)}). Класс \In{HasBounds} 
обозначает массивы размер, которых фиксирован.
Но вернёмся к массивам. Мы можем не только выделять память
под массив, но и читать элементы и обновлять их:

\begin{code}
readArray  :: (MArray a e m, Ix i) => a i e -> i -> m e
writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
\end{code}

В случае \In{ST}-ссылок у нас была функция \In{runST}.
Она возвращала значение из памяти, но что будет
возвращать аналогичная функция для массива?
Посмотрим на неё:

\begin{code}
freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
\end{code}

Возможно за всеми классами схожесть с функцией \In{runST} 
прослеживается не так чётко. Новый класс \In{IArray}
обозначает неизменяемые (immutable) массивы.
Функцией \In{freeze} мы превращаем изменяемый массив
в неизменяемый, но завёрнутый в специальный тип-монаду.
В нашем случае этим типом будет \In{ST}. В модуле 
\In{Data.Array.ST} определена специальная версия этой функции:

\begin{code}
runSTArray :: Ix i => (forall s . ST s (STArray s i e)) -> Array i e
\end{code}

Здесь \In{Array} -- это обычный неизменяемый массив. Он
живёт в модуле \In{Data.Array} мы можем строить массивы
из списков значений, преобразовывать их разными способами,
превращать в обратно в списки и многое другое.
Об о всём этом можно узнать из документации к модулю. 
Обратите на появление слова \In{forall} и в этой функции.
Оно несёт тот же смысл, что и в функции \In{runST}.

Для тренировки напишем функцию, которая меняет местами
два элемента массива:

\begin{code}
module Qsort where

import Data.STRef
import Control.Monad.ST

import Data.Array
import Data.Array.ST
import Data.Array.MArray

swapElems :: Ix i => i -> i -> STArray s i e -> ST s ()
swapElems i j arr = do
     vi <- readArray arr i
     vj <- readArray arr j

     writeArray arr i vj
     writeArray arr j vi
\end{code}

Протестируем на небольшом массиве:

\begin{code}
test :: Int -> Int -> [a] -> [a]
test i j xs = elems $ runSTArray $ do
    arr <- newListArray (0, length xs - 1) xs
    swapElems i j arr
    return arr
\end{code}

Тир функции \In{test} ничем не выдаёт её содержание.
Вроде функция как функция:

\begin{code}
test :: Int -> Int -> [a] -> [a]
\end{code}

Посмотрим на то, как она работает:

\begin{code}
*Qsort> test 0 3 [0,1,2,3,4]
[3,1,2,0,4]
*Qsort> test 0 4 [0,1,2,3,4]
[4,1,2,3,0]
\end{code}

Теперь перейдём к сортировке. Суть метода в том, что мы выбираем
один элемент массива, называемый осью (pivot) и переставляем
остальные элементы массива так, чтобы все элементы меньше осевого
были слева от него, а все, что больше оказались справа.
Затем мы повторяем эту процедуру на массивах поменьше,
тех, что находятся слева и справа от осевого элемента
и так пока все элементы не отсортируются. В алгоритме 
очень хитрая процедура перестановки элементов, наша
задача переставить элементы в массиве, то есть не пользуясь 
никакими дополнительными структурами данных. 
Я не буду говорить как это делается, просто выпишу код,
а вы можете почитать об этом где-нибудь, в любом случае из 
кода будет понятно как это происходит:

\begin{code}
qsort :: Ord a => [a] -> [a]
qsort xs = elems $ runSTArray $ do
    arr <- newListArray (left, right) xs
    qsortST left right arr
    return arr
    where left  = 0
          right = length xs - 1
 
qsortST :: Ord a => Int -> Int -> STArray s Int a -> ST s ()
qsortST left right arr = do
    when (left <= right) $ do
        swapArray left (div (left + right) 2) arr
        vLeft <- readArray arr left 
        (last, _) <- forLoop (left + 1) (<= right) succ 
                            (update vLeft) (return (left, arr))
        swapArray left last arr
        qsortST left (last - 1) arr
        qsortST (last + 1) right arr
    where update vLeft i st = do
            (last, arr) <- st
            vi <- readArray arr i
            if (vi < vLeft) 
                then do
                    swapArray (succ last) i arr
                    return (succ last, arr)
                else do
                    return (last, arr)
\end{code}

Это далеко не самый быстрый вариант быстрой сортировки,
но самый простой. Мы просто учимся обращаться с
изменяемыми массивами. Протестируем:

\begin{code}
*Qsort> qsort "abracadabra"
"aaaaabbcdrr"
*Qsort> let x = 1000000
*Qsort> last $ qsort [x, pred x .. 0]
-- двадцать лет спустя
1000000
\end{code}

\section{Краткое содержание}

Мы посмотрели на примерах как применяются типы \In{State},
\In{Reader} и \In{Writer}. 
Также мы познакомились с монадой изменяемых значений \In{ST}. 
Она позволяет писать в имеративном стиле на Haskell. 
Мы узнали два новых элемента пострения типов:

\begin{itemize}
\item Типы-обёртки, которые определяются через ключевое слово \In{newtype}.

\item Записи, они являются произведением типов с именованными полями.
\end{itemize}


Также мы узнали несколько полезных типов:

\begin{itemize}

\item \In{Map} -- хранение значений по ключу 
(из модуля \In{Data.Map}).

\item \In{Tree} -- деревья (из модуля \In{Data.Tree}).

\item \In{Array} -- массивы (из модуля \In{Data.Array}).

\item Типы для накопления результата (из модуля \In{Data.Monoid}).

\end{itemize}

Отметим, что экземпляр класса \In{Monad} определён 
и для функций. Мы можем записать функцию двух аргументов
\In{(a -> b -> c)} как \In{(a -> (->) b c)}. Тогда тип 
\In{(->) b} будет типом с одним параметром, как раз то, что нужно для
класса \In{Monad}. По смыслу экземпляр класса \In{Monad} 
для функций совпадает с экземпляром типа \In{Reader}. 
Первый аргумент стрелочного типа \In{b} играет роль окружения.

\section{Упражнения}

\begin{itemize}

\item Напишите с помощью типа \In{Random} функцию
игры в кости, два игрока бросают по очереди 
кости (два кубика с шестью гранями, грани пронумерованы
от 1 до 6). Они бросают
кубики 10 раз выигрывает тот, у кого в сумме выпадет 
больше очков. Функция принимает начальное состояние
и выводит результат игры: суммарные баллы игроков.

\item Напишите с помощью типа \In{Random}
функцию, которая будет создавать 
случайные деревья заданной глубины. Значение в узле 
является случайным числом от 0 до 100, также число
дочерних деревьев в каждом узле случайно, оно 
изменяется от 0 до 10.

\item Опишите в виде конечного автомата поведение амёбы.
Амёба может двигаться на плоскости по четырём направлениям. 
Если она чувствует свет в определённой стороне, то она 
ползёт туда. Если по-близости нет света, она ползает
в произвольном направлении. Амёба улавливает интенсивность
света, если по всем четырём сторонам интенсивность
одинаковая, она стоит на месте и греется.

\item Казалось бы, зачем нам сохранять вычисления в 
выражениях, почему бы нам просто не вычислить их сразу? 
Если у нас есть описание выражения мы можем применить
различные техники оптимизации, которые могут сокращать
число вычислений. Например нам известно, что 
двойное отрицание не влияет на аргумент, мы можем
выразить это так:

\begin{code}
instance Num Exp where
    negate (Neg a)  = a
    negate x        = Neg x
    ...
    ...
\end{code}

Так мы сократили вычисления на две операции. Возможны и
более сложные техники оптимизации. Мы можем учесть ноль
и единицу при сложении и умножении или дистрибутивность
сложения относительно умножения.

В этом упражнении вам предлагается провести подобную
оптимизацию для логических значений. 
У нас есть абстрактное синтаксическое дерево:

\begin{code}
data Log    = True
            | False
            | Not Log
            | Or  Log Log
            | And Log Log            
\end{code}

Напишите функцию, которая оптимизирует выражение
\In{Log}. Эта функция приводит \In{Log} к 
конъюнктивной нормальной форме (КНФ). Дерево в КНФ
обладает такими свойствами: все узлы с \In{Or} 
находятся ближе к корню чем узлы с \In{And} и
все узлы с \In{And} находятся ближе к корню 
чем узлы с \In{Not}. В КНФ выражения имеют вид:

\begin{code}
(True `And` Not False `And` True) `Or` True `Or` (True `And` False)
(True `And` True `And` False) `Or` True
\end{code}

Как бы мы не шли от корня к листу сначала нам будут 
встречаться только операции \In{Or}, затем только 
операции \In{And}, затем только \In{Not}.

КНФ замечательна тем, что её вычисление может
пройти досрочно. КНФ можно представить так:

\begin{code}
data Or'  a = Or'  [a]
data And' a = And' [a]
data Not' a = Not'  a
data Lit    = True' | False'

type CNF = Or' (And' (Not' Lit))
\end{code}

Сначала идёт список выражений разделённых 
конструктором \In{Or} (вычислять весь список не нужно,
нам нужно найти первый элемент, который вернёт \In{True}).
Затем идёт список выражений, разделённых \In{And}
(опять же его не надо вычислять целиком, нам нужно найти
первое выражение, которое вернёт \In{False}). 
В самом конце стоят отрицания. 

В нашем случае приведение к КНФ состоит из двух этапов:


\begin{itemize}
\item Сначала построим выражение, в котором все
        конструкторы \In{Or} и \In{And} стоят
        ближе к корню чем конструктор \In{Not}.
        Для этого необходимо воспользоваться такими
        правилами:

\begin{code}
-- удаление двойного отрицания
Not (Not a)  ==> a  

-- правила де Моргана
Not (And a b) ==> Or  (Not a) (Not b)
Not (Or  a b) ==> And (Not a) (Not b)

\end{code}

\item Делаем так чтобы все конструкторы \In{Or} 
были бы ближе к корню чем конструкторы \In{And}.
Для этого мы воспользуемся правилом дистрибутивности:

\begin{code}
And a (Or b c)  ==> Or (And a b) (And a c)
\end{code}

При этом мы будем учитывать коммутативность
\In{And} и \In{Or}:

\begin{code}
And a b  == And b a
Or  a b  == Or  b a
\end{code}

\end{itemize}

\item Когда вы закончите определение функции:

\begin{code}
transform :: Log -> CNF
\end{code}

Напишите функцию, которая будет сравнивать
вычисление исходного выражения напрямую
и вычисление через КНФ. Эта функция будет
принимать исходное значение типа \In{Log}
и будет возвращать два числа, число операций
необходимых для вычисления выражения: 

\begin{code}
evalCount :: Log -> (Int, Int)
evalCount a = (evalCountLog a, evalCountCNF a)

evalCountLog :: Log -> Int
evalCountLog a = ...

evalCountCNF :: Log -> Int
evalCountCNF a = ...
\end{code}

При написании этих функций воспользуйтесь
функциями-накопителями.


\item В модуле \In{Data.Monoid} определён специальный
тип с помощью которого можно накапливать функции.
Только функции должны быть специального типа. Они должны
принимать и возвращать значения одного типа. Такие функции
называют \emph{эндоморфизмами}.

Посмотрим на их определение:

\begin{code}
newtype Endo a = Endo { appEndo :: a -> a }

instance Monoid (Endo a) where
        mempty = Endo id
        Endo f `mappend` Endo g = Endo (f . g)
\end{code}

В качестве нейтрального элемента выступает функция тождества,
а функцией объединения значений является функция композиции.
Попробуйте переписать примеры из главы накопление чисел
с помощью этого типа.

\item Реализуйте с помощью монады \In{ST} 
какой-нибудь алгоритм в императивном стиле. 
Например алгоритм поиска корней уравнения методом деления 
пополам. Если функция $f$ непрерывна и в двух точках $a$ и $b$ ($a < b$)
значения функции имеют разные знаки, то это говорит о том,
что где-то на отрезке $[a,\ b]$ уравнение $f(x) = 0$ имеет решение.
Мы можем найти его так. Посмотрим какой знак у значения функции 
в середине отрезка. Если значение равно нулю, то нам повезло 
и мы нашли решение, если нет, то из двух концов отрезка выбрем тот, 
у которого знак значения функции $f$ отличается от знака значения в середине
отрезка. Далее повторим эту процедуру на новом отрезке. И так пока
мы не найдём корень или отрезок не стянется в точку.
Внутри функции выделите память под концы отрезка и последовательно
изменяйте их внутри типа \In{ST}.  
\end{itemize}







