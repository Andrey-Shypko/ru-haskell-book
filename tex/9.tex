\setcounter{chapter}{8}
\chapter{Ленивые чудеса}

В прошлой главе мы узнали, что такое ленивые вычисления. 
В этой главе мы посмотрим чем они хороши. С ними можно
делать невозможные вещи. Обращаться к ещё не вычисленным
значениям, работать с бесконечными данными.

Мы пишем программу, чтобы решить какую-нибудь сложную задачу.
Часто так бывает, что сложная задача оказывается сложной до тех
пор пока её не удаётся разбить на отдельные независимые
подзадачи. Мы решаем задачи по-меньше, потом собираем из
них решения, из этих решений собираем другие решения и
вот уже готова программа. Но мы решаем задачу не на листочке,
нам необходимо объяснить её компьютеру. И тот язык, на 
котором мы пишем программу, оказывает сильное влияние на то
как мы будем решать задачу. Мы не можем разбить программу
на независимые подзадачи, если в том языке на котором мы собираемся
объяснять задачу компьютеру нет средств для того, чтобы 
собрать эти решения вместе. 

Об этом говорит \emph{Джон Хьюз} (John Huges) в статье
\Quote{Why functional programming matters}. Он приводит
такую метафору. Если мы делаем стул и у нас нет хорошего клея.
Единственное что нам остаётся это вырезать из дерева стул 
целиком. Это невероятно трудная задача. Гораздо проще 
сделать отдельные части и потом собрать вместе. 
Функциональные языки программирования предоставляют 
два новых вида \Quote{клея}. Это функции высшего порядка 
и ленивые вычисления. В статье можно найти много 
примеров. Некоторые из них мы рассмотрим в этой главе.

С функциями высших порядков мы уже знакомы, они позволяют
склеивать небольшие решения. С их помощью мы можем параметризовать 
функцию другой функцией (поведением). Они дают нам возможность
выделять сложные закономерности и собирать их в функции.
Ленивые вычисления же предназначены для склеивания больших
программ. Они синхронизируют выполнение подзадач, избавляя
нас от необходимости выполнять это вручную.

Эта идея разбиения программы на независимые части приводит 
нас к понятию модульности. Когда мы решаем задачу мы 
пытаемся разложить её на простейшие составляющие. 
При этом часто оказывается, что эти составляющие применимы
не только для нашей задачи, но и для многих других. 
Мы получаем целый букет решений, там где искали одно.

\section{Численные методы}

Рассмотрим несколько численных методов. 
Все эти методы построены на понятии сходимости.
У нас есть последовательность решений и она
сходится к одному решению, но мы не знаем когда. 
Мы только знаем, что промежуточные решения будут всё 
ближе и ближе к итоговому. 

Поскольку у нас ленивый язык мы сначала построим
все возможные решения, а затем выберем итоговое.
Так же как мы делали это в прошлой главе, когда
искали корни уравнения методом неподвижной точки.
Эти примеры взяты из статьи 
\Quote{Why functional programming matters} Джона Хьюза.

\subsection{Дифференцирование}

Найдём производную функции в точке. Посмотрим на 
математическое определение производной:

\[ f^\prime(x)\ =\lim_{h\to0}\frac{f(x+h)-f(x)}{h}  \]

Производная это предел последовательности таких
отношений, при $h$ стремящемся к нулю. Если предел
сходится, то производная определена. Для того
чтобы решить эту задачу мы начнём с небольшого 
значения $h$ и будем постепенно уменьшать его,
вычисляя промежуточные значения производной.
Как только они перестанут сильно изменяться мы 
будем считать, что мы нашли предел последовательности

Этот процесс напоминает то, что мы делали при
поиске корня уравнения методом неподвижной  точки.
Мы можем взять из того решения функцию определения 
сходимости последовательности:

\begin{code}
converge :: (Ord a, Num a) => a -> [a] -> a
converge eps (a:b:xs) 
    | abs (a - b) <= eps    = a
    | otherwise             = converge eps (b:xs)
\end{code}

Теперь осталось только создать последовательность
значений производных. Напишем функцию, которая вычисляет
промежуточные решения:

\begin{code}
easydiff :: Fractional a => (a -> a) -> a -> a -> a
easydiff f x h = (f (x + h) - f x) / h
\end{code}

Мы возьмём начальное значение шага и будем последовательно
уменьшать его вдвое:

\begin{code}
halves = iterate (/2) 
\end{code}

Соберём все части вместе:

\begin{code}
diff :: (Ord a, Fractional a) => a -> a -> (a -> a) -> a -> a
diff h0 eps f x = converge eps $ map (easydiff f x) $ iterate (/2) h0
    where easydiff f x h = (f (x + h) - f x) / h
\end{code}

Сохраним эти определения в отдельном модуле и найдём производную 
какой-нибудь функции. Протестируем решение на экспоненте.
Известно, что производная экспоненты равна самой себе:

\begin{code}
*Numeric> let exp' = diff 1 1e-5 exp
*Numeric> let test x = abs $ exp x - exp' x
*Numeric> test 2
1.4093421286887065e-5
*Numeric> test 5
1.767240203776055e-5
\end{code}

\subsection{Интегрирование}

Теперь давайте поинтегрируем функции одного аргумента. 
Интеграл это площадь кривой под графиком функции. 
Если бы кривая была прямой, то мы могли бы вычислить 
интеграл по формуле трапеций:

\begin{code}
easyintegrate :: Fractional a => (a -> a) -> a -> a -> a
easyintegrate f a b = (f a + f b) * (b - a) / 2
\end{code}

Но мы хотим интегрировать не только прямые линии. 
Мы представим, что функция является ломаной прямой
линией. Мы посчитаем интеграл на каждом из участков и 
сложим ответы. При этом чем ближе точки друг к другу, 
тем точнее можно представить функцию в виде ломаной 
прямой линии, тем точнее будет значение интеграла.

Проблема в том, что мы не знаем заранее насколько
близки должны быть точки друг к другу. Это
зависит от функции, которую мы хотим проинтегрировать. 
Но мы можем построить последовательность решений. 
На каждом шаге мы будем приближать функцию 
ломаной прямой, и на каждом шаге число изломов
будет расти вдвое. Как только решение перестанет меняться 
мы вернём ответ.

Построим последовательность решений:

\begin{code}
integrate :: Fractional a => (a -> a) -> a -> a -> [a]
integrate f a b = easyintegrate f a b : 
    zipWith (+) (integrate a mid) (integrate mid b)
    where mid = (a + b)/2
\end{code}

Первое решение является площадью под прямой, которая соединяет
концы отрезка. Потом мы делим отрезок пополам, строим
последовательность приближений и складываем частичные суммы
с помощью функции \In{zipWith}. 

Эта версия функции хоть 
и наглядная, но не эффективная. Функция \In{f} вычисляется
заново при каждом рекурсивном вызове. Было бы хорошо 
вычислять её только для новых значений. Для этого 
мы будем передавать значения с предыдущего шага:

\begin{code}
integrate :: Fractional a => (a -> a) -> a -> a -> [a]
integrate f a b = integ f a b (f a) (f b)
    where integ f a b fa fb = (fa+fb)*(b-a)/2 :
                zipWith (+) (integ f a m fa fm) 
                            (integ f m b fm fb)
                where m  = (a + b)/2
                      fm = f m 
\end{code}

В этой версии мы вычисляем значения в функции \In{f}
лишь один раз для каждой точки. Запишем итоговое решение:

\begin{code}
int :: (Ord a, Fractional a) => a -> (a -> a) -> a -> a -> a
int eps f a b = converge eps $ integrate f a b
\end{code}

Мы опять воспользовались функцией \In{converge}, нам не нужно
было её переписывать. Проверим решение. Для проверки 
также воспользуемся экспонентой. В прошлой главе мы узнали, что

\[  e^x = 1 + \int_0^x e^t dt  \]

Посмотрим, так ли это для нашего алгоритма:

\begin{code}
*Numeric> let exp' = int 1e-5 exp 0
*Numeric> let test x = abs $ exp x - 1 -  exp' x 
*Numeric> test 2
8.124102876649886e-6
*Numeric> test 5
4.576306736225888e-6
*Numeric> test 10
1.0683757864171639e-5
\end{code}

Алгоритм работает. В статье ещё рассмотрены методы
повышения точности этих алгоритмов. Что интересно для
улучшения точности не надо менять существующий код.
Функция принимает последовательность промежуточных
решений и преобразует её. 


\section{Степенные ряды}

Напишем модуль для вычисления степенных рядов.
Этот пример взят из статьи Дугласа МакИлроя 
(Douglas McIlroy) \Quote{Power Series, Power Serious}.
Степенной ряд представляет собой функцию, которая 
определяется списком коэффициентов:

\[ F(x) = f_0 + f_1 x + f_2 x^2 + f_3 x^3 + f_4 x^4 + .... \]

Степенной ряд содержит бесконечное число слагаемых.
Для вычисления  нам потребуются функции сложения
и умножения. Ряд $F(x)$ можно записать и по-другому:

\[\begin{array}{l@{\ =\ }l}
F(x) & F_0 (x) \\
     & f_0 + x F_1 (x)  \\
     & f_0 + x (f_1 + x F_2 (x)) \\   
\end{array}\]

Это определение очень похоже на определение списка. Ряд
есть коэффициент $f_0$ и другой ряд $F_1(x)$ умноженный
на \In{x}. Поэтому для представления рядов мы выберем 
конструкцию похожую на список:


\begin{code}
data Ps a = a :+: Ps a
    deriving (Show, Eq)
\end{code}


Но в нашем случае списки бесконечны, поэтому у
нас лишь один конструктор.
Далее мы будем писать просто $f + x F_1$, без скобок для аргумента.


Определим вспомогательные функции для создания рядов:


\begin{code}
p0 :: Num a => a -> Ps a
p0 x = x :+: p0 0

ps :: Num a => [a] -> Ps a
ps []     = p0 0
ps (a:as) = a :+: ps as
\end{code}


Обратите внимание на то, как мы дописываем бесконечный хвост
нулей в конец ряда.
Теперь давайте определим функцию вычисления ряда. Мы будем
вычислять лишь конечное число степеней. 


\begin{code}
eval :: Num a => Int -> Ps a -> a -> a
eval 0 _         _ = 0
eval n (a :+: p) x = a + x * eval (n-1) p x
\end{code}

В первом случае мы хотим вычислить ноль степеней ряда,
поэтому мы возвращаем ноль, а во втором случае значение
ряда $a + x P$ складывается из числа $a$ и значения
ряда $P$ умноженного на заданное значение.  


\subsection{Арифметика рядов}

В результате сложения и умножения рядов также
получается ряд. Также мы можем создать ряд из числа.
Эти операции говорят о том, что мы можем сделать 
степенной ряд экземпляром класса \In{Num}.

\subsubsection{Сложение}

Рекурсивное представление ряда $f + x F$ позволяет нам
очень кратко выражать операции, которые мы хотим определить.
Теперь у нас нет бесконечного набора коэффициентов, у нас
всего лишь одно число и ещё один ряд. Операции существенно
упрощаются. Так сложение двух бесконечных рядов имеет вид:

\[ F + G = (f + x F_1) + (g + x G_1) = (f+g) + x (F_1 + G_1) \]

Переведём на Haskell:


\begin{code}
(f :+: fs) + (g :+: gs) = (f + g) :+: (fs + gs)
\end{code}


\subsubsection{Умножение}

Умножим два ряда:

\[ F*G = (f + x F_1) * (g + x G_1) = f g + x (f G_1 + F_1 * G) \]

Переведём:


\begin{code}
(.*) :: Num a => a -> Ps a -> Ps a
k .* (f :+: fs) = (k * f) :+: (k .* fs)  

(f :+: fs) * (g :+: gs) = (f * g) :+: (f .* gs + fs * (g :+: gs))
\end{code}


Дополнительная операция \In{(.*)} выполняет умножение
всех коэффициентов ряда на число.

\subsubsection{Класс Num}

Соберём определения для методов класса \In{Num} вместе:


\begin{code}
instance Num a => Num (Ps a) where
    (f :+: fs) + (g :+: gs) = (f + g) :+: (fs + gs)
    (f :+: fs) * (g :+: gs) = (f * g) :+: (f .* gs + fs * (g :+: gs))
    negate (f :+: fs) = negate f :+: negate fs
    fromInteger n = p0 (fromInteger n)


(.*) :: Num a => a -> Ps a -> Ps a
k .* (f :+: fs) = (k * f) :+: (k .* fs)  
\end{code}


Методы \In{abs} и \In{signum} не определены для рядов.
Обратите внимание на то, как рекурсивное определение рядов
приводит к рекурсивным определениям функций для рядов.
Этот приём очень характерен для Haskell. Поскольку наш 
ряд это число и ещё один ряд за счёт рекурсии мы можем 
воспользоваться операцией, которую мы определяем, на 
\Quote{хвостовом} ряде.

\subsubsection{Деление}

Результат деления $Q$ удовлетворяет соотношению:

\[ F = Q * G \]

Переписав $F$, $G$ и $Q$ в нашем представлении, получим

\[\begin{array}{l@{\ = \ }l}
f + x F_1 &  (q + x Q_1) * G = qG + x Q_1 * G = q(g + x G_1) + x Q_1 * G \\
          & q g + x (q G_1 + Q_1 * G) \\
\end{array}\]

Следовательно 

\[\begin{array}{l@{\ = \ }l}
q    &  f/g  \\
Q_1  &  (F_1 - q G_1)/G \\
\end{array}\]

Если $g = 0$ деление имеет смысл только в том случае, если и
$f = 0$. Переведём на Haskell:


\begin{code}
class Fractional a => Fractional (Ps a) where
    (0 :+: fs) / (0 :+: gs) = fs / gs
    (f :+: fs) / (g :+: gs) = q :+: ((fs - q .* gs)/(g :+: gs))
        where q = f/g

    fromRational x = p0 (fromRational x)
\end{code}

\subsection{Производная и интеграл}

Производная одного члена ряда вычисляется так:

\[  \frac{d}{dx} x^n = n x^{n-1} \]

Из этого выражения по свойствам производной 

\[   \frac{d}{dx}(f(x) + g(x)) =  \frac{d}{dx}f(x) +  \frac{d}{dx}g(x) \]

\[  \frac{d}{dx} (k * f(x)) = k *  \frac{d}{dx} f(x)\]

мы можем получить формулу для всего ряда:

\[   \frac{d}{dx} F(x) = f_1 + 2 f_2 x + 3 f_3 x^2 + 4 f_4 x^3 + \dots \]

Для реализации нам понадобится вспомогательная функция, которая
будет обновлять значение дополнительного множителя $n$ в выражении
$n x^{n-1}$:


\begin{code}
diff :: Num a => Ps a -> Ps a
diff (f :+: fs) = diff' 1 fs
    where diff' n (g :+: gs) = (n * g) :+: (diff' (n+1) gs)
\end{code}


Также мы можем вычислить и интеграл степенного ряда:


\begin{code}
int :: Fractional a => Ps a -> Ps a
int (f :+: fs) = 0 :+: (int' 1 fs) 
    where int' n (g :+: gs) = (g / n) :+: (int' (n+1) gs)
\end{code}


\subsection{Элементарные функции}

Мы можем выразить элементарные функции через 
операции взятия производной и интегрирования.
К примеру уравнение для $e^x$ выглядит так:

\[ \frac{dy}{dx} = y \]

Проинтегрируем с начальным условием $y(0) = 1$:

\[ y(x) = 1 + \int_0^x y(t) dt  \]

Теперь переведём на Haskell:


\begin{code}
expx = 1 + int expx
\end{code}


Кажется невероятным, но это и есть определение экспоненты.
Так же мы можем определить и функции для синуса и косинуса:

\[\begin{array}{ll}
\frac{d}{dx} \sin{x} = \cos{x},   & \sin(0) = 0, \\
\frac{d}{dx} \cos{x} = - \sin{x},  & \cos(0) = 1 \\
\end{array}
\]


Что приводит нас к:


\begin{code}
sinx = int cosx
cosx = 1 - int sinx
\end{code}


И это работает! Вычисление этих функций возможно за счёт того,
что вне зависимости от аргумента функция \In{int} вернёт
ряд, у которого первый коэффициент равен нулю. Это значение 
подхватывается и используется на следующем шаге рекурсивных 
вычислений.

Через синус и косинус мы можем определить тангенс:

\begin{code}
tanx = sinx / cosx
\end{code}

\section{Водосборы}

В этом примере мы рассмотрим одну интересную технику
рекурсивных вычислений, которая называется 
\emph{мемоизацией} (memoization). Она заключается
в том, что мы запоминаем все значения, с которыми вызывалась
функция и, если с данным значением функция уже вычислялась, 
просто используем значение из памяти, а если значение 
ещё не вычислялось, вычисляем его и сохраняем. 

В ленивых языках программирования для мемоизации 
функций часто используется такой приём. Мы сохраняем
все значения функции в некотором контейнере, а затем
обращаемся к элементам. При этом значения
сохраняются в контейнере и не перевычисляются. Это
происходит за счёт ленивых вычислений. Что интересно
вычисляются не все значения, а лишь те, которые нам 
действительно нужны, те которые мы извлекаем из 
контейнера хотя бы один раз. 

Посмотрим на такой классический пример. 
Вычисление чисел Фибоначчи. Каждое последующее
число ряда Фибоначчи равно сумме двух предыдущих.
Наивное определение выглядит так:

\begin{code}
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
\end{code}

В этом определении число вычислений
растёт экспоненциально. Для того чтобы вычислить \In{fib n} нам
нужно вычислить \In{fib (n-1)} и \In{fib (n-2)}, для того чтобы вычислить
каждое из них нам нужно вычислить ещё два числа, и так вычисления 
удваиваются на каждом шаге. Если мы вызовем в интерпретаторе \In{fib 40},
то вычислитель зависнет. Что интересно в этой функции вычисления 
пересекаются, они могут быть переиспользованы. Например для вычисления
\In{fib (n-1)} и \In{fib (n-2)} нужно вычислить \In{fib (n-2)} (снова),
\In{fib (n-3)}, \In{fib (n-3)} (снова) и \In{fib (n-4)}. 

Если мы сохраним все значения функции в списке, каждый вызов
функции будет вычислен лишь один раз:

\begin{code}
fib' :: Int -> Int
fib' n = fibs !! n
    where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
\end{code}

Попробуем вычислить для \In{40}:

\begin{code}
*Fib> fib' 40
102334155
*Fib> fib' 4040
700852629
\end{code}

Вычисления происходят мгновенно. Если 
задача состоит из множества подзадач, которые самоподобны
и для вычисления последующих подзадач используются решения из предыдущих, 
стоит задуматься об использовании мемоизации. Такие задачи 
называются задачами \emph{динамического программирования}. 
Вычисление чисел Фибоначчи яркий пример задачи динамического
программирования. 

Рассмотрим такую задачу. Дана прямоугольная 
\Quote{карта местности}, в каждой клетке целым числом указана
высота точки. Необходимо разметить местность по следующим
правилам:

\begin{itemize}
\item Из каждой клетки карты вода стекает
    не более чем в одном из четырёх возможных направлений
    (\Quote{север}, \Quote{юг}, \Quote{запад}, \Quote{восток}).
        
\item Если у клетки нет соседе с высотой меньше её собственной
    высоты, то эта клетка -- водосток, и вода из неё никуда
    дальше не течёт. 
        
\item Иначе вода из текущей клетки стекает на соседнюю клетку 
    с минимальной высотой.

\item Если таких соседей несколько, то вода стекает по первому 
    из возможных направлений из списка 
    \Quote{на север}, \Quote{на запад}, 
    \Quote{на восток}, \Quote{на юг}.
\end{itemize}

Все клетки из которых вода стекает в один и тот же
водосток принадлежат к одному бассейну водосбора. 
Необходимо отметить на карте все бассейны. Решение
этой задачи встретилось мне в статье Дмитрия Астапова
\Quote{Рекурсия+мемоизация = динамическое программирование}.
Здесь оно и приводится с незначительными изменениями.

Карта местности представлена в виде двумерного массива,
в каждой клетке которого отмечена высота точки,
нам необходимо получить двумерный массив того же размера,
который вместо высот содержит метки водостоков. Мы будем 
отмечать их буквами латинского алфавита в том порядке,
в котором они встречаются при обходе карты сверху вниз,
слева направо. Например:

\begin{code}
1 2 3 4 5 6       a a a b b b
7 8 9 2 4 5       a a b b b b
3 5 3 3 6 7   ->  c c d b b e 
6 4 5 5 3 1       f g d b e e
2 2 4 5 3 7       f g g h h e
\end{code}

Для представления двумерного массива мы воспользуемся
типом \In{Array} из стандартного модуля \In{Data.Array}.
Тип \In{Array} имеет два параметра:

\begin{code}
darta Array i a
\end{code}

Первый указывает на индекс, а второй на содержание. 
Подразумевается, что этот тип является экземпляром
класса \In{Ix}, который описывает целочисленные индексы:

\begin{code}
class Ord a => Ix a where
    range :: (a, a) -> [a]
    index :: (a, a) -> a -> Int
    inRange :: (a, a) -> a -> Bool
    rangeSize :: (a, a) -> Int
\end{code}

Первый аргумент у всех этих функций это пара, которая 
представляет верхнюю и нижнюю грань последовательности. 
Попробуйте догадаться, что делают методы этого класса 
по типам и именам.

Для двумерного массива индекс будет задаваться парой целых
чисел:

\begin{code}
import Data.Array

type Coord = (Int, Int)
type HeightMap = Array Coord Int
type SinkMap   = Array Coord Coord
\end{code}

Значение типа \In{HeightMap} хранит карту высот, 
значение типа \In{SinkMap} хранит в каждой координате,
ту точку, которая является водостоком для данной точки.
Нам необходимо построить функцию:

\begin{code}
flow :: HeightMap -> SinkMap
\end{code}

Мы будем решать эту задачу рекурсивно. Представим, что 
мы знаем водостоки для всех точек кроме данной. Для каждой точки
мы можем узнать в какую сторону из неё стекает вода. 
При этом водосток для следующей точки такой же как
и для текущей. Если же из данной точки вода никуда не течёт, 
то она сама является водостоком. Мы определим эту функцию
через комбинатор неподвижной точки \In{fix}.:

\begin{code}
flow :: HeightMap -> SinkMap
flow arr = fix $ \result -> listArray (bounds arr) $ 
    map (\x -> maybe x (result !) $ getSink arr x) $ 
    range $ bounds arr 

getSink :: HeightMap -> Coord -> Maybe Coord
\end{code}

Мы ищем решение в виде неподвижной точки функции, 
которая принимает карту стоков и возвращает карту стоков.
Функция \In{getSink} по данной точке на карте вычисляет 
соседнюю точку, в которую стекает вода. Эта функция
частично определена, поскольку для водостоков
нет такой соседней точки, в которую бы утекала вода.
Функция \In{listArray} конструирует значение типа
\In{Array} из списка значений. Первым аргументом
она принимает диапазон значений для индексов. 
Размеры массива совпадают с размерами карты высот,
поэтому первым аргументом мы передаём \In{bounds arr}.

Теперь разберёмся с тем как заполняются значения 
в список. Сначала мы создаём список координат
исходной карты высот с помощью выражения:

\begin{code}
range $ bounds arr
\end{code}

После этого мы по координатам точек 
находим водостоки, причём сразу для всех точек.
Это происходит в лямбда-функции:

\begin{code}
\x -> maybe x (result !) $ getSink arr x
\end{code}

Мы принимаем текущую координату и с помощью функции 
\In{getSink} находим соседнюю точку, в которую убегает
вода. Если такой точки нет, то в следующем выражении
мы вернём исходную точку, поскольку в этом случае 
она и будет водостоком, а если такая соседняя точка 
всё-таки есть мы спросим результат из будущего.
Мы обратимся к результату \In{(result !)}, посмотрим
каким окажется водосток для соседней точки и вернём 
это значение. Поскольку за счёт ленивых вычислений
значения результирующего массива вычисляются лишь 
один раз, после того как мы найдём водосток для данной
точки этим результатом смогут воспользоваться все соседние
точки. При этом порядок обращения к значениям из
будущих вычислений не играет роли.

Осталось только определить функцию поиска ближайшего
стока и функцию разметки.


\begin{code}
getSink :: HeightMap -> Coord -> Maybe Coord
getSink arr (x, y) 
    | null sinks = Nothing
    | otherwise  = Just $ snd $ minimum $ map (\i -> (arr!i, i)) sinks
    where sinks = filter p [(x+1, y), (x-1, y), (x, y-1), (x, y+1)]
          p i   = inRange (bounds arr) i && arr ! i < arr ! (x, y)
\end{code}

В функции разметки мы воспользуемся ассоциативным массивом
из модуля \In{Data.Map}. Функция \In{nub} из модуля \In{Data.List}
убирает из списка повторяющиеся элементы. Затем мы составляем
список пар из координат водостоков и меток и в самом конце
размечаем исходный массив:

\begin{code}
label :: SinkMap -> LabelMap
label a = fmap (m M.! ) a 
    where m = M.fromList $ flip zip ['a' .. ] $ nub $ elems a
\end{code}


\section{Краткое содержание}

Ленивые вычисления повышают модульность программ. 
Мы можем в одной части программы создать все возможные
решения, а в другой выбрать лучшие по какому-либо признаку.
Также мы посмотрели на интересную технику написания 
рекурсивных функций, которая называется мемоизацией. 
Мемоизация означает, что мы не вычисляем повторно значения 
некоторой функции, а сохраняем их и используем в дальнейших
вычислениях. 

\section{Упражнения}

Мы побывали на выставке ленивых программ.
Присмотритесь ещё раз к решениям задач этой главы
и подумайте какую роль сыграли ленивые вычисления
в каждом из случаев, какие мотивы обыгрываются в этих примерах.
Также подумайте каким было бы решение, если бы в Haskell
использовалась стратегия вычисления по значению.

