\setcounter{chapter}{3}
\chapter{Декларативный и композиционный стиль}

В Haskell существует несколько встроенных выражений,
которые облегчают построение функций и делают код более
наглядным. Их можно разделить на два вида: выражения,
которые поддерживают \emph{декларативный стиль} 
(declarative style) определения функций,
и выражения которые поддерживают 
\emph{композиционный стиль} (expression style).

Что это за стили? В декларативном стиле определения функций
больше похожи на математическую нотацию, словно это
предложения языка. В композиционном стиле мы строим 
из маленьких выражений более сложные, применяем к этим
выражениям другие выражения и строим ещё большие. 

В Haskell есть полноценная поддержка и того и другого стиля, поэтому
конструкции которые мы рассмотрим в этой главе будут по смыслу
дублировать друг друга. Выбор стиля скорее дело вкуса, существуют
приверженцы и того и другого стиля, поэтому разработчики Haskell
не хотели никого ограничивать. 

\section{Локальные переменные}

Вспомним определение площади треугольника по трём сторонам:

\[  S = \sqrt{p \cdot (p - a) \cdot (p - b) \cdot (p - c)} \]

Где $a$, $b$ и $c$ -- длины сторон треугольника, а $p$ это
полупериметр. 

Как бы мы определили эту функцию теми средствами, что у нас
есть? Наверное мы бы написали так:

\begin{code}
square a b c = sqrt (p a b c * (p a b c - a) * (p a b c - b) * (p a b c - c))

p a b c = (a + b + c) / 2
\end{code}

Согласитесь это не многим лучше чем решение в лоб:

\begin{code}
square a b c = sqrt ((a+b+c)/2 * ((a+b+c)/2 - a) * ((a+b+c)/2 - b) * ((a+b+c)/2 - c))
\end{code}

И в том и в другом случае нам приходится дублировать выражения, нам бы
хотелось чтобы определение выглядело так же, как и обычное математическое
определение:

\begin{code}
square a b c = sqrt (p * (p - a) * (p - b) * (p - c))

p = (a + b + c) / 2
\end{code}

Нам нужно, чтобы \In{p} знало, что \In{a}, \In{b} и \In{c} 
берутся из аргументов функции \In{square}. 
В этом нам помогут локальные переменные.

\subsection{where-выражения}

В декларативном стиле для этого предусмотрены \KeyWord{where} 
\In{where}-выражения. Они пишутся так:

\begin{code}
square a b c = sqrt (p * (p - a) * (p - b) * (p - c))
    where p = (a + b + c) / 2
\end{code}

Или так:

\begin{code}
square a b c = sqrt (p * (p - a) * (p - b) * (p - c)) where 
    p = (a + b + c) / 2
\end{code}

За определением функции следует специальное слово \In{where},
которое вводит локальные имена-синонимы. При этом аргументы
функции включены в область видимости имён. Синонимов может быть
несколько:

\begin{code}
square a b c = sqrt (p * pa * pb * pc)
    where p  = (a + b + c) / 2
          pa = p - a
          pb = p - b
          pc = p - c
\end{code}

Отметим, что отступы обязательны. Haskell по отступам
понимает, что эти выражения относятся к \In{where}. 

Как и в случае объявления функций порядок следования 
локальных переменных в \In{where}-выражении не важен. 
Главное чтобы в выражениях справа от знака равно мы
пользовались именами из списка аргументов исходной функции
или другими определёнными именами.
Локальные переменные видны только в пределах той
функции, в которой они вводятся.

Что интересно, слева от знака равно в \In{where}-выражениях 
можно проводить декомпозицию значений, также как и в аргументах
функции:

\begin{code}
pred :: Nat -> Nat
pred x = y
    where (Succ y) = x
\end{code}

Эта функция делает тоже самое что и функция

\begin{code}
pred :: Nat -> Nat
pred (Succ y) = y
\end{code}

В \In{where}-выражениях можно определять новые функции
а также выписывать их типы:

\begin{code}
add2 x = succ (succ x)
    where succ :: Int -> Int
          succ x = x + 1
\end{code}

А можно и не выписывать, компилятор догадается:

\begin{code}
add2 x = succ (succ x)
    where succ x = x + 1
\end{code}

Но иногда это бывает полезно, при использовании классов
типов, для избежания неопределённости применения.

Приведём ещё один пример. Посмотрим на функцию
фильтрации списков, она определена в \In{Prelude}:

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  []     = []
filter  p  (x:xs) = if p x then x : rest else rest
    where rest = filter p xs
\end{code}

Мы определили локальную переменную \In{rest}, которая
указывает на рекурсивный вызов функции на оставшейся части
списка.

\In{where}-выражения определяются для каждого уравнения
в определении функции: 

\begin{code}
even :: Nat -> Bool
even Zero        = res
    where res = True
even (Succ Zero) = res
    where res = False
even x = even res
    where (Succ (Succ res)) = x
\end{code}

Конечно в этом примере \In{where} не нужны, но здесь они приведены
для иллюстрации привязки \In{where}-выражения к данному уравнению.
Мы определили три локальных переменных с одним и тем же именем.

\In{where}-выражения могут быть и у значений, которые
определяются внутри \In{where}-выражений. Но лучше избегать
сильно вложенных выражений.

\subsection{let-выражения}

В композиционном стиле функция вычисления площади треугольника будет
выглядеть так:

\begin{code}
square a b c = let p = (a + b + c) / 2
               in  sqrt (p * (p - a) * (p - b) * (p - c)) 
\end{code}

Слова \KeyWord{let in} \In{let} и \In{in} -- ключевые. Выгодным отличием
\In{let}-выражений является то, что они являются обычными выражениями
и не привязаны к определённому месту как \In{where}-выражения.
Они могут участвовать в любой части обычного выражения:

\begin{code}
square a b c = let p = (a + b + c) / 2
               in  sqrt ((let pa = p - a in p * pa) * 
                         (let pb = p - b
                              pc = p - c  
                          in  pb * pc)) 
\end{code}

В этом проявляется их принадлежность  композиционному
стилю. \In{let}-выражения могут участвовать в любом 
подвыражении, они также группируются скобками. А \In{where}-выражения
привязаны к уравнениям в определении функции.

Также как и в \In{where}-выражениях, в \In{let}-выражениях слева
от знака равно можно проводить декомпозицию значений.

\begin{code}
pred :: Nat -> Nat
pred x = let (Succ y) = x
         in  y
\end{code}

Определим функцию фильтрации списков через \In{let}:

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  []     = []
filter  p  (x:xs) = 
    let rest = filter p xs
    in  if p x then x : rest else rest
\end{code}


\section{Декомпозиция}

Декомпозиция или сопоставление с образцом позволяет
выделять из составных значений, простейшие значения
с помощью которых они были построены

\begin{code}
pred (Succ x) = x
\end{code}

\noindent и организовывать 
условные вычисления которые зависят от вида поступающих
на вход функции значений

\begin{code}
not True  = False
not False = True
\end{code}

\subsection{Сопоставление с образцом}

Декомпозицию в декларативном стиле мы уже изучили, это
обычный случай разбора значений в аргументах функции.
Рассмотрим одну полезную возможность при декомпозиции.
Иногда нам хочется провести декомпозицию и дать 
псевдоним всему значению. Это можно сделать
с помощью специального символа \InS{@}.

Например определим функцию, которая возвращает соседние
числа для данного числа Пеано:

\begin{code}
beside :: Nat -> (Nat, Nat)
beside  Zero       = error "undefined"
beside  x@(Succ y) = (y, Succ x)
\end{code}

В выражении \InS{x@}\In{(Succ y)} мы одновременно проводим
разбор и даём имя всему значению. В этом определении
нам встретился новый тип -- кортеж. В Haskell кортежи
пишутся в скобках, значения разделяются запятыми. 
В отличие от списка кортеж может содержать значения разных
типов, но размер его фиксирован. Мы пользуемся кортежами,
когда хотим вернуть из функции несколько значений. 

\subsection{case-выражения}

Оказывается декомпозицию можно проводить в любом выражении,
для этого существуют \KeyWord{case of} \In{case}-выражения:

\begin{code}
data AnotherNat = None | One | Two | Many
    deriving (Show, Eq)

toAnother :: Nat -> AnotherNat
toAnother x = 
    case x of
        Zero                -> None
        Succ Zero           -> One
        Succ (Succ Zero)    -> Two
        _                   -> Many

fromAnother :: AnotherNat -> Nat
fromAnother None    = Zero
fromAnother One     = Succ Zero
fromAnother Two     = Succ (Succ Zero)
fromAnother Many    = error "undefined" 
\end{code}

Слова \In{case} и \In{of} -- ключевые. Выгодным отличием
\In{case}-выражений является то, что нам не приходится
каждый раз выписывать имя функции. Обратите внимание
на то, что в \In{case}-выражениях также можно пользоваться
обычными переменными и безымянными переменными.

Для проведения декомпозиции по нескольким переменным можно
воспользоваться кортежами. 
Например определим знакомую функцию равенства для \In{Nat}:

\begin{code}
instance Eq Nat where
    (==) a b =
        case (a, b) of
            (Zero,    Zero)     -> True
            (Succ a', Succ b')  -> a' == b'
            _                   -> False
\end{code}

Мы проводим сопоставление с образцом по кортежу \In{(a, b)},
соответственно слева от знака \In{->} мы проверяем значения в 
кортежах, для этого мы также заключаем значения в скобки
и пишем их через запятую.

Давайте определим функцию \In{filter} в ещё более 
композиционном стиле. Для этого мы заменим в исходном 
определении \In{where} на \In{let} и декомпозицию в аргументах
на \In{case}-выражение:

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  a = 
    case a of
        []      -> []
        x:xs    ->  let rest = filter p xs
                    in  if (p x) 
                        then (x:rest)
                        else rest
\end{code}


\section{Условные выражения}

С условными выражениями мы уже сталкивались в сопоставлении с образцом.
Например в определении функции \In{not}:

\begin{code}
not True  = False
not False = True
\end{code}

В зависимости от поступающего значения мы выбираем одну из двух
альтернатив. Условные выражении в сопоставлении с образцом позволяют
реагировать лишь на частичное (с учётом переменных) совпадение дерева
значения в аргументах функции. 

Часто нам хочется определить более сложные
условия для альтернатив. Например, если значение на входе функции
больше 2, но меньше 10, верни \In{A}, а если больше 10, верни \In{B},
а во всех остальных случаях верни \In{C}. 
Или если на вход поступила строка состоящая только из букв
латинского алфавита, верни \In{A}, а в противном случае верни
\In{B}. Нам бы хотелось реагировать лишь в том случае, если значение 
некоторого типа \In{a} удовлетворяет некоторому предикату. 
Предикатами обычно называют функции типа \In{a -> Bool}.
Мы говорим, что значение удовлетворяет предикату, если предикат
для этого значения возвращает \In{True}. 

\subsection{Охранные выражения}

В декларативном стиле условные выражения представлены 
\emph{охранными выражениями} (guards). Предположим у нас есть
тип:

\begin{code}
data HowMany = Little | Enough | Many
\end{code}

И мы хотим написать функцию, которая принимает число людей,
которые хотят посетить выставку, а возвращает значение 
типа \In{HowMany}. Эта функция оценивает вместительность
выставочного зала. С помощью охранных выражений мы можем написать
её так:

\begin{code}
hallCapacity :: Int -> HowMany
hallCapacity n
    | n < 10    = Little
    | n < 30    = Enough
    | True      = Many
\end{code}

Специальный символ \In{|} уже встречался нам в определении
типов. Там он играл роль разделителя альтернатив в сумме типов.
Здесь же он разделяет альтернативы в условных выражениях. 
Сначала мы пишем \In{|} затем выражение-предикат, которое
возвращает значение типа \In{Bool}, затем
равно и после равно -- возвращаемое значение. Альтернативы
так же как и в случае декомпозиции аргументов функции обходятся
сверху вниз, до тех пор пока в одной из альтернатив предикат 
не вернёт значение \In{True}. Обратите внимание на то, что нам 
не нужно писать во второй альтернативе:

\begin{code}
    | 10 <= n && n < 30   = Enough
\end{code}

Если вычислитель дошёл до этой альтернативы, значит значение
точно больше либо равно \In{10}. Поскольку в предыдущей альтернативе
предикат вернул \In{False}. 

Предикат в последней альтернативе 
является константой \In{True}, он пройдёт сопоставление с любым
значением \In{n}. В данном случае, если учесть предыдущие альтернативы
мы знаем, что если вычислитель дошёл до последней альтернативы , значение
\In{n} больше либо равно \In{30}. Для повышения наглядности кода
в \In{Prelude} определена специальная константа-синоним значению 
\In{True} под именем \In{otherwise}. 

Определим функцию \In{filter} для списков в более 
декларативном стиле, для этого заменим \In{if}-выражение
в исходной версии на охранные выражения:

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  []       = []
filter  p  (x:xs)   
    | p x           = x : rest
    | otherwise     = rest
    where rest = filter p xs
\end{code}

Или мы можем разместить охранные выражения по-другому:

\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter  p  []                   = []
filter  p  (x:xs)   | p x       = x : rest
                    | otherwise = rest
    where rest = filter p xs
\end{code}

Отметим то, что локальная переменная \In{rest} видна и в той 
и в другой альтернативе. Вы спокойно можете пользоваться 
локальными переменными в любой части уравнения, в котором
они определены. 

Определим с помощью охранных выражений функцию \In{all},
она принимает предикат и список, и проверяет удовлетворяют
ли все элементы списка данному предикату.

\begin{code}
all :: (a -> Bool) -> [a] -> Bool
all p []        = True
all p (x:xs)    
    | p x       = all p xs
    | otherwise = False
\end{code}

С помощью охранных выражений можно очень наглядно
описывать условные выражения. Но иногда можно обойтись
и простыми логическими операциями. Например функцию
\In{all} можно было бы определить так:

\begin{code}
all :: (a -> Bool) -> [a] -> Bool
all  p  []        = True
all  p  (x:xs)    = p x && all p xs
\end{code}

Или так:

\begin{code}
all :: (a -> Bool) -> [a] -> Bool
all  p  xs = null (filter notP xs)
    where notP x = not (p x)
\end{code}

Или даже так)


\begin{code}
import Prelude(all)
\end{code}

Функция \In{null} определена в \In{Prelude} она возвращает
\In{True} только если список пуст. 

\subsection{if-выражения}

В композиционном стиле в качестве условных выражений
используются уже знакомые нам \In{if}-выражения. Вспомним
как они выглядят:

\begin{code}
a = if bool 
    then x1
    else x2
\end{code}

Слова \In{if}, \In{then} и \In{else} -- ключевые. Тип \In{a}, 
\In{x1} и \In{x2} совпадают.

Любое охранное выражение, в котором больше одной альтернативы,
можно представить в виде \In{if}-выражения и наоборот. 
Перепишем все функции их предыдущего подраздела с помощью
\In{if}-выражений:

\begin{code}
hallCapacity :: Int -> HowMany
hallCapacity n =
    if (n < 10)
    then Little
    else (if n < 30 
          then Enough
          else Many)

all :: (a -> Bool) -> [a] -> Bool
all p []     = True
all p (x:xs) = if (p x) then all p xs else False
\end{code}

\section{Определение функций}

Под функцией мы понимаем составной синоним, который
принимает аргументы, возможно разбирает их на части и
составляет из этих частей новые выражения. Теперь посмотрим
как такие синонимы определяются в каждом из стилей.

\subsection{Уравнения}

В декларативном стиле функции определяются с помощью
уравнений. Пока мы видели лишь этот способ определения функций,
примерами могут служить все предыдущие примеры. Вкратце напомним,
что функция определяется набором уравнений вида:

\begin{code}
name декомпозиция1 = композиция1
name декомпозиция2 = композиция2
...
name декомпозицияN = композицияN
\end{code}

Где \In{name} -- имя функции. В \In{декомпозиции} происходит 
разбор поступающих на вход значений, а в \In{композиции} происходит
составление значения результата. Уравнения обходятся вычислителем
сверху вниз до тех пор пока он не найдёт такое уравнение, для
которого переданные в функции значения не подойдут в указанный
в декомпозиции шаблон значений (если сопоставление с образцом
аргументов пройдёт успешно). Как только такое уравнение найдено,
составляется выражение справа от знака равно (\In{композиция}).
Это значение будет результатом функции. Если такое уравнение
не будет найдено программа остановится с ошибкой.

К примеру попробуйте вычислить в интерпретаторе выражение \In{notT False},
для такой функции:

\begin{code}
notT :: Bool -> Bool
notT True = False
\end{code}

Что мы увидим?

\begin{code}
Prelude> notT False
*** Exception: <interactive>:1:4-20: Non-exhaustive patterns in function notT
\end{code}

Интерпретатор сообщил нам о том, что он не нашёл уравнения
для переданного в функцию значения. 

\subsection{Безымянные функции}

В композиционном стиле функции определяются по-другому.
Это необычный метод, он пришёл в Haskell из лямбда-исчисления.
Функции строятся с помощью специальных конструкций, которые
называются лямбда-функциями. По сути лямбда-функции являются
безымянными функциями. Давайте посмотрим на лямбда функцию,
которая прибавляет к аргументу единицу:

\begin{code}
\x -> x + 1
\end{code}

Для того, чтобы превратить лямбда-функцию в обычную функцию
мысленно замените знак \verb!\! на имя \In{noName},
а стрелку на знак равно:

\begin{code}
noName x = x + 1
\end{code}

Мы получили обычную функцию Haskell, с такими мы уже много
раз встречались. Зачем специальный синтаксис для определения
безымянных функций? Ведь можно определить её в виде уравнений. 
К тому же кому могут понадобиться безымянные функции? 
Ведь смысл функции в том, чтобы выделить определённый 
шаблон поведения и затем ссылаться на него по имени функции. 

Смысл безымянной функции в том, что ею, также как и любым
другим элементом композиционного стиля, можно пользоваться
в любой части обычных выражений. С её помощью мы можем 
создавать функции \Quote{на лету}. Предположим, что мы
хотим профильтровать список чисел, мы хотим выбрать из них лишь
те, что меньше 10, но больше 2, и к тому же они должны быть чётными. 
Мы можем написать:

\begin{code}
f :: [Int] -> [Int]
f = filter p
    where p x = x > 2 && x < 10 && even x
\end{code}

При этом нам приходится давать какое-нибудь имя предикату,
например \In{p}. С помощью безымянной функции мы могли бы написать 
так:

\begin{code}
f :: [Int] -> [Int]
f = filter (\x -> x > 2 && x < 10 && even x)
\end{code}

Смотрите мы составили предикат сразу в аргументе 
функции \In{filter}. Выражение 
\In{(}\verb!\!\In{x -> x > 2 && x < 10 && even x)}
является обычным значением. 

Возможно у вас появился вопрос, где аргумент функции? Где тот 
список по которому мы проводим фильтрацию. Ответ на этот вопрос
кроется в частичном применении. Давайте вычислим по правилу 
применения тип функции \In{filter}:

\begin{code}
    f :: (a -> Bool) -> [a] -> [a],    x :: (Int -> Bool)
    ------------------------------------------------------
                (f x) :: [Int] -> [Int]
\end{code}

После применения параметр \In{a} связывается с типом \In{Int},
поскольку при применении происходит сопоставление более общего
предиката \In{a -> Bool} из функции \In{filter} с тем, который
мы передали первым аргументом \In{Int -> Bool}. После этого
мы получаем тип \In{(f x) :: [Int] -> [Int]} это как раз тип
функции, которая принимает список целых чисел и возвращает список 
целых чисел. Частичное применение позволяет нам не писать
в таких выражениях:

\begin{code}
f xs = filter p xs
    where p x = ...
\end{code}


\noindent последний аргумент \In{xs}. 

К примеру вместо

\begin{code}
add a b = (+) a b
\end{code}

\noindent мы можем просто написать:

\begin{code}
add = (+)
\end{code}

Такой стиль определения функций называют \emph{бесточечным} 
(point-free).

Давайте выразим функцию \In{filter} с помощью лямбда-функций:

\begin{code}
filter :: (a -> Bool) -> ([a] -> [a])
filter = \p -> \xs -> case xs of
    []     -> []
    (x:xs) -> let rest = filter p xs
              in  if   p x
                  then x : rest
                  else rest
\end{code}

Мы определили функцию \In{filter} пользуясь только 
элементами композиционного стиля. Обратите внимание
на скобки в объявлении типа функции. Я хотел напомнить
вам о том, что все функции в Haskell  являются функциями
одного аргумента. Это определение функции \In{filter}
как нельзя лучше подчёркивает этот факт. Мы говорим,
что  функция \In{filter} является функцией одного аргумента
\In{p} в выражении \verb!\!\In{p -> }, которая
возвращает также функцию одного аргумента. Мы выписываем
это в явном виде в выражении \verb!\!\In{xs -> }.
Далее идёт выражение, которое содержит определение функции. 

Отметим, что лямбда функции могут принимать несколько 
аргументов, в предыдущем определении мы могли бы написать:


\begin{code}
filter :: (a -> Bool) -> ([a] -> [a])
filter = \p xs -> case xs of
    ...
\end{code}

\noindent но это лишь синтаксический сахар, который разворачивается
в предыдущую запись.

Для тренировки определим несколько стандартных функций
для работы с кортежами с помощью лямбда-функций (все они
определены в \In{Prelude}):

\begin{code}
fst :: (a, b) -> a
fst = \(a, _) -> a

snd :: (a, b) -> b
snd = \(_, b) -> b

swap :: (a, b) -> (b, a)
swap = \(a, b) -> (b, a)
\end{code}

Обратите внимание на то, что все функции словно являются
константами. Они не содержат аргументов. Аргументы мы \Quote{пристраиваем}
с помощью безымянных функций. 

Определим функции преобразования первого и второго
элемента кортежа (эти функции определены в модуле  \In{Control.Arrow})

\begin{code}
first :: (a -> a') -> (a, b) -> (a', b)
first = \f (a, b) -> (f a, b)

second :: (b -> b') -> (a, b) -> (a, b')
second = \f (a, b) -> (a, f b)
\end{code}

Также в \In{Prelude} есть полезные функции, которые превращают функции
с частичным применением в обычны функции и наоборот:

\begin{code}
curry :: ((a, b) -> c) -> a -> b -> c
curry = \f -> \a -> \b -> f (a, b)

uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry = \f -> \(a, b) -> f a b
\end{code}

Функция \In{curry} принимает функцию двух аргументов 
для которой частичное применение невозможно. Это имитируется
с помощью кортежей. Функция принимает кортеж из двух элементов.
Функция \In{curry} (от слова каррирование, частичное применение) 
превращает такую функцию в обычную функцию Haskell. А функция
\In{uncurry} выполняет обратное преобразование.


С помощью лямбда-функций можно имитировать локальные переменные.
Так например можно переписать формулу для вычисления площади 
треугольника:

\begin{code}
square a b c = 
    (\p -> sqrt (p * (p - a) * (p - b) * (p - c))) 
    ((a + b + c) / 2)
\end{code}

Смотрите мы определили функцию, которая принимает параметром
полупериметр \In{p} и передали в неё значение \In{((a + b + c) / 2)}.
Если в нашей функции несколько локальных переменных, то мы можем
составить лямбда-функцию от нескольких переменных и подставить
в неё нужные значения.

\section{Какой стиль лучше?}

Основной критерий выбора заключается в том, сделает
ли этот элемент код более \emph{ясным}.
Наглядность кода станет залогом успешной поддержки. Его будет
легче понять и улучшить при необходимости. 

Далее мы рассмотрим несколько примеров определений
из \In{Prelude} и подумаем, почему был выбран тот или
иной стиль.
Начнём с класса \In{Ord} и посмотрим на определения
по умолчанию:


\begin{code}
-- Тип упорядочивания

data  Ordering  =  LT | EQ | GT
          deriving (Eq, Ord, Enum, Read, Show, Bounded)


class  (Eq a) => Ord a  where
    compare              :: a -> a -> Ordering
    (<), (<=), (>=), (>) :: a -> a -> Bool
    max, min             :: a -> a -> a

        -- Минимальное полное определение:
        --      (<=) или compare
        -- Использование compare может оказаться более 
        -- эффективным для сложных типов.
    compare x y
         | x == y    =  EQ
         | x <= y    =  LT
         | otherwise =  GT

    x <= y           =  compare x y /= GT
    x <  y           =  compare x y == LT
    x >= y           =  compare x y /= LT
    x >  y           =  compare x y == GT

    max x y 
         | x <= y    =  y
         | otherwise =  x
    min x y
         | x <= y    =  x
         | otherwise =  y
\end{code}


Все функции определены в декларативном стиле. Тип \In{Ordering} 
кодирует результат операции сравнения. Два числа могут быть либо равны
(значение \In{EQ}), либо первое меньше второго (значение \In{LT}),
либо первое больше второго (значение \In{GT}).

Обратите внимание на функцию \In{compare}. Мы не пишем дословное
определение значений типа \In{Ordering}:

\begin{code}
    compare x y
         | x == y    =  EQ
         | x <  y    =  LT
         | x >  y    =  GT
\end{code}

В этом случае функция \In{compare} была бы определена через 
две других функции класса  \In{Ord}, а именно больше \In{>}
и меньше \In{<}. Мы же хотим минимизировать число функций
в этом определении. Поэтому вместо этого определения
мы полагаемся на очерёдность обхода альтернатив в охранном
выражении.

Если первый случай не прошёл, то во втором случае нет разницы
между функциями \In{<} и \In{<=}. А если не прошёл и этот случай, 
то остаётся только вернуть значение \In{GT}. Так мы определили
функцию \In{compare} через одну функцию класса \In{Ord}.

Теперь посмотрим на несколько полезных функций для списков.
Посмотрим на три основные функции для списков, одна из них
возможно вам уже порядком поднадоела:

\begin{code}
-- Преобразование списка
map :: (a -> b) -> [a] -> [b]
map f []     = []
map f (x:xs) = f x : map f xs


-- Фильтрация списка
filter :: (a -> Bool) -> [a] -> [a]
filter p []                 = []
filter p (x:xs) | p x       = x : filter p xs
                | otherwise = filter p xs

-- Свёртка списка
foldr            :: (a -> b -> b) -> b -> [a] -> b
foldr f z []     =  z
foldr f z (x:xs) =  f x (foldr f z xs)
\end{code}

Все эти функции определены в декларативном стиле. С преобразованием
списка и фильтрацией мы уже сталкивались. Функция свёртки списка
заменяет в узлах дерева списка все конструкторы \In{[]} на 
значение \In{z} и все конструкторы \In{(:)} на функцию двух
аргументов \In{f :: (a -> b -> b)}. Это очень полезная функция
с помощью неё можно определить много других функций на списках.
Приведём несколько примеров:

\begin{code}
and, or          :: [Bool] -> Bool
and              =  foldr (&&) True
or               =  foldr (||) False

(++) :: [a] -> [a] -> [a]
[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
    
concat :: [[a]] -> [a]
concat = foldr (++) []
\end{code}

Функции \In{and} и \In{or} выполняют логические операции 
на списках. Так каждый конструктор \In{(:)} заменяется на 
соответствующую логическую операцию, а пустой список заменяется
на значение, которое не влияет на результат выполнения 
данной логической операции. Имеется ввиду, что функции
\In{(&& True)} и \In{(|| False)} дают тот же результат,
что и функция \In{id x = x}. 

Функция \In{(++)} объединяет два списка, а функция \In{concat}
выполняет ту же операцию, но на списке списков.

Функция \In{zip} принимает два списка и смешивает
их в список пар. Как только один из списков оборвётся 
оборвётся и список-результат. Эта функция является
частным случаем более общей функции \In{zipWith},
которая принимает функцию двух аргументов и два списка
и составляет новый список попарных применений.

\begin{code}
-- zip-ы 
zip :: [a] -> [b] -> [(a, b)]
zip = zipWith (,)

zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith z (a:as) (b:bs) =  z a b : zipWith z as bs
zipWith _ _ _           =  []
\end{code}

Посмотрим как работают эти функции в интерпретаторе:

\begin{code}
Prelude> zip [1,2,3] "hello"
[(1,'h'),(2,'e'),(3,'l')]
Prelude> zipWith (+) [1,2,3] [3,2,1]
[4,4,4]
Prelude> zipWith (*) [1,2,3] [5,4,3,2,1]
[5,8,9]
\end{code}

Отметим, что в \In{Prelude} также определена обратная функция \In{unzip}:

\begin{code}
unzip   :: [(a,b)] -> ([a], [b]) 
\end{code}

Она берёт список пар и разбивает его на два списка.

Пока по этим определениям кажется, что композиционный стиль 
совсем нигде не применяется. Он встретился нам лишь в функции
\In{break}. Но давайте посмотрим и на функции
с композиционным стилем:

\begin{code}
lines            :: String -> [String]
lines ""         =  []
lines s          =  let (l, s') = break (== '\n') s
                    in  l : case s' of
                              []      -> []
                              (_:s'') -> lines s''
\end{code}

Функция \In{line} разбивает строку на список строк. 
Эти строки были разделены в исходной строке 
символом переноса \verb!'\textbackslash n'!. 

Функция \In{break} принимает предикат и список 
и возвращает два списка. В первом все элементы от начала
списка, которые не удовлетворяют предикату, а во втором все остальные.
Наш предикат \In{(== '}\verb!\!\In{n')} выделяет все символы 
кроме переноса каретки. В строке 

\begin{code}
let (l, s') = break (== '\n') s
\end{code}

Мы сохраняем все символы до \verb!'\textbackslash n'! от начала
строки в переменной \In{l}. Затем мы рекурсивно вызываем
функцию \In{lines} на оставшейся части списка:

\begin{code}
                    in  l : case s' of
                              []      -> []
                              (_:s'') -> lines s''
\end{code}

При этом мы пропускаем в \In{s'} первый элемент, поскольку
он содержит символ переноса каретки. 

Посмотрим на ещё одну функцию для работы со строками. 

\begin{code}
words            :: String -> [String]
words s          =  case dropWhile Char.isSpace s of
                      "" -> []
                      s' -> w : words s''
                            where (w, s'') = break Char.isSpace s'
\end{code}

Функция \In{words} делает тоже самое, что и \In{lines}, только
теперь в качестве разделителя выступает пробел. Функция
\In{dropWhile} отбрасывает от начала списка все элементы, которые 
удовлетворяют предикату. В строке 

\begin{code}
case dropWhile Char.isSpace s of
\end{code}

Мы одновременно отбрасываем все первые пробелы и готовим
значение для декомпозиции. Дальше мы рассматриваем два 
возможных случая для строк. 

\begin{code}
                      "" -> []  
                      s' -> w : words s''
                            where (w, s'') = break Char.isSpace s'
\end{code}

Если строка пуста, то делать больше нечего. Если -- нет, 
мы также как и в предыдущей функции применяем функцию \In{break}
для того, чтобы выделить все элементы кроме пробела, а затем
рекурсивно вызываем функцию \In{words} на оставшейся части списка.


\section{Краткое содержание}

В этой главе мы узнали очень много новых синтаксических 
конструкций для определения функций. Они появлялись парами. Сведём их в таблицу:

\begin{center}
\begin{tabular}{l||l|l} 
%\hline
Элемент                 & Декларативный стиль     & Композиционный  стиль \\
[3mm] \hline  
      & & \\
Локальные переменные    & \In{where}-выражения    & \In{let}-выражения \\ [1mm]
Декомпозиция            & Сопоставление с образцом в уравнениях 
                                             & \In{case}-выражения \\ [1mm]
Условные выражения      & Охранные выражения & \In{if}-выражения \\ [1mm]
Определение функций     & Уравнения          & лямбда-функции \\ [1mm]
%    \hline
\end{tabular}
\end{center}

Также нам встретился новый тип -- кортеж. Кортежи в основном
используются для того, чтобы возвращать из функции 
несколько значений. В отличие от списков они могут 
содержать значения разных типов, но длина их фиксирована.

\begin{code}
(a, b)
(a, b, c)
(a, b, c, d)
...
\end{code}


\subsubsection{Особенности синтаксиса}

Нам встретилась новая конструкция в сопоставлении с образцом:

\begin{code}
beside :: Nat -> (Nat, Nat)
beside  Zero       = error "undefined"
beside  x@(Succ y) = (y, Succ x)
\end{code}

Она позволяет проводить декомпозицию и давать имя 
всему значению одновременно. Такие выражения \In{x@(\dots)}
в англоязычной литературе принято называть as-patterns.

\section{Упражнения}

\begin{itemize}

\item В этой главе нам встретилось много полезных 
        стандартных функций, потренируйтесь с ними
        в интерпретаторе. Вызывайте их с различными значениями,
        экспериментируйте.


\item Попробуйте определить функции из предыдущих глав
        в чисто композиционном стиле. 

\item Посмотрите на те функции, которые мы прошли 
        и попробуйте переписать их определения шиворот на
        выворот. Если вы видите, что элемент написан композиционном
        стиле перепишите его в декларативном и наоборот.
        Получившиеся функции могут показаться монстрами, но
        это упражнение может помочь вам в закреплении новых 
        конструкций и почувствовать сильные и слабые стороны
        того или иного стиля.

\item Определите модуль, который будет вычислять площади 
        простых фигур, треугольника, окружности, прямоугольника,
        трапеции. Помните, что фигуры могут задаваться различными
        способами.

\item Поток это бесконечный список, т.е.~список, у которого
        нет конструктора пустого списка:

\begin{code}
data Stream a = a :& Stream a
\end{code}

Так например мы можем составить поток из всех чисел Пеано:

\begin{code}
nats :: Nat -> Stream Nat
nats a = a :& nats (Succ a) 
\end{code}

Или поток, который содержит один и тот же элемент:

\begin{code}
constStream :: a -> Stream a
constStream a = a :& constStream a 
\end{code}

Напишите модуль для потоков. В первую очередь нам понадобятся
функции выделения частей потока, поскольку мы не сможем
распечатать поток целиком (ведь он бесконечный):

\begin{code}
-- Первый элемент потока
head :: Stream a -> a

-- Хвост потока, всё кроме первого элемента
tail :: Stream a -> Stream a

-- n-тый элемент потока
(!!) :: Stream a -> Int -> a

-- Берёт из потока несколько первых элементов:
take :: Int -> Stream a -> [a]
\end{code}

Имена этих функций будут совпадать с именами функций
для списков чтобы избежать коллизий имён мы воспользуемся
квалифицированным импортом функций. Делается это так:

\begin{code}
import qualified Prelude as P( определения )
\end{code}

Слова \KeyWord{qualified as} \In{qualified} и \In{as} -- ключевые. Теперь для
использования функций из модуля \In{Prelude} мы будем 
писать \In{P.имяФункции}. Такие имена называются 
квалифицированными. Для того чтобы пользоваться 
квалифицированными именами только для тех функций, для
которых возможна коллизия имён можно поступить так:

\begin{code}
import qualified Prelude as P
import Prelude
\end{code}

Компилятор разберётся, какую функцию мы имеем в виду. 

Для удобства тестирования можно определить такую функцию 
печати потоков:

\begin{code}
instance Show a => Show (Stream a) where
    show xs =  showInfinity (show (take 5 xs))
        where showInfinity x = P.init x  P.++ "..."
\end{code}

Функция \In{P.init} выделяет все элементы списка кроме
последнего. В данном случае она откусит от строки закрывающуюся
скобку. После этого мы добавляем троеточие, как символ бесконечности списка.

Функции преобразования потоков:

\begin{code}
-- Преобразование потока
map :: (a -> b) -> Stream a -> Stream b

-- Фильтрация потока
filter :: (a -> Bool) -> Stream a -> Stream a

-- zip-ы для потоков:
zip :: Stream a -> Stream b -> Stream (a, b)

zipWith :: (a -> b -> c) -> Stream a -> Stream b -> Stream c 
\end{code}

Функция генерации потока:

\begin{code}
iterate :: (a -> a) -> a -> Stream a
\end{code}

Эта функция принимает два аргумента: функцию следующего 
элемента потока и значение первого элемента потока и
возвращает поток:

\begin{code}
iterate f a = a :& f a :& f (f a) :& f (f (f a)) :& ...
\end{code}

Так с помощью этой функции можно создать поток всех чисел Пеано
от нуля или постоянный поток:

\begin{code}
nats            = iterate Succ Zero 
constStream a   = iterate (\x -> x) a
\end{code}
Возможно вас удивляет тот факт, что в этом упражнении
мы оперируем бесконечными значениями, но пока мы не будем 
вдаваться в детали того как это работает, просто попробуйте
определить этот модуль и посмотрите в интерпретаторе, что получится.

\end{itemize}

