\setcounter{chapter}{9}
\chapter{Реализация Haskell в GHC}

На момент написания этой книги основным компилятором
Haskell является GHC. Остальные конкуренты отстают очень
сильно. Отметим компилятор Hugs (его хорошо использовать 
для демонстрации Haskell на чужом компьютере, если вы не хотите
устанавливать тяжёлый GHC).
В этом разделе мы обзорно рассмотрим как язык Hаskell 
реализован в GHC. 
GHC -- как ни парадоксально это звучит, это самая успешная
программа написанная на Haskell. GHC уже двадцать лет.
Отметим основных разработчиков. Это Саймон Пейтон Джонс
(Simon Peyton Jones) и Саймон Марлоу (Simon Marlow).

GHC состоит из трёх частей. Это сам компилятор, основные
библиотеки языка (такие как Prelude) и низкоуровневая 
система вычислений (она отвечает за управление памятью, 
потоками, вычисление примитивных операций). 
Весь GHC кроме системы вычислений
написан на Haskell. Система вычислений написана на C.
Компилятор принимает набор файлов с исходным кодом 
(а также возможно объектных и интерфейсных файлов) 
и генерирует код низкого уровня. Система вычислений низкого уровня
используется в этом коде как библиотека. Она статически 
подключается к любому нативному коду, который генерируется GHC. 
Далее мы сосредоточимся на изучении компилятора. 

Но перед этим давайте освежим в памяти (или узнаем)
несколько терминов. У нас есть код на Haskell, что значит
перевести в код низкого уровня? Код низкого уровня представляет
собой набор инструкций, которые изменяют значения в памяти
компьютера. Изменение значений происходит с помощью 
базовых операций, которые выполняются в процессоре компьютера.
Память компьютера представляет собой ленту ячеек. У каждой
ячейки есть адрес и содержание. По адресу мы можем читать
данные из ячейки и записывать их туда. Эти операции также
выполняются с помощью инструкций. 
Мы будем делить память на стек (stack), кучу (heap) и 
регистры (registers). 

Стек~-- это очередь с 
принципом работы \Quote{последним пришёл, первым ушёл}.
Стек можно представить как стопку книг. У нас есть две
операции: положить книгу наверх, и снять верхнюю книгу.
Стек очень удобен для переключения контекстов вычисления.
Представьте, что у нас есть функция, которая внутри 
вызывает другую функцию, а та следующую. Находясь в 
верхней функции при заходе во вторую мы сохраняем контекст
внешней функции в стеке. Контекст -- это та информация, которая
нужна нам для того, чтобы продолжить вычисления. 
Как только мы доходим до третьей функции, мы \Quote{кладём на стопку
сверху} контекст второй функции, как только третья функция вычислена,
мы обращаемся к стеку и снимаем с него контекст второй функции
продолжаем вычислять и как только вторая функция заканчивается
снова обращаемся к стеку. А там сверху уже лежит контекст 
самой первой функции. Мы можем продолжать вычисления. Так 
происходит вычисление вложенных функций в императивных 
языках программирования. 

В куче мы храним разные данные. Данные бывают статическими
(они нужны нам на протяжении выполнения всей программы)
и динамическими (время жизни динамических данных заранее
неизвестно, например это могут быть отложенные вычисления,
мы не знаем когда ни нам понадобятся).
У кучи также две операции: выделить блок памяти, эта операция
принимает размер блока и возвращает адрес, по которому
удалось выделить память, и освободить память по указанному адресу.

Регистры находятся в процессоре. В них можно записывать и читать
данные, при этом операции обращения к регистрам будут 
происходить очень быстро.

Посмотрим как GHC справляется с переводом процесса редукции 
синонимов на язык понятный нашему компьютеру. Язык обновления стека и кучи.

\subsection{Этапы компиляции}

Рассмотрим этапы компиляции программы (\RefFig{CompilerStages}).

\newcommand{\Dia}[1]{\fbox{\text{#1}}}

\begin{figure}[ht]
\centering
\begin{diagram}
 &          & \text{Файл .hs} \\
 &          & \dTo  \\
 &          & \Dia{Построение синтаксического дерева} \\
 &          & \dTo \\
 &          & \Dia{Разрешение имён} \\
 &          & \dTo \\
 &          & \Dia{Проверка типов} \\
 &          & \dTo \\
 &          & \Dia{Устранение синтаксического сахара} \\
 &          & \dTo^{\text{Core}} \\
 &          & \Dia{Упрощение Core}     & \rTo & \Dia{Генерация кода для ghci} \\
 &          & \dTo^{\text{STG}} \\
 &          & \Dia{Генерация Cmm} \\ 
 &          & \dTo \\
 &          & \Dia{Cmm}    &        &  \\
 & \ldTo    & \dTo          & \rdTo  &  \\
\Dia{C} &  & \Dia{Native} &        & \Dia{LLVM}  \\
\end{diagram}
\caption{Этапы компиляции}
\label{fig:CompilerStages}
\end{figure}

На первых трёх этапах происходит проверка ошибок. 
Сначала мы строим синтаксическое дерево программы. 
Если мы нигде не забыли скобки, не ошиблись в простановке 
ключевых слов, то этот этап успешно завершится. 
Далее мы приписываем ко всем функциям их полные имена.
Дописываем перед всеми определениями имя модуля, в котором они
определены. Обычно на этом этапе нам сообщают о том, что
мы забыли определить какую-нибудь функцию, часто это связано
с простой опечаткой. Следующий этап -- самый важный. 
Происходит вывод типов для всех значений и проверка
программы по типам. Блок кода, отвечающий за проверку типов,
является самым большим в GHC. Haskell имеет очень 
развитую систему типов. Многих возможностей мы ещё 
не коснулись, часть из них мы рассмотрим в главе 16.
Допустим, что мы исправили все ошибки связанные с типами,
тогда компилятор начнёт переводить Haskell в Core.

Core -- это функциональный язык программирования, который 
является сильно урезанной версией Haskell. Помните мы говорили, что 
в Haskell поддерживается несколько стилей (композиционный
и декларативный). Что хорошо для программиста, не очень хорошо 
для компилятора. Компилятор устраняет весь синтаксический сахар
и выражает все определения через простейшие конструкции языка Core.
Далее происходит серия оптимизаций языка Core. На дереве
описания программы выполняется серия функций типа  \mbox{\In{Core -> Core}}.
Например происходит замена вызовов коротких функций на 
их правые части урвнений (встраивание или inlining), 
выражения, которые проводят декомпозицию в \In{case}-выражениях 
по константам, заменяются на соответствующие этим константам 
выражения. По требованию GHC может провести анализ строгости
(strictness analysis). Он заключается в том, что GHC
ищет аргументы функций, которые могут быть вычислены 
более эфективно с помощью вычисления по значению и
расставляет анотации строгости. И многие многие другие
оптимизации кода. Все они представлены в виде преобразования
синтаксического дерева программы. Также этот этап называют
упрощением программы. 

После этого Core переводится на STG. Это функциональный
язык, повторяющий Core. Он содержит дополнительную информацию,
которая необходима низкоуровневым бибилиотекам на этапе 
вычисления программы. Затем из STG генерируется код
языка \verb!C--!. Это язык низкого уровня, \Quote{портируемый ассемблер}.
На этом языке не пишут программы, он предназначен для 
автоматической генерации кода. Далее из него получают
другие низкоуровневые коды. Возможна генерация C, LLVM
и нативного кода (код, который исполняется операционной системой). 

\subsection{Язык STG}

STG расшифровывается как Spineless Tagless G-machine. 
G-machine или Г-машина -- это низкоуровневое описание 
процесса редукции графов (от Graph). Пока мы называли этот процесс
редукцией синонимов. Spineless и Tagless -- это термины специфичные
для G-машины, которая была придумана разработчиками GHC.
Tagless относится к особому представлению объектов в куче
(объекты представлены единообразно, так что им не нужен специальный
тег для обозначения типа объекта), а Spineless относится
к тому, что в отличие от машин-предшественников, которые
описывают процесс редукции графов виде последовательности
инструкций, STG является небольшим функциональным языком. 
На \RefFig{SyntaxSTG} представлен синтаксис языка STG. 
Синтаксис упрощён для чтения людьми. Несмотря на упрощения 
мы сможем посмотреть как происходит вычисление выражений. 
    
\begin{figure}[ht]
\centering
\[\begin{array}{rrlll}
\text{Переменные}   & x,y,f,g   &       &   &  \\
\text{Конструкторы} & C         &       &   & 
    \text{Объявлены в определениях типов}  \\
\text{Литералы}     & lit       & ::=   & i \Or d & 
    \text{Незапакованные целые} \\
 & & & & \text{или действительные числа} \\
\text{Атомы}        & a, v      & ::=   & lit \Or x & 
    \text{Аргументы функций атомарны} \\
\text{Арность функции} & k      & ::=   & \bullet   & 
    \text{Арность неизвестна} \\
                       &        & \Or   & n         & 
    \text{Арность известна } n \geq 1 \\
\\
\text{Выражения}       &   e     & ::=  & a         & \text{Атом} \\
                       &         & \Or  & f^k\ a_1 \dots a_n & 
    \text{Вызов функции } (n \geq 1) \\ 
                       &         & \Or  & \oplus\ a_1 \dots a_n & 
    \text{Вызов примитивной функции } (n \geq 1) \\  
\\
                       &         & \Or  & 
            \texttt{let}\ x\ \texttt{=}\ obj\ \texttt{in}\ e  & 
    \text{Выделение нового объекта } obj \text{ в куче} \\ 
                       &         & \Or  & 
            \texttt{case } e \texttt{ of } \{ alt_1; \dots ;alt_n \}  & 
    \text{Приведение выражения } e \text{ к СЗНФ} \\  
\\
\text{Альтернативы}    & alt     & ::=  & C\ x_1 \dots x_n \Ra e &
    \text{Сопоставление с образцом } (n \geq 1) \\
                       &         & \Or  & x \Ra e &
    \text{Альтернатива по умолчанию} \\
\\
\text{Объекты в куче}  & obj     & ::=  & FUN(x_1 \dots x_n \Ra e)  &
    \text{Функция арности } n \geq 1 \\
                        &        & \Or  & PAP(f\ a_1 \dots a_n) &
    \text{Частичное применение } f \text{ может} \\
 & & & & \text{указывать только на } FUN \\
                        &        & \Or  & CON(C\ a_1 \dots a_n) &
        \text{Полное применение конструктора } (n \geq 0) \\
                        &        & \Or  & THUNK\ e  & 
        \text{Отложенное вычисление}  \\   
                        &        & \Or  & BLACKHOLE &
        \text{Используется только во время} \\
 & & & & \text{выполнения программы} \\
\text{Программа}        & prog  & ::=   & 
    f_1 \texttt{=} obj_1\ ; \dots ;\ f_n \texttt{=} obj_n & \\

\end{array}\]
\caption{Синтаксис STG}
\label{fig:SyntaxSTG}
\end{figure}

По синтаксису STG можно понять, какие выражения языка
Haskell являются синтаксическим сахаром. Им просто нет 
места в языке STG. Например, не видим мы сопоставления с образцом.
Оно как и \In{if}-выражения переписывается через \In{case}-выражения.
Исчезли \In{where}-выражения. Конструкторы могут применяться
только полностью, то есть для применения конструктора мы должны
передать ему все аргументы. В STG \In{let}-выражения
разделяют на не рекурсивные (\In{let}) и рекурсивные (\In{letrec}).
Разделение проводится в целях оптимизации, мы же будем
считать, что эти случаи описываются одной конструкцией. 

На что стоит обратить внимание? Заметим, что функции
могут принимать только атомарные значения 
(либо примитивные значения, либо переменные). 
В данном случае переменные указывают на объекты в куче. 
Так если в Haskell мы пишем:

\begin{code}
foldr f (g x y) (h x)
\end{code}

В STG это выражение примет вид:

\begin{code}
let gxy = THUNK (g x y)
    hx  = THUNK (h x)
in  foldr f gxy hx
\end{code}

У функций появились степени. Что это? Степени указывают
на арность функции, то есть на количество принимаемых аргументов.
Количество принимаемых аргументов определяется по левой части
функции. Поскольку в Haskell функции могут возвращать другие функции,
очень часто мы не можем знать арность, тогда мы пишем $\bullet$.

Отметим два важных принципа вычисления на STG:

\begin{itemize}
\item Новые объекты создаются в куче \emph{только} в \In{let}-выражениях
\item Выражение приводится к СЗНФ \emph{только} в \In{case}-выражениях
\end{itemize}

Выражение \In{let a = obj in e} означает
добавь в кучу объект \In{obj} под именем \In{a} и затем вычисли \In{e}.
Выражение \In{case e of}~\verb!{alt1;...;alt2}! означает
узнай конструктор в корне \In{e} и продолжи вычисления в соответствующей
альтернативе. Обратите внимание на то, что сопоставления с образцом
в альтернативах имеет только один уровень вложенности. 
Также аргумент \In{case}-выражения в отличие от функции не обязан
быть атомарным. 

Для тренировки перепишем на STG пример из раздела про ленивые вычисления.

\begin{code}
data Nat = Zero | Succ Nat

zero    = Zero
one     = Succ zero
two     = Succ one

foldNat :: a -> (a -> a) -> Nat -> a
foldNat z  s  Zero      = z
foldNat z  s  (Succ n)  = s (foldNat z s n)

add a = foldNat a   Succ
mul a = foldNat one (add a) 

exp = (\x -> add (add x x) x) (add Zero two)
\end{code}

Теперь в STG:

\begin{code}
data Nat = Zero | Succ Nat

zero    = CON(Zero)
one     = CON(Succ zero)
two     = CON(Succ one)

foldNat = FUN( z s arg -> 
            case arg of 
                Zero    -> z
                Succ n  -> let next = THUNK (foldNat z s n)
                           in  s next  
          )

add     = FUN( a ->
            let succ = FUN( x -> 
                        let r = CON(Succ x) 
                        in r)
            in  foldNat a succ
          )

mul     = FUN( a -> 
            let succ = THUNK (add a)
            in  foldNat one succ
          )

exp     = THUNK( 
            let f = FUN( x -> let axx = THUNK (add x x)
                              in  add axx x) 
                a = THUNK (add Zero two)
            in  f a    
          )
\end{code}    

Программа состоит из связок вида \In{имя = объектКучи}.
Эти связки называют глобальными, они становятся
статическими объектами кучи, остальные объекты
выделяются динамически в \In{let}-выражениях.
Глобальный объект типа \In{THUNK} называют 
постоянной аппликативной формой (constant applicative form или 
сокращённо CAF).

\subsection{Вычисление STG}

Итак у нас есть упрощённый функциональный язык. Как мы будем
вычислять выражения? Присутствие частичного применения усложняет
этот процесс. Для многих функций мы не знаем заранее их арность.
Так например в выражении

\begin{code}
f x y
\end{code}

Функция \In{f} может иметь один аргумент в определении, 
но вернуть функцию. Есть два способа вычисления таких функций:

\begin{itemize}
\item \emph{вставка-вход} (push-enter). Когда мы видим 
применение функции, мы сначала \emph{вставляем} все аргументы в стек,
затем совершаем \emph{вход} в тело функции. В процессе входа
мы вычисляем функцию \In{f} и узнаём число аргументов, которое
ей нужно, после этого мы извлекаем из стека необходимое число 
аргументов, и применяем к ним функцию, если мы снова получаем функцию,
тогда мы опять добираем необходимое число аргументов из стека.
И так пока аргументы в стеке не кончатся.

\item \emph{вычисление-применение} (eval-apply). Вместе с функцией
мы храним информацию о том, сколько аргументов ей нужно. 
Если это статически определённая функция 
(определение выписано пользователем), то число аргументов мы можем
понять по левой части определения. В этой стратегии, если число
аргументов известно, мы сразу \emph{вычисляем} значение с
нужным числом аргументов, сохранив оставшиеся в стеке, 
а затем извлекаем аргументы из стека и \emph{применяем}
к ним вычисленное значение.
\end{itemize}

Возвращаясь к исходному примеру, предположим, что арность
функции \In{f} равна единице. Тогда стратегия вставка-вход
сначала добавит на стек \In{x} и \In{y}, а затем будет добирать
из стека необходимые аргументы. Стратегия вычисление-применение
сначала вычислит \In{(f x)}, сохранив \In{y} на стеке, затем
попробует применить результат к \In{y}. Почему мы говорим
попробует? Может так случиться, что арность значения \In{f x}
окажется равным трём, но пока у нас есть лишь один аргумент,
тогда мы создадим объект \In{PAP}, который соответствует 
частичному применению. 

Эти стратегии применимы как к ленивым, так и к энергичным языкам. 
Исторически сложилось, что ленивые языки тяготеют к первой 
стратегии, а энергичные ко второй. До недавнего времени
и в GHC применялась первая стратегия. Пока однажды разработчики GHC 
всё же не решили сравнить две стратегии. Реализовав обе стратегии,
и проверив их на большом количестве разных по сложности программ,
они пришли к выводу, что ни одна из стратегий не даёт существенного
преимущества на этапе вычислений. Потребление ресурсов оказалось 
примерно равным. Но вторая стратегия заметно выигрывала
в простоте реализации. Подробнее об этом можно почитать в статье
Simon Marlow, Simon Peyton Jones:
Making a Fast Curry: Push/Enter vs. Eval/Apply.
Описание модели вычислений GHC, которое вы сейчас читаете
копирует описание приведённое в этой статье. 

\subsubsection{Куча}

Объекты кучи принято называть \emph{замыканиями} (closure).
Их называют так, потому что обычно для вычисления выражения
нам не достаточно знать его текст, например посмотрим на
функцию:

\begin{code}
mul     = FUN( a -> 
            let succ = THUNK (add a)
            in  foldNat one succ
          )
\end{code}

Для того, чтобы вычислить \In{THUNK(add a)} нам необходимо
знать значение \In{a}, это значение определено в теле функции.
Оно определяется из контекста. По отношению к объекту
такую переменную называют \emph{свободной} (free). 
В куче мы будем хранить не только выражение \In{(add a)},
но и ссылки на все свободные переменные, которые участвуют
в выражении объекта. Эти ссылки называют \emph{довесок} (payload).
Объект кучи содержит ссылку на специальную таблицу и довесок. 
В таблице находятся информация о типе объекта и 
код, который необходимо вычислить, а также другая 
служебная информация. При вычислении объекта мы заменяем
ссылки настоящими значениями или ссылками на конструкторы. 

Объект кучи может быть:

\begin{itemize}
\item \In{FUN} -- определением функции;
\item \In{PAP} -- частичным применением;
\item \In{CON} -- полностью применённым конструктором;
\item \In{THUNK} -- отложенным вычислением;
\item \In{BLACKHOLE} -- это значение используется во время вычисления
    \In{THUNK}. Этот трюк предотвращает появление утечек памяти. 
\end{itemize}

Мы будем считать, что куча -- это таблица, которая ставит 
в соответствие адресам объекты или вычисленные значения.


\subsubsection{Стек}

Стек служит для быстрого переключения контекста. Мы будем пользоваться
стеком при вычислении \In{case}-выражений и \In{THUNK}-объектов. 
При вычислении \In{case}-выражения мы сохраняем в стеке альтернативы
и место возврата значения, а сами начинаем вычислять аргумент
\In{case}-выражения. При вычислении \In{THUNK}-объекта мы запомним
в стеке, адрес с которым необходимо связать полученное значение. 

При вычислении в стратегии вставка-вход мы будем сохранять 
в стеке аргументы функции. А при вычислении в стратегии 
вычисление-применение мы также будем сохранять аргументы 
функции в стеке. Какая разница между этими вариантами?
В первой стратегии мы можем доставать из стека произвольное
число аргументов, после определения арности функции мы добираем столько,
сколько нам нужно, поэтому мы будем хранить аргументы по одному.
Во второй же стратегии нам нужно просто сохранить все оставшиеся
аргументы. Мы сохраняем и извлекаем их все сразу. Упрощая,
объекты стека можно представить так:

\[\begin{array}{llll}
k   & ::=  & \texttt{case } \bullet \texttt{ of } \{ alt_1; \dots alt_n \} & 
        \text{контекст \texttt{case}-выражения}  \\
    & \Or  & Upd\ \ t\ \ \bullet                &  
        \text{Обновить отложенное вычисление} \\
    & \Or  & (\bullet \ a_1 \dots a_n )     &  
        \text{Применить функцию к аргументам, только для} \\
    &      &                             &  
        \text{стратегии вычисление-применение} \\
    & \Or  & Arg\ a                      &  
        \text{Аргумент на потом, только для}  \\
    &      &                             &  
        \text{стратегии вставка-вход} \\ 
\end{array}\]



\subsubsection{Правила общие для обеих стратегий вычисления}

Состояние вычислителя состоит из трёх частей. Это выражение
для вычисления $e$, стек $s$ и куча $H$. Мы рассмотрим правила
по которым вычислитель переходит из одного состояния в другое.
Все они имеют вид:

\[ e_1;\quad s_1;\quad H_1\quad \RA\quad e_2;\quad s_2;\quad H_2 \]

Левая часть переходит в правую, при условии, что левая часть
имеет определённый вид. Начнём с правил, которые одинаковы и в той
и в другой стратегии вычисления. Для простоты пока мы будем полагать,
что объекты только добавляются в кучу и никогда не стираются.
Мы будем обозначать добавление в стек как добавление элемента 
в обычный список: $elem\ :\ s$. 

Рассмотрим правило для \In{let}-выражений:

\[ \texttt{let } x \texttt{ = } obj \texttt{ in } e;\quad s;\quad H 
    \quad \RA \quad e[x'/x]; \quad s ;\quad H[x' \Ra obj],\quad x' 
    \text{ -- новое имя} \]

В этом правиле мы добавляем в кучу новый объект $obj$ 
под именем (или по адресу) $x'$. Запись $e[x'/x]$ означает
замену $x$ на $x'$ в выражении $e$. 

Теперь разберёмся с правилами для \In{case}-выражений. 

\[\begin{array}{lll}
\texttt{case}\ v\ \texttt{of}\ \{\dots;C\ x_1\dots x_n \Ra e ;\dots\};
    &\quad \RA  \quad &  e[a_1/x_1 \dots a_n / x_n]; \quad s; \quad H \\
s;\quad H[v \Ra CON(C\ a_1\dots a_n)] & & \\    
\\
\texttt{case}\ v\ \texttt{of}\ \{\dots; x \Ra e\};\quad s;\quad H 
    &\quad \RA  \quad & e[v/x];\quad s; \quad  H \\
    & & \text{Если } v \text{ -- литерал или } H[v] \text{ -- значение,} \\
    & & \text{которое не подходит ни по одной из альтернатив} \\
\\
\texttt{case}\ e\ \texttt{of}\ \{\dots\};\quad s; \quad H 
    & \quad \RA \quad & e;\quad 
    \texttt{case}\ \bullet \ \texttt{of}\ \{\dots\}\ :\ s; \quad H \\
\\

v;\quad \texttt{case}\ \bullet \ \texttt{of}\ \{\dots\}\ :\ s; \quad H 
    & \quad \RA \quad & \texttt{case}\ v\ \texttt{of}\ \{\dots\}; 
    \quad s; \quad H \\ 
\end{array}\]


Вычисления начинаются с третьего правила, в котором нам встречается
\In{case}-выражения с произвольным $e$. В этом правиле мы сохраняем
в стеке альтернативы и адрес возвращаемого значения и продолжаем
вычисление выражения $e$. После вычисления мы перейдём к четвёртому правилу,
тогда мы снимем со стека информацию необходимую для продолжения вычисления
\In{case}-выражения. Это приведёт нас к одному из первых двух правил.
В первом правиле значение аргумента содержит конструктор, подходящий
по одной из альтернатив, а во втором мы выбираем альтернативу по умолчанию.

Теперь посмотрим как вычисляются \In{THUNK}-объекты.

\[\begin{array}{lll}
x;\quad s; \quad H[x \Ra THUNK\ e]  &\quad \RA  \quad & 
    e; \quad Upd\ \ x\ \ \bullet\ :\ s; \quad H[x \Ra BLACKHOLE] \\
\\

y;\quad Upd\ \ x\ \ \bullet\ :\ s; \quad H
&\quad \RA  \quad & y; \quad s; \quad H[x \Ra H[y]] \\ 
& & \text{если } H[y] \text{ является значением} \\
\end{array}\]

Если переменная указывает на отложенное вычисление $e$, 
мы сохраняем в стеке адрес по которому необходимо обновить
значение и вычисляем значение $e$. В это время мы записываем
в по адресу $x$ объект $BLACKHOLE$. У нас нет такого правила,
которое реагирует на левую часть, если в ней содержится
объект $BLACKHOLE$. Поэтому во время вычисления $THUNK$ 
ни одно из правил сработать не может. Этот трюк необходим
для избежания утечек памяти. Как только выражнение будет
вычислено мы извлечём из стека адрес $x$ и обновим значение.

Правила применения функций, если арность совпадает
с числом аргументов в тексте выражения:

\[\begin{array}{lll}
f^n\ a_1 \dots a_n; \quad s; \quad H[y \Ra FUN(x_1 \dots x_n \Ra e)] 
&\quad \RA  \quad &  e[a_1/x_1 \dots a_n/x_n]; s; H \\
\\
\oplus\ a_1 \dots a_n; \quad s; \quad H
&\quad \RA  \quad & a;\quad s;\quad H \\
& & a \text{ -- результат вычисления } (\oplus\ a_1 \dots a_n)  \\
\end{array}\]

Мы просто заменяем все вхождения аргументов на значения. Второе
правило выполняет применение примитивной функции к значениям.

\subsubsection{Правила для стратегии вставка-вход}

\[\begin{array}{lll}
f^k\ a_1 \dots a_m ; \quad s; \quad H 
&\quad \RA  \quad &  f ;\quad Arg\ a_1: \text{\dots} : \ Arg\ a_m \ :\ s ;\quad H \\
\\
\multicolumn{3}{l}{f; \quad Arg\ a_1: \text{\dots} : \ Arg\ a_n \ :\ s ;\quad 
    H[f \Ra FUN(x_1 \dots x_n \Ra e)]} \\ 
&\quad \RA  \quad & e[a_1/x_1 \dots a_n/x_n] ;\quad s; \quad H \\
\\
\multicolumn{3}{l}{f; \quad Arg\ a_1: \text{\dots} : \ Arg\ a_m \ :\ s ;\quad 
    H[f \Ra FUN(x_1 \dots x_n \Ra e)]} \\ 
&\quad \RA  \quad & p;\quad s; \quad H[p \Ra PAP(f\ a_1 \dots a_m)] \\
&  & \text{при } m \geq 1;\ m < n;\ \text{верхний элемент } s \\
&  & \text{ не является } Arg;\ p\ \text{-- новый адрес} \\
\\
\multicolumn{3}{l}{f; \quad Arg\ a_{n+1}\ :\ s;
    \quad H[f \Ra PAP(g\ a_1 \dots a_n)]} \\
&\quad \RA  \quad & g;\quad 
    Arg\ a_1: \text{\dots} : \ Arg\ a_n \ : \ Arg\ a_{n+1} \ :\ s ;\quad H
\end{array}\]

Первое правило выполняет этап \Quote{вставка}. 
Если мы видим применение функции,
мы первым делом сохраняем все аргументы в стеке. Во втором
правиле мы вычислили значение \In{f}, оно оказалось
функцией с арностью $n$. Тогда мы добираем из стека $n$ 
аргументов и подставляем их в правую часть функции $e$.
Если  в стеке оказалось слишком мало аргументов,
то мы переходим к третьему правилу и составляем 
частичное применение. Последнее правило говорит о том как
расшифровывается частичное применение. Мы вставляем в стек
все аргументы и начинаем вычисление функции $g$ из тела $PAP$.



\subsubsection{Правила для стратегии вычисление-применение}

\[\begin{array}{lll}
\multicolumn{3}{l}{f^{\bullet}\ a_1 \dots a_n;\quad s;\quad 
    H[f \Ra FUN(x_1 \dots x_n \Ra e)]} \\
    & \quad \RA  \quad &  e[a_1/x_1 \dots a_n/x_n];\quad s;\quad H \\
\\
\multicolumn{3}{l}{f^k\ a_1 \dots a_m;\quad s;\quad 
    H[f \Ra FUN(x_1 \dots x_n \Ra e)]} \\
    & \quad \RA  \quad &  e[a_1/x_1 \dots a_n/x_n];\quad 
        (\bullet \ a_{n+1} \dots a_m)\ :\ s;\quad H \\ 
    & &  \text{при } m \geq n \\
    & \quad \RA  \quad & p;\quad s ;\quad H[p \Ra PAP(f\ a_1 \dots a_m)] \\
    & &  \text{при } m < n,\ p \text{ -- новый адрес} \\
    \\
\multicolumn{3}{l}{f^{\bullet}\ a_1 \dots a_m;\quad s;\quad 
    H[f \Ra THUNK\ e]} \\
    & \quad \RA  \quad &  f;\quad (\bullet \ a_1 \dots a_m)\ :\ s;\quad H \\ 
\\
\multicolumn{3}{l}{f^k\ a_{n+1} \dots a_m;\quad s;\quad 
    H[f \Ra PAP(g\ a_1 \dots a_n)]} \\
    & \quad \RA  \quad &  g^\bullet\ a_1 \dots a_n\ a_{n+1} \dots a_m; 
        \quad s; \quad H \\ 
\\
f;\quad (\bullet \ a_1 \dots a_n)\ :\ s;\quad H 
    & \quad \RA  \quad & f^\bullet\ a_1 \dots a_n;\quad s;\quad H \\ 
    & & H[f] \text{ является } FUN \text{ или } PAP
\\
\end{array}\]

Разберёмся с первыми двумя правилами.
В первом правиле статическая арность $f$ неизвестна, но
значение $f$ уже вычислено, и мы можем узнать арность по
объекту $FUN$, далее возможны три случая. Число аргументов
переданных в функцию совпадает с арностью $FUN$, тогда
мы применяем аргументы к правой части $FUN$. Если
в функцию передано больше аргументов чем нужно, мы 
сохраняем лишние на стеке. Если же аргументов меньше,
то мы создаём объект $PAP$. 
Третье правило говорит о том, что нам делать, если значение
$f$ ещё не вычислено. Оно является $THUNK$. Тогда мы 
сохраним аргументы на стеке и вычислим его. В следующем
правиле мы раскрываем частичное применение. Мы просто
организуем вызов функции со всеми аргументами (и со стека
и из частичного применения). Последнее правило срабатывает
после третьего. Когда мы вычислим $THUNK$ и увидим там 
$FUN$ или $PAP$. Тогда мы составляем применение функции.  

Сложность применения стратегии вставка-вход связана
с плохо предсказуемым изменением стека. Если в стратегии вычисление-выполнение
мы добавляем и снимаем все аргументы, то в стратегии вставка-вход
мы добавляем их по одному и неизвестно сколько снимем в следующий раз.
Кроме того стратегия вычисление-применение позволяет проводить
оптимизацию перемещения аргументов. Вместо стека мы можем хранить
аргументы в регистрах. Тогда скорость обращения к аргументам
резко возрастёт. 

\subsection{Управление памятью. Сборщик мусора}

В прошлом разделе для простоты мы считали, что объекты только добавляются
на кучу. На самом деле это не так. Допустим во время вычисления функции
нам нужно было вычислить какие-то промежуточные данные, например
объявленные в локальных переменных, тогда после вычисления результата
все эти значения больше не нужны. При этом в куче висит
много-много объектов, которые уже не нужны. Нам нужно 
как-то от них избавится. Этой задачей занимается отдельный 
блок компилятора, который называется \emph{сборщиком мусора} 
(garbage collector), соответственно процесс автоматического
освобождения памяти называется сборкой мусора (garbage collection или GC).

На данный момент в GHC используется копирующий последовательный
сборщик мусора, который работает по алгоритму Чейни (Cheney). 
Изначально под кучу выделяется небольшая область памяти,
по умолчанию 512 Кб (эта цифра может изменится). 
Эта область разделена на две части. 
Сначала мы создаём объекты в одной половине, как только при
выполнении \In{let} оказывается, что мы исчерпали доступную память.
Мы копируем из текущей половины в другую все \Quote{живые} объекты.
Теперь эта половина считается свободной. Этот этап называется
поверхностной очисткой (minor GC). Если после поверхностной
очистки памяти оказалось недостаточно. Начинается 
глубокая очистка (major GC).
Мы просматриваем обе половины и ищем там все живые объекты.
Для этих объектов мы выделяем новую область памяти и 
копируем их туда. После этого вся прежняя память считается свободной.
Мы выделяем столько памяти, сколько осталось живых объектов. 
Так например, если у нас было выделено 30 Мб памяти и оказалось,
что живые объекты занимают 10 Мб, мы выделим ещё 10 Мб, скопируем
туда все живые объекты и общий объём памяти станет равным 40 Мб.

Поверхностная очистка происходит в младшем поколении, а
глубокая в старшем поколении. Мы можем изменять размеры
выделенной памяти с помощью специальных флагов. 
Эти флаги предназнчены для вычислителя низкого уровня
(realtime system или RTS), они заключаются в окружение 
\In{+RTS ... -RTS}, если флаги идут в конце строки и считается,
что все последующие флаги предназначены для \In{RTS}
мы можем просто написать \In{ghc --make file.hs +RTS ...}
Все флаги можно посмотреть в документации GHC. Мы обратим
внимание на несколько флагов. Для начала посмотрим на
флаги \In{s[file]} и \In{S[file]} они позволяют посмотреть
на статистику выполнения программы. Например запустим программу
    
\begin{code}

\end{code}



,



Пока мы ищем мы копируем эти объекты в новую область памяти

оказалось, что 
в другой половине нам не хватило места для всех живых объект


\begin{code}
\end{code}

\begin{code}
\end{code}

\begin{code}
\end{code}

\begin{code}
\end{code}


\subsection{Оптимизация программ}

\subsection{Просмотр показателей вычисления в GHC}
\begin{code}
\end{code}

\begin{code}
\end{code}


